package cmd

import (
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/charmbracelet/lipgloss"
	"github.com/josephgoksu/TaskWing/internal/app"
	"github.com/josephgoksu/TaskWing/internal/task"
	"github.com/josephgoksu/TaskWing/internal/ui"
	"github.com/spf13/cobra"
)

var taskCmd = &cobra.Command{
	Use:   "task",
	Short: "Manage execution tasks",
	Long:  `View and manage tasks generated by the planning agent.`,
}

var taskListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all tasks",
	Long:  `List all tasks, grouped by plan. Use --plan to filter by a specific plan.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		repo, err := openRepo()
		if err != nil {
			return err
		}
		defer func() { _ = repo.Close() }()

		planFilter, _ := cmd.Flags().GetString("plan")

		plans, err := repo.ListPlans()
		if err != nil {
			return err
		}

		if len(plans) == 0 {
			if isJSON() {
				return printJSON([]any{})
			}
			fmt.Println("No plans found. Create one with: tw plan new \"Your goal\"")
			return nil
		}

		// Handle JSON output
		if isJSON() {
			type taskJSON struct {
				ID                     string   `json:"id"`
				PlanID                 string   `json:"plan_id"`
				Title                  string   `json:"title"`
				Description            string   `json:"description"`
				Status                 string   `json:"status"`
				Priority               int      `json:"priority"`
				Agent                  string   `json:"assigned_agent"`
				Acceptance             []string `json:"acceptance_criteria"`
				Validation             []string `json:"validation_steps"`
				Scope                  string   `json:"scope"`
				Keywords               []string `json:"keywords"`
				SuggestedRecallQueries []string `json:"suggestedRecallQueries"`
			}
			var allTasks []taskJSON
			for _, p := range plans {
				if planFilter != "" && !strings.HasPrefix(p.ID, planFilter) {
					continue
				}
				tasks, _ := repo.ListTasks(p.ID)
				for _, t := range tasks {
					allTasks = append(allTasks, taskJSON{
						ID:                     t.ID,
						PlanID:                 p.ID,
						Title:                  t.Title,
						Description:            t.Description,
						Status:                 string(t.Status),
						Priority:               t.Priority,
						Agent:                  t.AssignedAgent,
						Acceptance:             t.AcceptanceCriteria,
						Validation:             t.ValidationSteps,
						Scope:                  t.Scope,
						Keywords:               t.Keywords,
						SuggestedRecallQueries: t.SuggestedRecallQueries,
					})
				}
			}
			return printJSON(allTasks)
		}

		// Render header
		ui.RenderPageHeader("TaskWing Task List", "")

		// Styles
		planHeader := lipgloss.NewStyle().
			Foreground(lipgloss.Color("205")).
			Bold(true)
		taskID := lipgloss.NewStyle().
			Foreground(lipgloss.Color("241"))
		statusPending := lipgloss.NewStyle().
			Foreground(lipgloss.Color("214"))
		statusDone := lipgloss.NewStyle().
			Foreground(lipgloss.Color("42"))
		priority := lipgloss.NewStyle().
			Foreground(lipgloss.Color("75"))
		subtle := lipgloss.NewStyle().
			Foreground(lipgloss.Color("241"))

		totalTasks := 0
		plansShown := 0

		for _, p := range plans {
			// Filter by plan ID if specified
			if planFilter != "" && !strings.HasPrefix(p.ID, planFilter) {
				continue
			}

			tasks, _ := repo.ListTasks(p.ID)
			if len(tasks) == 0 {
				continue
			}

			plansShown++
			totalTasks += len(tasks)

			// Truncate goal for display
			goal := p.Goal
			if len(goal) > 60 {
				goal = goal[:57] + "..."
			}

			// Plan header
			fmt.Printf("\n%s %s\n", planHeader.Render("‚óÜ"), planHeader.Render(goal))
			fmt.Printf("  %s %s\n\n", subtle.Render("Plan:"), subtle.Render(p.ID))

			// Column headers
			fmt.Printf("  %-14s %-12s %4s   %s\n",
				subtle.Render("ID"),
				subtle.Render("STATUS"),
				subtle.Render("PRI"),
				subtle.Render("TITLE"))

			// Tasks
			for _, t := range tasks {
				// Format status with color
				var statusStr string
				switch t.Status {
				case "done", "completed":
					statusStr = statusDone.Render("[done]")
				case "in_progress":
					statusStr = statusPending.Render("[in-prog]")
				default:
					statusStr = statusPending.Render("[pending]")
				}

				// Truncate title
				title := t.Title
				if len(title) > 50 {
					title = title[:47] + "..."
				}

				// Format task ID (shorter display)
				tid := t.ID
				if len(tid) > 12 {
					tid = tid[:12]
				}

				fmt.Printf("  %-14s %-12s %s   %s\n",
					taskID.Render(tid),
					statusStr,
					priority.Render(fmt.Sprintf("%3d", t.Priority)),
					title)
			}
		}

		if plansShown == 0 && planFilter != "" {
			fmt.Printf("\nNo plan found matching: %s\n", planFilter)
			fmt.Println("Run 'taskwing plan list' to see available plans.")
		} else {
			fmt.Printf("\n%s\n", subtle.Render(fmt.Sprintf("Total: %d tasks across %d plan(s)", totalTasks, plansShown)))
		}

		return nil
	},
}

var taskShowCmd = &cobra.Command{
	Use:   "show [task-id]",
	Short: "Show a task",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		taskID := args[0]
		repo, err := openRepo()
		if err != nil {
			return err
		}
		defer func() { _ = repo.Close() }()

		t, err := repo.GetTask(taskID)
		if err != nil {
			return err
		}

		if isJSON() {
			return printJSON(t)
		}

		fmt.Printf("Task: %s\n", t.ID)
		fmt.Printf("Plan: %s\n", t.PlanID)
		fmt.Printf("Title: %s\n", t.Title)
		if t.Description != "" {
			fmt.Printf("Description: %s\n", t.Description)
		}
		fmt.Printf("Status: %s\n", t.Status)
		fmt.Printf("Priority: %d\n", t.Priority)
		if t.AssignedAgent != "" {
			fmt.Printf("Assigned Agent: %s\n", t.AssignedAgent)
		}
		if len(t.AcceptanceCriteria) > 0 {
			fmt.Println("\nAcceptance Criteria:")
			for _, a := range t.AcceptanceCriteria {
				fmt.Printf("  - %s\n", a)
			}
		}
		if len(t.ValidationSteps) > 0 {
			fmt.Println("\nValidation Steps:")
			for _, v := range t.ValidationSteps {
				fmt.Printf("  - %s\n", v)
			}
		}
		return nil
	},
}

var taskUpdateCmd = &cobra.Command{
	Use:   "update [task-id]",
	Short: "Update a task",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		taskID := args[0]
		statusStr, _ := cmd.Flags().GetString("status")
		if statusStr == "" {
			return fmt.Errorf("status is required")
		}
		status := task.TaskStatus(statusStr)
		if !isValidTaskStatus(status) {
			return fmt.Errorf("invalid status: %s", statusStr)
		}

		repo, err := openRepo()
		if err != nil {
			return err
		}
		defer func() { _ = repo.Close() }()

		if err := repo.UpdateTaskStatus(taskID, status); err != nil {
			return err
		}

		if isJSON() {
			updated, _ := repo.GetTask(taskID)
			return printJSON(updated)
		}

		if !isQuiet() {
			fmt.Printf("‚úì Updated task %s\n", taskID)
		}
		return nil
	},
}

var (
	taskCompleteSummary string
	taskCompleteFiles   []string
)

var taskCompleteCmd = &cobra.Command{
	Use:   "complete [task-id]",
	Short: "Mark a task as completed",
	Long: `Mark a task as completed with optional summary and file list.

When all tasks in a plan are completed:
- Runs audit verification automatically
- Creates PR if audit passes (requires gh CLI)
- Commits and pushes changes to git`,
	Args: cobra.ExactArgs(1),
	RunE: runTaskComplete,
}

func runTaskComplete(cmd *cobra.Command, args []string) error {
	taskID := args[0]
	repo, err := openRepo()
	if err != nil {
		return err
	}
	defer func() { _ = repo.Close() }()

	// Use TaskApp for complete - single source of truth
	appCtx := app.NewContext(repo)
	taskApp := app.NewTaskApp(appCtx)

	ctx := context.Background()
	result, err := taskApp.Complete(ctx, app.TaskCompleteOptions{
		TaskID:        taskID,
		Summary:       taskCompleteSummary,
		FilesModified: taskCompleteFiles,
	})
	if err != nil {
		return fmt.Errorf("complete task: %w", err)
	}

	if !result.Success {
		return fmt.Errorf("%s", result.Message)
	}

	if isJSON() {
		return printJSON(result)
	}

	if !isQuiet() {
		fmt.Printf("‚úì %s\n", result.Message)
		if result.Hint != "" {
			fmt.Printf("  %s\n", result.Hint)
		}
		if result.GitWorkflowApplied {
			fmt.Printf("  Git: committed to %s\n", result.GitBranch)
		}
		if result.PRCreated {
			fmt.Printf("  PR: %s\n", result.PRURL)
		}
	}
	return nil
}

var taskDeleteCmd = &cobra.Command{
	Use:   "delete [task-id]",
	Short: "Delete a task",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		taskID := args[0]
		force, _ := cmd.Flags().GetBool("force")

		repo, err := openRepo()
		if err != nil {
			return err
		}
		defer func() { _ = repo.Close() }()

		if !force && !isJSON() {
			t, err := repo.GetTask(taskID)
			if err != nil {
				return err
			}
			fmt.Printf("\n  Task:  %s\n", t.ID)
			fmt.Printf("  Title: %s\n\n", t.Title)
			if !confirmOrAbort("‚ö†Ô∏è  Delete this task? [y/N]: ") {
				return nil
			}
		}

		if err := repo.DeleteTask(taskID); err != nil {
			return err
		}

		if isJSON() {
			return printJSON(deleteResult{
				ID:      taskID,
				Deleted: true,
			})
		}

		if !isQuiet() {
			fmt.Printf("‚úì Deleted task %s\n", taskID)
		}
		return nil
	},
}

var taskValidateCmd = &cobra.Command{
	Use:   "validate [task-id]",
	Short: "Validate a task (Placeholder)",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("üïµÔ∏è  Validation agent coming in V2.1")
		fmt.Println("    For now, please run the validation steps manually:")

		// Logic to fetch task and print validation steps would go here
	},
}

// taskNextCmd gets the next pending task
var taskNextCmd = &cobra.Command{
	Use:   "next",
	Short: "Get the next pending task",
	Long: `Get the next pending task from the active plan (or specified plan).

Optionally auto-start the task by providing a session ID.
Git workflow creates a feature branch on first task.

Examples:
  taskwing task next
  taskwing task next --plan p-abc123
  taskwing task next --auto-start --session my-session`,
	RunE: runTaskNext,
}

var (
	taskNextPlanID            string
	taskNextSessionID         string
	taskNextAutoStart         bool
	taskNextCreateBranch      bool
	taskNextSkipUnpushedCheck bool
)

func runTaskNext(cmd *cobra.Command, args []string) error {
	repo, err := openRepo()
	if err != nil {
		return err
	}
	defer func() { _ = repo.Close() }()

	appCtx := app.NewContext(repo)
	taskApp := app.NewTaskApp(appCtx)

	if !isQuiet() && !isJSON() {
		fmt.Fprint(os.Stderr, "üîç Getting next task...")
	}

	ctx := context.Background()
	result, err := taskApp.Next(ctx, app.TaskNextOptions{
		PlanID:            taskNextPlanID,
		SessionID:         taskNextSessionID,
		AutoStart:         taskNextAutoStart,
		CreateBranch:      taskNextCreateBranch,
		SkipUnpushedCheck: taskNextSkipUnpushedCheck,
	})
	if err != nil {
		return err
	}

	if !isQuiet() && !isJSON() {
		fmt.Fprintln(os.Stderr, " done")
	}

	if isJSON() {
		return printJSON(result)
	}

	if !result.Success {
		fmt.Printf("‚ö†Ô∏è  %s\n", result.Message)
		if result.Hint != "" {
			fmt.Printf("üí° %s\n", result.Hint)
		}
		return nil
	}

	if result.Task == nil {
		fmt.Printf("‚úì %s\n", result.Message)
		if result.Hint != "" {
			fmt.Printf("üí° %s\n", result.Hint)
		}
		return nil
	}

	// Show task details
	ui.RenderPageHeader("Next Task", "")

	if result.GitWorkflowApplied {
		fmt.Printf("üåø Branch: %s\n\n", result.GitBranch)
	}

	fmt.Printf("üìã %s\n", result.Task.Title)
	fmt.Printf("   ID: %s\n", result.Task.ID)
	fmt.Printf("   Status: %s\n", result.Task.Status)
	fmt.Printf("   Priority: %d\n", result.Task.Priority)

	if result.Task.Description != "" {
		fmt.Printf("\nüìù %s\n", result.Task.Description)
	}

	if result.Hint != "" {
		fmt.Printf("\nüí° %s\n", result.Hint)
	}

	return nil
}

// taskCurrentCmd shows the current in-progress task
var taskCurrentCmd = &cobra.Command{
	Use:   "current",
	Short: "Show the current in-progress task",
	Long: `Show the task currently being worked on.

Looks up by session ID first, then falls back to any in-progress task in the active plan.

Examples:
  taskwing task current
  taskwing task current --session my-session`,
	RunE: runTaskCurrent,
}

var (
	taskCurrentSessionID string
	taskCurrentPlanID    string
)

func runTaskCurrent(cmd *cobra.Command, args []string) error {
	repo, err := openRepo()
	if err != nil {
		return err
	}
	defer func() { _ = repo.Close() }()

	appCtx := app.NewContext(repo)
	taskApp := app.NewTaskApp(appCtx)

	ctx := context.Background()
	result, err := taskApp.Current(ctx, taskCurrentSessionID, taskCurrentPlanID)
	if err != nil {
		return err
	}

	if isJSON() {
		return printJSON(result)
	}

	if !result.Success || result.Task == nil {
		fmt.Printf("‚ÑπÔ∏è  %s\n", result.Message)
		if result.Hint != "" {
			fmt.Printf("üí° %s\n", result.Hint)
		}
		return nil
	}

	// Show task details
	ui.RenderPageHeader("Current Task", "")

	fmt.Printf("üìã %s\n", result.Task.Title)
	fmt.Printf("   ID: %s\n", result.Task.ID)
	fmt.Printf("   Status: %s\n", result.Task.Status)
	if !result.Task.ClaimedAt.IsZero() {
		fmt.Printf("   Started: %s\n", result.Task.ClaimedAt.Format("2006-01-02 15:04"))
	}

	if result.Task.Description != "" {
		fmt.Printf("\nüìù %s\n", result.Task.Description)
	}

	return nil
}

// taskStartCmd claims a specific task
var taskStartCmd = &cobra.Command{
	Use:   "start [task-id]",
	Short: "Start working on a specific task",
	Long: `Claim a task and mark it as in-progress.

Requires a session ID to track which session owns the task.

Examples:
  taskwing task start t-abc123 --session my-session`,
	Args: cobra.ExactArgs(1),
	RunE: runTaskStart,
}

var taskStartSessionID string

func runTaskStart(cmd *cobra.Command, args []string) error {
	taskID := args[0]

	if taskStartSessionID == "" {
		return fmt.Errorf("--session is required")
	}

	repo, err := openRepo()
	if err != nil {
		return err
	}
	defer func() { _ = repo.Close() }()

	appCtx := app.NewContext(repo)
	taskApp := app.NewTaskApp(appCtx)

	ctx := context.Background()
	result, err := taskApp.Start(ctx, app.TaskStartOptions{
		TaskID:    taskID,
		SessionID: taskStartSessionID,
	})
	if err != nil {
		return err
	}

	if isJSON() {
		return printJSON(result)
	}

	if !result.Success {
		fmt.Printf("‚ö†Ô∏è  %s\n", result.Message)
		return nil
	}

	fmt.Printf("‚úì Started task: %s\n", result.Task.Title)
	fmt.Printf("  ID: %s\n", result.Task.ID)

	if result.Hint != "" {
		fmt.Printf("\nüí° %s\n", result.Hint)
	}

	return nil
}

func init() {
	rootCmd.AddCommand(taskCmd)
	taskCmd.AddCommand(taskListCmd)
	taskCmd.AddCommand(taskShowCmd)
	taskCmd.AddCommand(taskUpdateCmd)
	taskCmd.AddCommand(taskCompleteCmd)
	taskCmd.AddCommand(taskDeleteCmd)
	taskCmd.AddCommand(taskValidateCmd)
	taskCmd.AddCommand(taskNextCmd)
	taskCmd.AddCommand(taskCurrentCmd)
	taskCmd.AddCommand(taskStartCmd)

	// Task list flags
	taskListCmd.Flags().StringP("plan", "p", "", "Filter by plan ID (prefix match)")
	taskUpdateCmd.Flags().String("status", "", "Update the task status (draft, pending, in_progress, verifying, completed, failed)")
	taskDeleteCmd.Flags().BoolP("force", "f", false, "Skip confirmation prompt")

	// Task complete flags
	taskCompleteCmd.Flags().StringVar(&taskCompleteSummary, "summary", "", "Summary of what was accomplished")
	taskCompleteCmd.Flags().StringSliceVar(&taskCompleteFiles, "files", nil, "Files that were modified (comma-separated)")

	// Task next flags
	taskNextCmd.Flags().StringVar(&taskNextPlanID, "plan", "", "Specific plan ID (defaults to active plan)")
	taskNextCmd.Flags().StringVar(&taskNextSessionID, "session", "", "Session ID for auto-start")
	taskNextCmd.Flags().BoolVar(&taskNextAutoStart, "auto-start", false, "Automatically claim the task")
	taskNextCmd.Flags().BoolVar(&taskNextCreateBranch, "create-branch", false, "Create a new git branch for this plan")
	taskNextCmd.Flags().BoolVar(&taskNextSkipUnpushedCheck, "skip-unpushed-check", false, "Proceed despite unpushed commits (only with --create-branch)")

	// Task current flags
	taskCurrentCmd.Flags().StringVar(&taskCurrentSessionID, "session", "", "Session ID to look up")
	taskCurrentCmd.Flags().StringVar(&taskCurrentPlanID, "plan", "", "Plan ID to search in")

	// Task start flags
	taskStartCmd.Flags().StringVar(&taskStartSessionID, "session", "", "Session ID (required)")
}

// isValidTaskStatus validates task status values
func isValidTaskStatus(status task.TaskStatus) bool {
	switch status {
	case task.StatusDraft, task.StatusPending, task.StatusInProgress, task.StatusVerifying, task.StatusCompleted, task.StatusFailed:
		return true
	default:
		return false
	}
}
