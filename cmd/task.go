package cmd

import (
	"context"
	"fmt"
	"os"
	"strings"

	"github.com/charmbracelet/lipgloss"
	"github.com/josephgoksu/TaskWing/internal/app"
	"github.com/josephgoksu/TaskWing/internal/task"
	"github.com/josephgoksu/TaskWing/internal/ui"
	"github.com/josephgoksu/TaskWing/internal/util"
	"github.com/spf13/cobra"
)

var taskCmd = &cobra.Command{
	Use:   "task",
	Short: "Manage execution tasks",
	Long:  `View and manage tasks generated by the planning agent.`,
}

var taskListCmd = &cobra.Command{
	Use:   "list",
	Short: "List all tasks",
	Long: `List all tasks, grouped by plan.

By default, tasks from archived plans are excluded. Use --include-archived to show them.

Filter options:
  --plan              Filter by plan ID (prefix match)
  --status            Filter by status (pending, in_progress, completed, failed)
  --priority          Filter by priority threshold (show tasks with priority <= value)
  --scope             Filter by scope/tag
  --include-archived  Include tasks from archived plans

Examples:
  taskwing task list                    # All tasks (excludes archived plans)
  taskwing task list --include-archived # Include archived plan tasks
  taskwing task list --status pending   # Only pending tasks
  taskwing task list --priority 50      # High priority tasks only
  taskwing task list --scope api        # Tasks in api scope`,
	RunE: runTaskList,
}

func runTaskList(cmd *cobra.Command, args []string) error {
	repo, err := openRepoOrHandleMissingMemory()
	if err != nil {
		return err
	}
	if repo == nil {
		return nil
	}
	defer func() { _ = repo.Close() }()

	// Get filter flags
	planFilter, _ := cmd.Flags().GetString("plan")
	statusFilter, _ := cmd.Flags().GetString("status")
	priorityFilter, _ := cmd.Flags().GetInt("priority")
	scopeFilter, _ := cmd.Flags().GetString("scope")
	includeArchived, _ := cmd.Flags().GetBool("include-archived")

	plans, err := repo.ListPlans()
	if err != nil {
		return fmt.Errorf("failed to list plans: %w", err)
	}

	if len(plans) == 0 {
		if isJSON() {
			return printJSON([]any{})
		}
		fmt.Println("No plans found. Create one with: taskwing goal \"Your goal\"")
		return nil
	}

	// Collect and filter tasks
	type taskWithPlan struct {
		Task       task.Task
		PlanID     string
		PlanStatus task.PlanStatus
		Goal       string
	}
	var allTasks []taskWithPlan

	for _, p := range plans {
		// Skip archived plans by default unless --include-archived is set
		if !includeArchived && p.Status == task.PlanStatusArchived {
			continue
		}
		if planFilter != "" && !strings.HasPrefix(p.ID, planFilter) {
			continue
		}
		tasks, err := repo.ListTasks(p.ID)
		if err != nil {
			return fmt.Errorf("failed to list tasks for plan %s: %w", p.ID, err)
		}
		for _, t := range tasks {
			// Apply filters
			if statusFilter != "" && string(t.Status) != statusFilter {
				continue
			}
			if priorityFilter > 0 && t.Priority > priorityFilter {
				continue
			}
			if scopeFilter != "" && !strings.Contains(strings.ToLower(t.Scope), strings.ToLower(scopeFilter)) {
				// Also check keywords
				found := false
				for _, kw := range t.Keywords {
					if strings.Contains(strings.ToLower(kw), strings.ToLower(scopeFilter)) {
						found = true
						break
					}
				}
				if !found {
					continue
				}
			}
			allTasks = append(allTasks, taskWithPlan{Task: t, PlanID: p.ID, PlanStatus: p.Status, Goal: p.Goal})
		}
	}

	// Handle JSON output
	if isJSON() {
		type taskJSON struct {
			ID                     string   `json:"id"`
			PlanID                 string   `json:"plan_id"`
			PlanStatus             string   `json:"plan_status"`
			Title                  string   `json:"title"`
			Description            string   `json:"description"`
			Status                 string   `json:"status"`
			Priority               int      `json:"priority"`
			Agent                  string   `json:"assigned_agent"`
			Acceptance             []string `json:"acceptance_criteria"`
			Validation             []string `json:"validation_steps"`
			Scope                  string   `json:"scope"`
			Keywords               []string `json:"keywords"`
			SuggestedAskQueries []string `json:"suggestedAskQueries"`
		}
		var jsonTasks []taskJSON
		for _, tp := range allTasks {
			t := tp.Task
			jsonTasks = append(jsonTasks, taskJSON{
				ID:                     t.ID,
				PlanID:                 tp.PlanID,
				PlanStatus:             string(tp.PlanStatus),
				Title:                  t.Title,
				Description:            t.Description,
				Status:                 string(t.Status),
				Priority:               t.Priority,
				Agent:                  t.AssignedAgent,
				Acceptance:             t.AcceptanceCriteria,
				Validation:             t.ValidationSteps,
				Scope:                  t.Scope,
				Keywords:               t.Keywords,
				SuggestedAskQueries: t.SuggestedAskQueries,
			})
		}
		return printJSON(jsonTasks)
	}

	// Render styled table
	ui.RenderPageHeader("TaskWing Task List", "")

	if len(allTasks) == 0 {
		subtle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))
		fmt.Println(subtle.Render("\nNo tasks match the filters."))
		if statusFilter != "" || priorityFilter > 0 || scopeFilter != "" {
			fmt.Println(subtle.Render("Try adjusting your filter criteria."))
		}
		return nil
	}

	// Styles for colored output
	idStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("14")).Bold(true) // Cyan, bold
	titleStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("255"))        // White
	scopeStyle := lipgloss.NewStyle().Foreground(lipgloss.Color("241")).Italic(true)
	subtle := lipgloss.NewStyle().Foreground(lipgloss.Color("241"))

	// Group tasks by plan for display
	tasksByPlan := make(map[string][]taskWithPlan)
	planOrder := []string{}
	for _, tp := range allTasks {
		if _, exists := tasksByPlan[tp.PlanID]; !exists {
			planOrder = append(planOrder, tp.PlanID)
		}
		tasksByPlan[tp.PlanID] = append(tasksByPlan[tp.PlanID], tp)
	}

	planHeader := lipgloss.NewStyle().Foreground(lipgloss.Color("205")).Bold(true)

	for _, planID := range planOrder {
		tasks := tasksByPlan[planID]
		if len(tasks) == 0 {
			continue
		}

		// Plan header
		goal := tasks[0].Goal
		if len(goal) > 60 {
			goal = goal[:57] + "..."
		}
		fmt.Printf("\n%s %s\n", planHeader.Render("â—†"), planHeader.Render(goal))
		fmt.Printf("  %s\n", subtle.Render(planID))

		// Table header
		fmt.Printf("\n  %-14s %-10s %4s  %-8s  %s\n",
			subtle.Render("ID"),
			subtle.Render("STATUS"),
			subtle.Render("PRI"),
			subtle.Render("SCOPE"),
			subtle.Render("TITLE"))
		fmt.Println(subtle.Render("  " + strings.Repeat("â”€", 80)))

		// Task rows
		for _, tp := range tasks {
			t := tp.Task

			// ID - Cyan and bold, use ShortID for consistent display
			// Full task IDs are 13 chars (task-xxxxxxxx), display fits in 14-char column
			tid := util.ShortID(t.ID, util.TaskIDLength)
			idStr := idStyle.Render(tid)

			// Status - Color coded
			statusStr := formatTaskStatus(t.Status)

			// Priority - Color coded by urgency
			priStr := formatPriority(t.Priority)

			// Scope
			scope := t.Scope
			if scope == "" && len(t.Keywords) > 0 {
				scope = t.Keywords[0]
			}
			if len(scope) > 8 {
				scope = scope[:7] + "â€¦"
			}
			scopeStr := scopeStyle.Render(fmt.Sprintf("%-8s", scope))

			// Title
			title := t.Title
			if len(title) > 45 {
				title = title[:42] + "..."
			}
			titleStr := titleStyle.Render(title)

			fmt.Printf("  %-14s %-10s %s  %s  %s\n", idStr, statusStr, priStr, scopeStr, titleStr)
		}
	}

	// Summary
	fmt.Printf("\n%s\n", subtle.Render(fmt.Sprintf("Total: %d task(s) across %d plan(s)", len(allTasks), len(planOrder))))

	return nil
}

// formatTaskStatus returns a color-coded status string.
// Covers all known TaskStatus values with an "unknown" fallback for unexpected values.
func formatTaskStatus(status task.TaskStatus) string {
	switch status {
	case task.StatusCompleted, "done":
		// Green - successfully completed
		return lipgloss.NewStyle().Foreground(lipgloss.Color("42")).Render("[done]    ")
	case task.StatusInProgress:
		// Orange/bold - actively working
		return lipgloss.NewStyle().Foreground(lipgloss.Color("214")).Bold(true).Render("[active]  ")
	case task.StatusFailed:
		// Red - execution or verification failed
		return lipgloss.NewStyle().Foreground(lipgloss.Color("196")).Render("[failed]  ")
	case task.StatusVerifying:
		// Blue - running validation
		return lipgloss.NewStyle().Foreground(lipgloss.Color("33")).Render("[verify]  ")
	case task.StatusPending:
		// Gray - ready to be picked up
		return lipgloss.NewStyle().Foreground(lipgloss.Color("245")).Render("[pending] ")
	case task.StatusDraft:
		// Dim gray - initial creation, not ready
		return lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("[draft]   ")
	case task.StatusBlocked:
		// Red/dim - waiting on dependencies
		return lipgloss.NewStyle().Foreground(lipgloss.Color("124")).Render("[blocked] ")
	case task.StatusReady:
		// Green/dim - dependencies met, ready for execution
		return lipgloss.NewStyle().Foreground(lipgloss.Color("28")).Render("[ready]   ")
	default:
		// Unknown status - neutral gray with label showing the actual value
		// This ensures we never panic on unexpected values
		return lipgloss.NewStyle().Foreground(lipgloss.Color("245")).Render("[unknown] ")
	}
}

// formatPriority returns a color-coded priority string.
func formatPriority(priority int) string {
	var color lipgloss.Color
	switch {
	case priority <= 20:
		color = lipgloss.Color("196") // Red - critical
	case priority <= 50:
		color = lipgloss.Color("214") // Orange - high
	case priority <= 75:
		color = lipgloss.Color("226") // Yellow - medium
	default:
		color = lipgloss.Color("245") // Gray - low
	}
	return lipgloss.NewStyle().Foreground(color).Render(fmt.Sprintf("%3d ", priority))
}

var taskShowCmd = &cobra.Command{
	Use:   "show [task-id]",
	Short: "Show a task",
	Long: `Show details for a specific task.

Accepts full task IDs or unique prefixes. If the prefix is ambiguous,
candidate IDs will be displayed.

Examples:
  taskwing task show task-abc12345     # Full ID
  taskwing task show task-abc          # Unique prefix
  taskwing task show abc               # Prefix without 'task-' (auto-prepended)`,
	Args: cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		idOrPrefix := args[0]
		repo, err := openRepoOrHandleMissingMemory()
		if err != nil {
			return err
		}
		if repo == nil {
			return nil
		}
		defer func() { _ = repo.Close() }()

		// Resolve prefix to full task ID
		taskID, err := util.ResolveTaskID(cmd.Context(), repo, idOrPrefix)
		if err != nil {
			return fmt.Errorf("failed to resolve task ID: %w", err)
		}

		t, err := repo.GetTask(taskID)
		if err != nil {
			return fmt.Errorf("failed to get task %s: %w", taskID, err)
		}

		if isJSON() {
			return printJSON(t)
		}

		fmt.Printf("Task: %s\n", t.ID)
		fmt.Printf("Plan: %s\n", t.PlanID)
		fmt.Printf("Title: %s\n", t.Title)
		if t.Description != "" {
			fmt.Printf("Description: %s\n", t.Description)
		}
		fmt.Printf("Status: %s\n", t.Status)
		fmt.Printf("Priority: %d\n", t.Priority)
		if t.AssignedAgent != "" {
			fmt.Printf("Assigned Agent: %s\n", t.AssignedAgent)
		}
		if len(t.AcceptanceCriteria) > 0 {
			fmt.Println("\nAcceptance Criteria:")
			for _, a := range t.AcceptanceCriteria {
				fmt.Printf("  - %s\n", a)
			}
		}
		if len(t.ValidationSteps) > 0 {
			fmt.Println("\nValidation Steps:")
			for _, v := range t.ValidationSteps {
				fmt.Printf("  - %s\n", v)
			}
		}
		return nil
	},
}

var taskUpdateCmd = &cobra.Command{
	Use:   "update [task-id]",
	Short: "Update a task",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		taskID := args[0]
		statusStr, _ := cmd.Flags().GetString("status")
		if statusStr == "" {
			return fmt.Errorf("status is required")
		}
		status := task.TaskStatus(statusStr)
		if !isValidTaskStatus(status) {
			return fmt.Errorf("invalid status: %s", statusStr)
		}

		repo, err := openRepoOrHandleMissingMemory()
		if err != nil {
			return err
		}
		if repo == nil {
			return nil
		}
		defer func() { _ = repo.Close() }()

		if err := repo.UpdateTaskStatus(taskID, status); err != nil {
			return err
		}

		if isJSON() {
			updated, _ := repo.GetTask(taskID)
			return printJSON(updated)
		}

		if !isQuiet() {
			fmt.Printf("âœ“ Updated task %s\n", taskID)
		}
		return nil
	},
}

var (
	taskCompleteSummary string
	taskCompleteFiles   []string
)

var taskCompleteCmd = &cobra.Command{
	Use:   "complete [task-id]",
	Short: "Mark a task as completed",
	Long: `Mark a task as completed with optional summary and file list.

When all tasks in a plan are completed:
- Runs audit verification automatically
- Creates PR if audit passes (requires gh CLI)
- Commits and pushes changes to git`,
	Args: cobra.ExactArgs(1),
	RunE: runTaskComplete,
}

func runTaskComplete(cmd *cobra.Command, args []string) error {
	taskID := args[0]
	repo, err := openRepoOrHandleMissingMemory()
	if err != nil {
		return err
	}
	if repo == nil {
		return nil
	}
	defer func() { _ = repo.Close() }()

	// Use TaskApp for complete - single source of truth
	appCtx := app.NewContext(repo)
	taskApp := app.NewTaskApp(appCtx)

	ctx := context.Background()
	result, err := taskApp.Complete(ctx, app.TaskCompleteOptions{
		TaskID:        taskID,
		Summary:       taskCompleteSummary,
		FilesModified: taskCompleteFiles,
	})
	if err != nil {
		return fmt.Errorf("complete task: %w", err)
	}

	if !result.Success {
		return fmt.Errorf("%s", result.Message)
	}

	if isJSON() {
		return printJSON(result)
	}

	if !isQuiet() {
		fmt.Printf("âœ“ %s\n", result.Message)
		if result.Hint != "" {
			fmt.Printf("  %s\n", result.Hint)
		}
		if result.GitWorkflowApplied {
			fmt.Printf("  Git: committed to %s\n", result.GitBranch)
		}
		if result.PRCreated {
			fmt.Printf("  PR: %s\n", result.PRURL)
		}
	}
	return nil
}

var taskDeleteCmd = &cobra.Command{
	Use:   "delete [task-id]",
	Short: "Delete a task",
	Args:  cobra.ExactArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		taskID := args[0]
		force, _ := cmd.Flags().GetBool("force")

		repo, err := openRepoOrHandleMissingMemory()
		if err != nil {
			return err
		}
		if repo == nil {
			return nil
		}
		defer func() { _ = repo.Close() }()

		if !force && !isJSON() {
			t, err := repo.GetTask(taskID)
			if err != nil {
				return err
			}
			fmt.Printf("\n  Task:  %s\n", t.ID)
			fmt.Printf("  Title: %s\n\n", t.Title)
			if !confirmOrAbort("âš ï¸  Delete this task? [y/N]: ") {
				return nil
			}
		}

		if err := repo.DeleteTask(taskID); err != nil {
			return err
		}

		if isJSON() {
			return printJSON(deleteResult{
				ID:      taskID,
				Deleted: true,
			})
		}

		if !isQuiet() {
			fmt.Printf("âœ“ Deleted task %s\n", taskID)
		}
		return nil
	},
}

var taskValidateCmd = &cobra.Command{
	Use:   "validate [task-id]",
	Short: "Validate a task (Placeholder)",
	Args:  cobra.ExactArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("ðŸ•µï¸  Validation agent coming in V2.1")
		fmt.Println("    For now, please run the validation steps manually:")

		// Logic to fetch task and print validation steps would go here
	},
}

// taskNextCmd gets the next pending task
var taskNextCmd = &cobra.Command{
	Use:   "next",
	Short: "Get the next pending task",
	Long: `Get the next pending task from the active plan (or specified plan).

Optionally auto-start the task by providing a session ID.
Git workflow creates a feature branch on first task.

Examples:
  taskwing task next
  taskwing task next --plan p-abc123
  taskwing task next --auto-start --session my-session`,
	RunE: runTaskNext,
}

var (
	taskNextPlanID            string
	taskNextSessionID         string
	taskNextAutoStart         bool
	taskNextCreateBranch      bool
	taskNextSkipUnpushedCheck bool
)

func runTaskNext(cmd *cobra.Command, args []string) error {
	repo, err := openRepoOrHandleMissingMemory()
	if err != nil {
		return err
	}
	if repo == nil {
		return nil
	}
	defer func() { _ = repo.Close() }()

	appCtx := app.NewContext(repo)
	taskApp := app.NewTaskApp(appCtx)

	if !isQuiet() && !isJSON() {
		fmt.Fprint(os.Stderr, "ðŸ” Getting next task...")
	}

	ctx := context.Background()
	result, err := taskApp.Next(ctx, app.TaskNextOptions{
		PlanID:            taskNextPlanID,
		SessionID:         taskNextSessionID,
		AutoStart:         taskNextAutoStart,
		CreateBranch:      taskNextCreateBranch,
		SkipUnpushedCheck: taskNextSkipUnpushedCheck,
	})
	if err != nil {
		return err
	}

	if !isQuiet() && !isJSON() {
		fmt.Fprintln(os.Stderr, " done")
	}

	if isJSON() {
		return printJSON(result)
	}

	if !result.Success {
		fmt.Printf("âš ï¸  %s\n", result.Message)
		if result.Hint != "" {
			fmt.Printf("ðŸ’¡ %s\n", result.Hint)
		}
		return nil
	}

	if result.Task == nil {
		fmt.Printf("âœ“ %s\n", result.Message)
		if result.Hint != "" {
			fmt.Printf("ðŸ’¡ %s\n", result.Hint)
		}
		return nil
	}

	// Show task details
	ui.RenderPageHeader("Next Task", "")

	if result.GitWorkflowApplied {
		fmt.Printf("ðŸŒ¿ Branch: %s\n\n", result.GitBranch)
	}

	fmt.Printf("ðŸ“‹ %s\n", result.Task.Title)
	fmt.Printf("   ID: %s\n", result.Task.ID)
	fmt.Printf("   Status: %s\n", result.Task.Status)
	fmt.Printf("   Priority: %d\n", result.Task.Priority)

	if result.Task.Description != "" {
		fmt.Printf("\nðŸ“ %s\n", result.Task.Description)
	}

	if result.Hint != "" {
		fmt.Printf("\nðŸ’¡ %s\n", result.Hint)
	}

	return nil
}

// taskCurrentCmd shows the current in-progress task
var taskCurrentCmd = &cobra.Command{
	Use:   "current",
	Short: "Show the current in-progress task",
	Long: `Show the task currently being worked on.

Looks up by session ID first, then falls back to any in-progress task in the active plan.

Examples:
  taskwing task current
  taskwing task current --session my-session`,
	RunE: runTaskCurrent,
}

var (
	taskCurrentSessionID string
	taskCurrentPlanID    string
)

func runTaskCurrent(cmd *cobra.Command, args []string) error {
	repo, err := openRepoOrHandleMissingMemory()
	if err != nil {
		return err
	}
	if repo == nil {
		return nil
	}
	defer func() { _ = repo.Close() }()

	appCtx := app.NewContext(repo)
	taskApp := app.NewTaskApp(appCtx)

	ctx := context.Background()
	result, err := taskApp.Current(ctx, taskCurrentSessionID, taskCurrentPlanID)
	if err != nil {
		return err
	}

	if isJSON() {
		return printJSON(result)
	}

	if !result.Success || result.Task == nil {
		fmt.Printf("â„¹ï¸  %s\n", result.Message)
		if result.Hint != "" {
			fmt.Printf("ðŸ’¡ %s\n", result.Hint)
		}
		return nil
	}

	// Show task details
	ui.RenderPageHeader("Current Task", "")

	fmt.Printf("ðŸ“‹ %s\n", result.Task.Title)
	fmt.Printf("   ID: %s\n", result.Task.ID)
	fmt.Printf("   Status: %s\n", result.Task.Status)
	if !result.Task.ClaimedAt.IsZero() {
		fmt.Printf("   Started: %s\n", result.Task.ClaimedAt.Format("2006-01-02 15:04"))
	}

	if result.Task.Description != "" {
		fmt.Printf("\nðŸ“ %s\n", result.Task.Description)
	}

	return nil
}

// taskStartCmd claims a specific task
var taskStartCmd = &cobra.Command{
	Use:   "start [task-id]",
	Short: "Start working on a specific task",
	Long: `Claim a task and mark it as in-progress.

Requires a session ID to track which session owns the task.

Examples:
  taskwing task start t-abc123 --session my-session`,
	Args: cobra.ExactArgs(1),
	RunE: runTaskStart,
}

var taskStartSessionID string

func runTaskStart(cmd *cobra.Command, args []string) error {
	taskID := args[0]

	if taskStartSessionID == "" {
		return fmt.Errorf("--session is required")
	}

	repo, err := openRepoOrHandleMissingMemory()
	if err != nil {
		return err
	}
	if repo == nil {
		return nil
	}
	defer func() { _ = repo.Close() }()

	appCtx := app.NewContext(repo)
	taskApp := app.NewTaskApp(appCtx)

	ctx := context.Background()
	result, err := taskApp.Start(ctx, app.TaskStartOptions{
		TaskID:    taskID,
		SessionID: taskStartSessionID,
	})
	if err != nil {
		return err
	}

	if isJSON() {
		return printJSON(result)
	}

	if !result.Success {
		fmt.Printf("âš ï¸  %s\n", result.Message)
		return nil
	}

	fmt.Printf("âœ“ Started task: %s\n", result.Task.Title)
	fmt.Printf("  ID: %s\n", result.Task.ID)

	if result.Hint != "" {
		fmt.Printf("\nðŸ’¡ %s\n", result.Hint)
	}

	return nil
}

// taskAddCmd creates a new task and links it to a plan
var taskAddCmd = &cobra.Command{
	Use:   "add [title]",
	Short: "Add a new task to a plan",
	Long: `Create a new task and link it to a plan.

The --plan flag accepts either a plan ID or a plan name (searches goal text).
If no plan is specified, the active plan is used.

Examples:
  taskwing task add "Implement user login" --plan plan-abc123
  taskwing task add "Fix bug in auth" --plan "authentication"
  taskwing task add "Quick fix" --priority 90`,
	Args: cobra.ExactArgs(1),
	RunE: runTaskAdd,
}

var (
	taskAddPlanID      string
	taskAddDescription string
	taskAddPriority    int
)

func runTaskAdd(cmd *cobra.Command, args []string) error {
	title := strings.TrimSpace(args[0])
	if title == "" {
		return fmt.Errorf("title cannot be empty")
	}

	repo, err := openRepoOrHandleMissingMemory()
	if err != nil {
		return err
	}
	if repo == nil {
		return nil
	}
	defer func() { _ = repo.Close() }()

	// Resolve plan ID
	var planID string
	if taskAddPlanID != "" {
		// Try exact ID match first
		plan, err := repo.GetPlan(taskAddPlanID)
		if err == nil && plan != nil {
			planID = plan.ID
		} else {
			// Search by name/goal
			plans, err := repo.SearchPlans(taskAddPlanID, "")
			if err != nil {
				return fmt.Errorf("search plans: %w", err)
			}
			if len(plans) == 0 {
				return fmt.Errorf("plan not found: %q", taskAddPlanID)
			}
			if len(plans) > 1 {
				return fmt.Errorf("multiple plans match %q, please specify exact ID", taskAddPlanID)
			}
			planID = plans[0].ID
		}
	} else {
		// Use active plan
		plan, err := repo.GetActivePlan()
		if err != nil || plan == nil {
			return fmt.Errorf("no active plan. Use --plan to specify a plan, or run 'taskwing plan start <id>' to set an active plan")
		}
		planID = plan.ID
	}

	// Create task (ID is auto-generated by the store)
	newTask := &task.Task{
		PlanID:      planID,
		Title:       title,
		Description: taskAddDescription,
		Status:      task.StatusPending,
		Priority:    taskAddPriority,
	}

	// Validate
	if newTask.Description == "" {
		newTask.Description = title // Use title as description if not provided
	}

	if err := newTask.Validate(); err != nil {
		return fmt.Errorf("invalid task: %w", err)
	}

	if err := repo.CreateTask(newTask); err != nil {
		return fmt.Errorf("create task: %w", err)
	}

	if isJSON() {
		return printJSON(newTask)
	}

	fmt.Printf("âœ“ Created task: %s\n", newTask.Title)
	fmt.Printf("  ID: %s\n", newTask.ID)
	fmt.Printf("  Plan: %s\n", planID)

	return nil
}

func init() {
	rootCmd.AddCommand(taskCmd)
	taskCmd.AddCommand(taskListCmd)
	taskCmd.AddCommand(taskShowCmd)
	taskCmd.AddCommand(taskUpdateCmd)
	taskCmd.AddCommand(taskCompleteCmd)
	taskCmd.AddCommand(taskDeleteCmd)
	taskCmd.AddCommand(taskValidateCmd)
	taskCmd.AddCommand(taskNextCmd)
	taskCmd.AddCommand(taskCurrentCmd)
	taskCmd.AddCommand(taskStartCmd)
	taskCmd.AddCommand(taskAddCmd)

	// Task add flags
	taskAddCmd.Flags().StringVarP(&taskAddPlanID, "plan", "p", "", "Plan ID or name to link task to (defaults to active plan)")
	taskAddCmd.Flags().StringVarP(&taskAddDescription, "description", "d", "", "Task description (defaults to title)")
	taskAddCmd.Flags().IntVar(&taskAddPriority, "priority", 50, "Task priority (0-100, lower is higher priority)")

	// Task list flags
	taskListCmd.Flags().StringP("plan", "p", "", "Filter by plan ID (prefix match)")
	taskListCmd.Flags().StringP("status", "s", "", "Filter by status (pending, in_progress, completed, failed)")
	taskListCmd.Flags().IntP("priority", "P", 0, "Filter by max priority (show tasks with priority <= value)")
	taskListCmd.Flags().String("scope", "", "Filter by scope/tag")
	taskListCmd.Flags().Bool("include-archived", false, "Include tasks from archived plans")

	taskUpdateCmd.Flags().String("status", "", "Update the task status (draft, pending, in_progress, verifying, completed, failed)")
	taskDeleteCmd.Flags().BoolP("force", "f", false, "Skip confirmation prompt")

	// Task complete flags
	taskCompleteCmd.Flags().StringVar(&taskCompleteSummary, "summary", "", "Summary of what was accomplished")
	taskCompleteCmd.Flags().StringSliceVar(&taskCompleteFiles, "files", nil, "Files that were modified (comma-separated)")

	// Task next flags
	taskNextCmd.Flags().StringVar(&taskNextPlanID, "plan", "", "Specific plan ID (defaults to active plan)")
	taskNextCmd.Flags().StringVar(&taskNextSessionID, "session", "", "Session ID for auto-start")
	taskNextCmd.Flags().BoolVar(&taskNextAutoStart, "auto-start", false, "Automatically claim the task")
	taskNextCmd.Flags().BoolVar(&taskNextCreateBranch, "create-branch", true, "Create a new git branch for this plan")
	taskNextCmd.Flags().BoolVar(&taskNextSkipUnpushedCheck, "skip-unpushed-check", false, "Proceed despite unpushed commits (only with --create-branch)")

	// Task current flags
	taskCurrentCmd.Flags().StringVar(&taskCurrentSessionID, "session", "", "Session ID to look up")
	taskCurrentCmd.Flags().StringVar(&taskCurrentPlanID, "plan", "", "Plan ID to search in")

	// Task start flags
	taskStartCmd.Flags().StringVar(&taskStartSessionID, "session", "", "Session ID (required)")
}

// isValidTaskStatus validates task status values
func isValidTaskStatus(status task.TaskStatus) bool {
	switch status {
	case task.StatusDraft, task.StatusPending, task.StatusInProgress, task.StatusVerifying, task.StatusCompleted, task.StatusFailed:
		return true
	default:
		return false
	}
}
