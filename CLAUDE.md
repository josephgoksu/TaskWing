# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## CLI Binaries

- **`taskwing`**: Production binary installed via Homebrew (`brew install josephgoksu/tap/taskwing`)
- **`./bin/taskwing`**: Local development binary generated by [air](https://github.com/air-verse/air) for hot-reloading

Use `./bin/taskwing` during development, `taskwing` for testing production behavior.

## MCP Server Testing

Two MCP servers are available for testing:

| MCP Server | Binary | Use Case |
|------------|--------|----------|
| `taskwing-mcp` | Production (`taskwing`) | Stable features, production testing |
| `taskwing-local-dev-mcp` | Development (`./bin/taskwing`) | Testing new/changed features |

### Testing New Features

When developing new MCP tools or modifying existing ones:

1. **Use local dev MCP**: Claude Code has access to `taskwing-local-dev-mcp` which uses the hot-reloaded binary from `air`
2. **Test via MCP tools**: Use tools like `mcp__taskwing-local-dev-mcp__explain_symbol` instead of CLI commands
3. **Verify with CLI**: After MCP testing, verify with `go run . <command>` (NOT the installed `taskwing` binary)

### Important: MCP Server Caching

The production MCP server (`taskwing-mcp`) uses the installed Homebrew binary. Changes to code are **NOT reflected** until:
- You rebuild: `make build && brew reinstall taskwing` (if using Homebrew)
- Or test with: `go run . mcp` directly

**Always use `taskwing-local-dev-mcp` tools when testing development changes.**

### Example Testing Workflow

```bash
# 1. Make code changes
# 2. Air auto-rebuilds ./bin/taskwing

# 3. Test via local dev MCP (in Claude Code)
# Use: mcp__taskwing-local-dev-mcp__explain_symbol, detect_drift, etc.

# 4. Verify CLI works
go run . explain NewRecallApp
go run . drift

# 5. Run tests
make test-quick
```

## Build & Test Commands

```bash
# Build
make build                    # Build the taskwing binary

# Test
make test                     # Run all tests (unit, integration, MCP)
make test-unit                # Run unit tests only
make test-quick               # Quick tests for development
go test -v ./internal/bootstrap/...  # Run tests for a specific package

# Quality
make lint                     # Format code and run golangci-lint
make coverage                 # Generate test coverage report

# Development
make dev-setup                # Install dependencies and golangci-lint
air                           # Start hot-reload dev server (creates ./bin/taskwing)
```

## Architecture Overview

TaskWing gives AI coding assistants permanent memory. It extracts architectural decisions, patterns, and constraints from your codebase, then exposes them via MCP (Model Context Protocol) so Claude, Cursor, and Copilot understand your architecture.

### Core Layers

```
cmd/                          # Cobra CLI commands
├── root.go                   # Base command, global flags (--json, --verbose, --preview, --quiet)
├── bootstrap.go              # Auto-generate knowledge from repo
├── add.go                    # Add knowledge (AI classifies type)
├── context.go                # Semantic search with --answer for AI responses
├── list.go                   # View knowledge by type
├── memory.go                 # Maintenance: check/repair/rebuild-index
├── mcp_server.go             # MCP server for AI tool integration
├── plan.go                   # Plan management (new/list/start)
├── task.go                   # Atomic task management
├── hook.go                   # Claude Code hooks for autonomous execution
└── eval.go                   # Evaluation benchmarks

internal/
├── memory/                   # Data layer
│   ├── store.go              # MemoryStore interface definition
│   ├── sqlite.go             # SQLite implementation (source of truth)
│   └── models.go             # Feature, Decision, Edge types
├── bootstrap/                # Codebase analysis
│   ├── scanner.go            # Heuristic scanner
│   └── llm_analyzer.go       # LLM-powered analysis with streaming
├── llm/
│   └── client.go             # Multi-provider LLM factory (OpenAI, Ollama via Eino)
└── knowledge/
    ├── classify.go           # AI classification of knowledge types
    └── embed.go              # Embedding generation
```

### Storage Model

```
.taskwing/memory/
├── memory.db                 # SQLite: THE source of truth
├── index.json                # Cache: regenerated from SQLite
└── features/*.md             # Generated markdown (human-readable, not canonical)
```

**Key design principle**: SQLite is the single source of truth. Markdown files are generated snapshots; manual edits may be overwritten. All writes go through CLI commands.

### Database Schema

Three main tables in SQLite:
- `features`: id, name, one_liner, status, tags (JSON), file_path, decision_count
- `decisions`: id, feature_id, title, summary, reasoning, tradeoffs
- `edges`: from_feature, to_feature, edge_type (depends_on, extends, replaces, related)

Graph traversal uses recursive CTEs for GetDependencies/GetDependents.

### LLM Integration

Uses CloudWeGo Eino for multi-provider support:
- OpenAI: Set `OPENAI_API_KEY` or `TASKWING_LLM_APIKEY`
- Ollama: Set `TASKWING_LLM_PROVIDER=ollama` and `TASKWING_LLM_MODEL=<model>`

**Bootstrap requires an LLM API key by default** to analyze architecture. Use `--skip-analyze` for CI/testing without LLM (hidden flag, deterministic mode only).

### MCP Server

`tw mcp` starts a JSON-RPC stdio server exposing `recall` tool for AI assistants. Target token budget: 500-1000 tokens per context response.

### Task Context Binding

Tasks receive architectural context via a **hybrid early+late binding** approach:

1. **Early binding** (at task creation): `TaskEnricher` executes recall queries and embeds results in `Task.ContextSummary`
2. **Late binding** (at display): `FormatRichContext()` uses early-bound context or fetches fresh context as fallback

This ensures tasks always have relevant architecture context while maintaining backward compatibility with older tasks.

**Key files**:
- `internal/app/plan.go` - TaskEnricher executes queries at creation time
- `internal/task/presentation.go` - FormatRichContext() handles display with fallback
- `internal/task/scope_config.go` - Configurable scope keywords for context matching

See `docs/architecture/ADR_CONTEXT_BINDING.md` for full design rationale.

### Autonomous Task Execution (Hooks)

TaskWing integrates with Claude Code's hook system for autonomous plan execution:

```bash
tw hook session-init      # Initialize session tracking (SessionStart hook)
tw hook continue-check    # Check if should continue to next task (Stop hook)
tw hook session-end       # Cleanup session (SessionEnd hook)
tw hook status            # View current session state
```

**Circuit breakers** prevent runaway execution:
- `--max-tasks=5` - Stop after N tasks for human review
- `--max-minutes=30` - Stop after N minutes

Configuration in `.claude/settings.json` enables auto-continuation through plans.

See `docs/development/AUTONOMOUS_HOOKS.md` for full documentation.

## Key Patterns

- **Write-through**: CreateFeature() writes to SQLite → generates markdown → invalidates index cache
- **Global flags**: All commands support `--json`, `--verbose`, `--quiet`, `--preview`
- **Config**: `~/.taskwing.yaml` or `.taskwing.yaml` in project root
- **GetMemoryBasePath()** in `cmd/root.go` resolves `.taskwing/memory` path

## Git Commit Guidelines

- Use conventional commit format: `type(scope): description`
- Types: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`
- **Do NOT include "Claude Code" or AI assistant references in commit messages**
- Do NOT include `Co-Authored-By` headers referencing AI
- Keep commit messages focused on what changed and why

## Versioning (Conservative SemVer)

We follow [SemVer](https://semver.org/): `MAJOR.MINOR.PATCH` — but **err on the side of NOT bumping**.

### Golden Rule: Batch Changes
- Do NOT bump version for every small fix
- Accumulate related fixes/improvements, then bump ONCE
- Multiple bug fixes in one session = ONE patch bump, not multiple

### PATCH (x.x.X) - Most changes go here
Increment when:
- Bug fixes
- Internal refactoring (no user-visible change)
- Performance improvements
- Adding/fixing internal utilities, helpers, error handling
- Documentation fixes
- Linter/staticcheck fixes
- Adding retry logic, improving reliability
- Fixing agent coverage reporting, JSON parsing, etc.

Examples: JSON repair logic, retry improvements, file tracking fixes

### MINOR (x.X.0) - User-visible new features only
Increment when:
- New CLI command users can run
- New flag users can pass
- New output format users can see
- New provider/model users can configure

**NOT MINOR**: Internal refactors, new internal modules, code reorganization

Examples: new `tw eval` command, new `--format` flag, adding Gemini provider

### MAJOR (X.0.0) - Breaking changes only
Increment when:
- Removing commands, flags, or config options
- Changing command behavior incompatibly
- Changing config/database format without migration

### Decision Checklist
1. Is this visible to users running CLI commands? No → probably no bump needed yet
2. Does it break existing workflows? → MAJOR
3. Does it add new user-facing capability? → MINOR
4. Everything else → PATCH (batched)

**Default stance**: When unsure, don't bump. Batch changes together.

## Release Process

**CRITICAL: Do NOT release without explicit user approval.**

### AI-Assisted Release (Preferred)

When user says "let's release", "create a release", or similar:

1. **Analyze changes** since last tag:
   ```bash
   git log $(git describe --tags --abbrev=0)..HEAD --oneline
   ```

2. **Generate release notes** summarizing:
   - New features (feat:)
   - Bug fixes (fix:)
   - Breaking changes (if any)

3. **Suggest version bump** based on changes:
   - PATCH: bug fixes, refactors, internal improvements
   - MINOR: new user-facing features
   - MAJOR: breaking changes

4. **Get user approval** before proceeding

5. **Execute release**:
   ```bash
   # Create annotated tag with release notes (no source file changes needed)
   git tag -a vX.Y.Z -m "Release notes here..."
   # Push tag to trigger CI/CD
   git push origin vX.Y.Z
   ```

   Note: Version is injected via ldflags at build time from the git tag.
   No need to edit `cmd/root.go` - GoReleaser handles versioning automatically.

### Manual Release (Standalone)

```bash
make release
```

Interactive script that prompts for version, opens editor for notes, creates tag, and pushes.

### Rules

- Never release without explicit user request
- Never bump version autonomously
- Always show release notes for approval before tagging
- GoReleaser + GitHub Actions handle the rest after tag push
<!-- TASKWING_DOCS_START -->

## TaskWing Integration

TaskWing provides project memory for AI assistants via MCP tools and slash commands.

### Slash Commands
- `/taskwing` - Fetch full project context (decisions, patterns, constraints)
- `/tw-next` - Start next task with architecture context
- `/tw-done` - Complete current task with summary
- `/tw-plan` - Create development plan from goal
- `/tw-status` - Show current task status
- `/tw-debug` - Get systematic debugging help for issues
- `/tw-explain` - Get deep-dive explanation of a code symbol
- `/tw-simplify` - Simplify code while preserving behavior

### MCP Tools
| Tool | Description |
|------|-------------|
| `recall` | Retrieve project knowledge (decisions, patterns, constraints) |
| `task` | Unified task lifecycle (next, current, start, complete) |
| `plan` | Plan management (clarify, generate, audit) |
| `code` | Code intelligence (find, search, explain, callers, impact, simplify) |
| `debug` | Diagnose issues systematically with AI-powered analysis |
| `remember` | Store knowledge in project memory |

### CLI Commands
```bash
tw bootstrap        # Initialize project memory (first-time setup)
tw context "query"  # Search knowledge semantically
tw add "content"    # Add knowledge to memory
tw plan new "goal"  # Create development plan
tw task list        # List tasks from active plan
```

### Autonomous Task Execution (Hooks)

TaskWing integrates with Claude Code's hook system for autonomous plan execution:

```bash
taskwing hook session-init      # Initialize session tracking (SessionStart hook)
taskwing hook continue-check    # Check if should continue to next task (Stop hook)
taskwing hook session-end       # Cleanup session (SessionEnd hook)
taskwing hook status            # View current session state
```

**Circuit breakers** prevent runaway execution:
- `--max-tasks=5` - Stop after N tasks for human review
- `--max-minutes=30` - Stop after N minutes

Configuration in `.claude/settings.json` enables auto-continuation through plans.

<!-- TASKWING_DOCS_END -->