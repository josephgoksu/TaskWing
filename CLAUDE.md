# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## CLI Binaries

- **`taskwing`**: Production binary installed via Homebrew (`brew install josephgoksu/tap/taskwing`)
- **`tw`**: Local development binary generated by [air](https://github.com/air-verse/air) for hot-reloading

Use `tw` during development, `taskwing` for testing production behavior.

## Build & Test Commands

```bash
# Build
make build                    # Build the taskwing binary

# Test
make test                     # Run all tests (unit, integration, MCP)
make test-unit                # Run unit tests only
make test-quick               # Quick tests for development
go test -v ./internal/bootstrap/...  # Run tests for a specific package

# Quality
make lint                     # Format code and run golangci-lint
make coverage                 # Generate test coverage report

# Development
make dev-setup                # Install dependencies and golangci-lint
air                           # Start hot-reload dev server (creates ./tmp/tw)
```

## Architecture Overview

TaskWing gives AI coding assistants permanent memory. It extracts architectural decisions, patterns, and constraints from your codebase, then exposes them via MCP (Model Context Protocol) so Claude, Cursor, and Copilot understand your architecture.

### Core Layers

```
cmd/                          # Cobra CLI commands
├── root.go                   # Base command, global flags (--json, --verbose, --preview, --quiet)
├── bootstrap.go              # Auto-generate knowledge from repo
├── add.go                    # Add knowledge (AI classifies type)
├── context.go                # Semantic search with --answer for AI responses
├── list.go                   # View knowledge by type
├── memory.go                 # Maintenance: check/repair/rebuild-index
├── mcp_server.go             # MCP server for AI tool integration
├── plan.go                   # Plan management (new/list/start)
├── task.go                   # Atomic task management
└── eval.go                   # Evaluation benchmarks

internal/
├── memory/                   # Data layer
│   ├── store.go              # MemoryStore interface definition
│   ├── sqlite.go             # SQLite implementation (source of truth)
│   └── models.go             # Feature, Decision, Edge types
├── bootstrap/                # Codebase analysis
│   ├── scanner.go            # Heuristic scanner
│   └── llm_analyzer.go       # LLM-powered analysis with streaming
├── llm/
│   └── client.go             # Multi-provider LLM factory (OpenAI, Ollama via Eino)
└── knowledge/
    ├── classify.go           # AI classification of knowledge types
    └── embed.go              # Embedding generation
```

### Storage Model

```
.taskwing/memory/
├── memory.db                 # SQLite: THE source of truth
├── index.json                # Cache: regenerated from SQLite
└── features/*.md             # Generated markdown (human-readable, not canonical)
```

**Key design principle**: SQLite is the single source of truth. Markdown files are generated snapshots; manual edits may be overwritten. All writes go through CLI commands.

### Database Schema

Three main tables in SQLite:
- `features`: id, name, one_liner, status, tags (JSON), file_path, decision_count
- `decisions`: id, feature_id, title, summary, reasoning, tradeoffs
- `edges`: from_feature, to_feature, edge_type (depends_on, extends, replaces, related)

Graph traversal uses recursive CTEs for GetDependencies/GetDependents.

### LLM Integration

Uses CloudWeGo Eino for multi-provider support:
- OpenAI: Set `OPENAI_API_KEY` or `TASKWING_LLM_APIKEY`
- Ollama: Set `TASKWING_LLM_PROVIDER=ollama` and `TASKWING_LLM_MODELNAME=<model>`

Bootstrap runs LLM analysis by default.

### MCP Server

`tw mcp` starts a JSON-RPC stdio server exposing `recall` tool for AI assistants. Target token budget: 500-1000 tokens per context response.

## Key Patterns

- **Write-through**: CreateFeature() writes to SQLite → generates markdown → invalidates index cache
- **Global flags**: All commands support `--json`, `--verbose`, `--quiet`, `--preview`
- **Config**: `~/.taskwing.yaml` or `.taskwing.yaml` in project root
- **GetMemoryBasePath()** in `cmd/root.go` resolves `.taskwing/memory` path

## Git Commit Guidelines

- Use conventional commit format: `type(scope): description`
- Types: `feat`, `fix`, `docs`, `refactor`, `test`, `chore`
- **Do NOT include "Claude Code" or AI assistant references in commit messages**
- Do NOT include `Co-Authored-By` headers referencing AI
- Keep commit messages focused on what changed and why

## Versioning (Conservative SemVer)

We follow [SemVer](https://semver.org/): `MAJOR.MINOR.PATCH` — but **err on the side of NOT bumping**.

### Golden Rule: Batch Changes
- Do NOT bump version for every small fix
- Accumulate related fixes/improvements, then bump ONCE
- Multiple bug fixes in one session = ONE patch bump, not multiple

### PATCH (x.x.X) - Most changes go here
Increment when:
- Bug fixes
- Internal refactoring (no user-visible change)
- Performance improvements
- Adding/fixing internal utilities, helpers, error handling
- Documentation fixes
- Linter/staticcheck fixes
- Adding retry logic, improving reliability
- Fixing agent coverage reporting, JSON parsing, etc.

Examples: JSON repair logic, retry improvements, file tracking fixes

### MINOR (x.X.0) - User-visible new features only
Increment when:
- New CLI command users can run
- New flag users can pass
- New output format users can see
- New provider/model users can configure

**NOT MINOR**: Internal refactors, new internal modules, code reorganization

Examples: new `tw eval` command, new `--format` flag, adding Gemini provider

### MAJOR (X.0.0) - Breaking changes only
Increment when:
- Removing commands, flags, or config options
- Changing command behavior incompatibly
- Changing config/database format without migration

### Decision Checklist
1. Is this visible to users running CLI commands? No → probably no bump needed yet
2. Does it break existing workflows? → MAJOR
3. Does it add new user-facing capability? → MINOR
4. Everything else → PATCH (batched)

**Default stance**: When unsure, don't bump. Batch changes together.

## Release Process

**CRITICAL: Do NOT release without explicit user approval.**

- Never create git tags or push releases autonomously
- Never bump version in `cmd/root.go` without user request
- Only release when user explicitly asks (e.g., "release this", "tag and push", "create a release")
- When releasing, follow this order:
  1. Update version in `cmd/root.go`
  2. Commit the version bump
  3. Push commit to origin
  4. Create tag on the version bump commit
  5. Push tag to origin
  6. Verify tag contains correct version
