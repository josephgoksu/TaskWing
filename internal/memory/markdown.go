package memory

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// MarkdownStore handles filesystem operations for human-readable files.
type MarkdownStore struct {
	basePath string
}

func NewMarkdownStore(basePath string) *MarkdownStore {
	return &MarkdownStore{basePath: basePath}
}

func (s *MarkdownStore) RemoveFile(path string) error {
	return os.Remove(path)
}

// ArchitectureData holds all knowledge needed to generate ARCHITECTURE.md.
// All data comes from the nodes table â€” the single source of truth.
type ArchitectureData struct {
	Features    []Node // Nodes of type "feature"
	Decisions   []Node // Nodes of type "decision"
	Patterns    []Node // Nodes of type "pattern"
	Constraints []Node // Nodes of type "constraint"
}

// GenerateArchitectureMD creates a comprehensive ARCHITECTURE.md file
// that consolidates all project knowledge into a single, navigable document.
func (s *MarkdownStore) GenerateArchitectureMD(data ArchitectureData, projectName string) error {
	var sb strings.Builder

	// Header
	sb.WriteString(fmt.Sprintf("# %s Architecture\n\n", projectName))
	sb.WriteString(fmt.Sprintf("> Auto-generated by TaskWing on %s\n", time.Now().Format("2006-01-02 15:04")))
	sb.WriteString("> **Do not edit manually** â€” changes will be overwritten on next generation.\n\n")

	// Table of Contents
	sb.WriteString("## Table of Contents\n\n")
	sb.WriteString("- [Architectural Constraints](#architectural-constraints)\n")
	sb.WriteString("- [Features & Components](#features--components)\n")
	sb.WriteString("- [Design Patterns](#design-patterns)\n")
	sb.WriteString("- [Key Decisions](#key-decisions)\n\n")
	sb.WriteString("---\n\n")

	// Constraints Section (most important - rules that MUST be followed)
	sb.WriteString("## Architectural Constraints\n\n")
	sb.WriteString("These are mandatory rules that must be respected during development.\n\n")
	if len(data.Constraints) == 0 {
		sb.WriteString("_No constraints documented yet._\n\n")
	} else {
		for _, c := range data.Constraints {
			sb.WriteString(fmt.Sprintf("### â›” %s\n\n", c.Summary))
			// Content often includes the summary, so show the rest
			content := strings.TrimPrefix(c.Content, c.Summary)
			content = strings.TrimSpace(content)
			if content != "" {
				sb.WriteString(fmt.Sprintf("%s\n\n", content))
			}
		}
	}
	sb.WriteString("---\n\n")

	// Features Section
	sb.WriteString("## Features & Components\n\n")
	sb.WriteString("Major functional areas and their architectural decisions.\n\n")

	if len(data.Features) == 0 {
		sb.WriteString("_No features documented yet._\n\n")
	} else {
		// Sort features alphabetically by summary
		sortedFeatures := make([]Node, len(data.Features))
		copy(sortedFeatures, data.Features)
		sort.Slice(sortedFeatures, func(i, j int) bool {
			return sortedFeatures[i].Summary < sortedFeatures[j].Summary
		})

		for _, f := range sortedFeatures {
			sb.WriteString(fmt.Sprintf("### %s\n\n", f.Summary))
			content := strings.TrimPrefix(f.Content, f.Summary)
			content = strings.TrimSpace(content)
			if content != "" {
				sb.WriteString(fmt.Sprintf("%s\n\n", content))
			}
		}
	}
	sb.WriteString("---\n\n")

	// Patterns Section
	sb.WriteString("## Design Patterns\n\n")
	sb.WriteString("Recurring patterns and workflows used across the codebase.\n\n")
	if len(data.Patterns) == 0 {
		sb.WriteString("_No patterns documented yet._\n\n")
	} else {
		for _, p := range data.Patterns {
			sb.WriteString(fmt.Sprintf("### ðŸ”„ %s\n\n", p.Summary))
			// Format content as a code block if it looks like steps
			content := strings.TrimPrefix(p.Content, p.Summary)
			content = strings.TrimSpace(content)
			if content != "" {
				// Check if it's a multi-line workflow
				if strings.Contains(content, "\n") {
					sb.WriteString("```\n")
					sb.WriteString(content)
					sb.WriteString("\n```\n\n")
				} else {
					sb.WriteString(fmt.Sprintf("%s\n\n", content))
				}
			}
		}
	}
	sb.WriteString("---\n\n")

	// Key Decisions Section
	sb.WriteString("## Key Decisions\n\n")
	sb.WriteString("Cross-cutting architectural decisions extracted from the codebase.\n\n")

	if len(data.Decisions) == 0 {
		sb.WriteString("_No decisions documented yet._\n\n")
	} else {
		// Group by source agent if available
		byAgent := make(map[string][]Node)
		for _, d := range data.Decisions {
			agent := d.SourceAgent
			if agent == "" {
				agent = "general"
			}
			byAgent[agent] = append(byAgent[agent], d)
		}

		// Sort agents for deterministic output
		agents := make([]string, 0, len(byAgent))
		for a := range byAgent {
			agents = append(agents, a)
		}
		sort.Strings(agents)

		for _, agent := range agents {
			nodes := byAgent[agent]
			agentTitle := toTitleCase(strings.ReplaceAll(agent, "_", " "))
			sb.WriteString(fmt.Sprintf("### From %s Analysis\n\n", agentTitle))

			for _, d := range nodes {
				sb.WriteString(fmt.Sprintf("- **%s**", d.Summary))
				// Add a snippet of content if it's different from summary
				content := strings.TrimPrefix(d.Content, d.Summary)
				content = strings.TrimSpace(content)
				if content != "" && len(content) < 200 {
					sb.WriteString(fmt.Sprintf(": %s", content))
				}
				sb.WriteString("\n")
			}
			sb.WriteString("\n")
		}
	}

	// Footer
	sb.WriteString("---\n\n")
	sb.WriteString("_This document is automatically generated from TaskWing's project memory._\n")
	sb.WriteString("_Use `taskwing bootstrap --force` to refresh project knowledge._\n")

	// Write to file
	archPath := filepath.Join(s.basePath, "ARCHITECTURE.md")
	return os.WriteFile(archPath, []byte(sb.String()), 0644)
}

// toTitleCase capitalizes the first letter of each word in the string.
// This is a simple replacement for the deprecated strings.Title.
func toTitleCase(s string) string {
	words := strings.Fields(s)
	for i, word := range words {
		if len(word) > 0 {
			first := strings.ToUpper(string(word[0]))
			rest := ""
			if len(word) > 1 {
				rest = strings.ToLower(word[1:])
			}
			words[i] = first + rest
		}
	}
	return strings.Join(words, " ")
}
