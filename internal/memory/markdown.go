package memory

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

// MarkdownStore handles filesystem operations for human-readable files.
type MarkdownStore struct {
	basePath string
}

func NewMarkdownStore(basePath string) *MarkdownStore {
	return &MarkdownStore{basePath: basePath}
}

func (s *MarkdownStore) WriteFeature(f Feature, decisions []Decision) error {
	featuresDir := filepath.Join(s.basePath, "features")
	if err := os.MkdirAll(featuresDir, 0755); err != nil {
		return fmt.Errorf("create features dir: %w", err)
	}

	// Use the feature's FilePath if set, otherwise generate one
	filePath := f.FilePath
	if filePath == "" {
		safeName := strings.ToLower(strings.ReplaceAll(f.Name, " ", "-"))
		filePath = filepath.Join(featuresDir, safeName+".md")
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# %s\n\n", f.Name))
	sb.WriteString(fmt.Sprintf("%s\n\n", f.OneLiner))

	if len(decisions) > 0 {
		sb.WriteString("## Decisions\n\n")
		for _, d := range decisions {
			sb.WriteString(fmt.Sprintf("### %s\n", d.Title))
			sb.WriteString(fmt.Sprintf("- **Summary:** %s\n", d.Summary))
			if d.Reasoning != "" {
				sb.WriteString(fmt.Sprintf("- **Why:** %s\n", d.Reasoning))
			}
			if d.Tradeoffs != "" {
				sb.WriteString(fmt.Sprintf("- **Trade-offs:** %s\n", d.Tradeoffs))
			}
			sb.WriteString(fmt.Sprintf("- **Date:** %s\n\n", d.CreatedAt.Format("2006-01-02")))
		}
	}

	sb.WriteString("## Notes\n\n")
	sb.WriteString("<!-- Add notes here -->\n")

	return os.WriteFile(filePath, []byte(sb.String()), 0644)
}

func (s *MarkdownStore) RemoveFile(path string) error {
	return os.Remove(path)
}

// ArchitectureData holds all knowledge needed to generate ARCHITECTURE.md
type ArchitectureData struct {
	Features    []Feature
	Decisions   map[string][]Decision // keyed by FeatureID
	Patterns    []Node
	Constraints []Node
	AllNodes    []Node // For decisions not linked to features
}

// GenerateArchitectureMD creates a comprehensive ARCHITECTURE.md file
// that consolidates all project knowledge into a single, navigable document.
func (s *MarkdownStore) GenerateArchitectureMD(data ArchitectureData, projectName string) error {
	var sb strings.Builder

	// Header
	sb.WriteString(fmt.Sprintf("# %s Architecture\n\n", projectName))
	sb.WriteString(fmt.Sprintf("> Auto-generated by TaskWing on %s\n", time.Now().Format("2006-01-02 15:04")))
	sb.WriteString("> **Do not edit manually** â€” changes will be overwritten on next generation.\n\n")

	// Table of Contents
	sb.WriteString("## Table of Contents\n\n")
	sb.WriteString("- [Architectural Constraints](#architectural-constraints)\n")
	sb.WriteString("- [Features & Components](#features--components)\n")
	sb.WriteString("- [Design Patterns](#design-patterns)\n")
	sb.WriteString("- [Key Decisions](#key-decisions)\n\n")
	sb.WriteString("---\n\n")

	// Constraints Section (most important - rules that MUST be followed)
	sb.WriteString("## Architectural Constraints\n\n")
	sb.WriteString("These are mandatory rules that must be respected during development.\n\n")
	if len(data.Constraints) == 0 {
		sb.WriteString("_No constraints documented yet._\n\n")
	} else {
		for _, c := range data.Constraints {
			sb.WriteString(fmt.Sprintf("### â›” %s\n\n", c.Summary))
			// Content often includes the summary, so show the rest
			content := strings.TrimPrefix(c.Content, c.Summary)
			content = strings.TrimSpace(content)
			if content != "" {
				sb.WriteString(fmt.Sprintf("%s\n\n", content))
			}
		}
	}
	sb.WriteString("---\n\n")

	// Features Section
	sb.WriteString("## Features & Components\n\n")
	sb.WriteString("Major functional areas and their architectural decisions.\n\n")
	// Track seen decisions to avoid duplication in Key Decisions section
	seenDecisions := make(map[string]bool)

	if len(data.Features) == 0 {
		sb.WriteString("_No features documented yet._\n\n")
	} else {
		// Sort features alphabetically
		sortedFeatures := make([]Feature, len(data.Features))
		copy(sortedFeatures, data.Features)
		sort.Slice(sortedFeatures, func(i, j int) bool {
			return sortedFeatures[i].Name < sortedFeatures[j].Name
		})

		for _, f := range sortedFeatures {
			sb.WriteString(fmt.Sprintf("### %s\n\n", f.Name))
			sb.WriteString(fmt.Sprintf("%s\n\n", f.OneLiner))

			// Feature-specific decisions
			if decisions, ok := data.Decisions[f.ID]; ok && len(decisions) > 0 {
				sb.WriteString("**Decisions:**\n\n")
				for _, d := range decisions {
					sb.WriteString(fmt.Sprintf("- **%s**: %s", d.Title, d.Summary))
					if d.Reasoning != "" {
						sb.WriteString(fmt.Sprintf(" â€” _Why: %s_", d.Reasoning))
					}
					sb.WriteString("\n")

					// Track as seen
					seenDecisions[d.Title] = true
					seenDecisions[d.Summary] = true
				}
				sb.WriteString("\n")
			}
		}
	}
	sb.WriteString("---\n\n")

	// Patterns Section
	sb.WriteString("## Design Patterns\n\n")
	sb.WriteString("Recurring patterns and workflows used across the codebase.\n\n")
	if len(data.Patterns) == 0 {
		sb.WriteString("_No patterns documented yet._\n\n")
	} else {
		for _, p := range data.Patterns {
			sb.WriteString(fmt.Sprintf("### ðŸ”„ %s\n\n", p.Summary))
			// Format content as a code block if it looks like steps
			content := strings.TrimPrefix(p.Content, p.Summary)
			content = strings.TrimSpace(content)
			if content != "" {
				// Check if it's a multi-line workflow
				if strings.Contains(content, "\n") {
					sb.WriteString("```\n")
					sb.WriteString(content)
					sb.WriteString("\n```\n\n")
				} else {
					sb.WriteString(fmt.Sprintf("%s\n\n", content))
				}
			}
		}
	}
	sb.WriteString("---\n\n")

	// Key Decisions Section (standalone decisions from nodes, not linked to features)
	sb.WriteString("## Key Decisions\n\n")
	sb.WriteString("Cross-cutting architectural decisions extracted from the codebase.\n\n")

	// Filter nodes of type "decision" that aren't already shown under features
	var standaloneDecisions []Node
	for _, n := range data.AllNodes {
		if n.Type == NodeTypeDecision {
			// Skip if already shown under a feature
			if seenDecisions[n.Summary] {
				continue
			}
			standaloneDecisions = append(standaloneDecisions, n)
		}
	}

	if len(standaloneDecisions) == 0 {
		sb.WriteString("_No standalone decisions documented yet._\n\n")
	} else {
		// Group by source agent if available
		byAgent := make(map[string][]Node)
		for _, d := range standaloneDecisions {
			agent := d.SourceAgent
			if agent == "" {
				agent = "general"
			}
			byAgent[agent] = append(byAgent[agent], d)
		}

		// Sort agents for deterministic output
		agents := make([]string, 0, len(byAgent))
		for a := range byAgent {
			agents = append(agents, a)
		}
		sort.Strings(agents)

		for _, agent := range agents {
			nodes := byAgent[agent]
			agentTitle := toTitleCase(strings.ReplaceAll(agent, "_", " "))
			sb.WriteString(fmt.Sprintf("### From %s Analysis\n\n", agentTitle))

			for _, d := range nodes {
				sb.WriteString(fmt.Sprintf("- **%s**", d.Summary))
				// Add a snippet of content if it's different from summary
				content := strings.TrimPrefix(d.Content, d.Summary)
				content = strings.TrimSpace(content)
				if content != "" && len(content) < 200 {
					sb.WriteString(fmt.Sprintf(": %s", content))
				}
				sb.WriteString("\n")
			}
			sb.WriteString("\n")
		}
	}

	// Footer
	sb.WriteString("---\n\n")
	sb.WriteString("_This document is automatically generated from TaskWing's project memory._\n")
	sb.WriteString("_Use `taskwing bootstrap --force` to refresh project knowledge._\n")

	// Write to file
	archPath := filepath.Join(s.basePath, "ARCHITECTURE.md")
	return os.WriteFile(archPath, []byte(sb.String()), 0644)
}

// toTitleCase capitalizes the first letter of each word in the string.
// This is a simple replacement for the deprecated strings.Title.
func toTitleCase(s string) string {
	words := strings.Fields(s)
	for i, word := range words {
		if len(word) > 0 {
			first := strings.ToUpper(string(word[0]))
			rest := ""
			if len(word) > 1 {
				rest = strings.ToLower(word[1:])
			}
			words[i] = first + rest
		}
	}
	return strings.Join(words, " ")
}
