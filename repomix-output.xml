This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.github/
  workflows/
    release.yml
cmd/
  add.go
  config_cmd.go
  config.go
  delete.go
  done.go
  errors.go
  generate.go
  init.go
  list.go
  mcp_advanced_tools.go
  mcp_context.go
  mcp_errors.go
  mcp_prompts.go
  mcp_resources.go
  mcp_tools.go
  mcp.go
  reset.go
  root.go
  search.go
  show.go
  update.go
  utils.go
  version.go
llm/
  factory.go
  openai.go
  provider.go
models/
  task.go
prompts/
  loader.go
  prompts.go
store/
  file_store.go
  interface.go
.gitignore
.goreleaser.yaml
.taskwing.example.yaml
CLAUDE.md
example.env
go.mod
LICENSE
main.go
MCP_GUIDE.md
product.xml
QUICKSTART.md
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="cmd/config_cmd.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"fmt"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// configCmd represents the config command
var configCmd = &cobra.Command{
	Use:   "config",
	Short: "Manage TaskWing configuration",
	Long: `Manage TaskWing configuration with simple commands.

Configuration lookup order:
1. ./.taskwing/.taskwing.yaml (project-specific)
2. ./.taskwing.yaml (legacy project root)
3. ~/.taskwing.yaml (global)
4. Environment variables (TASKWING_*)
5. Built-in defaults

Examples:
  taskwing config show                    # Show current configuration
  taskwing config path                    # Show config file location`,
}

var configShowCmd = &cobra.Command{
	Use:   "show",
	Short: "Show current configuration",
	Long:  `Display the current TaskWing configuration values and their sources.`,
	Run: func(cmd *cobra.Command, args []string) {
		config := GetConfig()

		fmt.Println("---")
		fmt.Printf("Loaded from: %s\n\n", viper.ConfigFileUsed())

		fmt.Println("[Project]")
		fmt.Printf("  Root Directory:     %s\n", config.Project.RootDir)
		fmt.Printf("  Tasks Directory:    %s\n", config.Project.TasksDir)
		fmt.Printf("  Templates Directory: %s\n", config.Project.TemplatesDir)
		fmt.Printf("  Log Path:           %s\n", config.Project.OutputLogPath)

		fmt.Println("\n[Data]")
		fmt.Printf("  File Name:          %s\n", config.Data.File)
		fmt.Printf("  Format:             %s\n", config.Data.Format)
		fmt.Printf("  Full Task Path:     %s\n", GetTaskFilePath())

		fmt.Println("\n[LLM]")
		fmt.Printf("  Provider:           %s\n", config.LLM.Provider)
		fmt.Printf("  Model:              %s\n", config.LLM.ModelName)
		fmt.Printf("  Max Tokens:         %d\n", config.LLM.MaxOutputTokens)
		fmt.Printf("  Temperature:        %.1f\n", config.LLM.Temperature)

		if config.LLM.APIKey != "" {
			fmt.Printf("  API Key:            [SET]\n")
		} else {
			fmt.Printf("  API Key:            [NOT SET]\n")
		}

		if config.LLM.ProjectID != "" {
			fmt.Printf("  Project ID:         %s\n", config.LLM.ProjectID)
		}
	},
}

var configPathCmd = &cobra.Command{
	Use:   "path",
	Short: "Show configuration file location",
	Long:  `Show the location of the configuration file being used by TaskWing.`,
	Run: func(cmd *cobra.Command, args []string) {
		configFile := viper.ConfigFileUsed()
		if configFile != "" {
			fmt.Printf("TaskWing is using the configuration file at: %s\n", configFile)
		} else {
			fmt.Println("TaskWing is not using a configuration file.")
			fmt.Println("It is running on defaults and/or environment variables.")
			fmt.Println("You can create one by running 'taskwing init'.")
		}
	},
}

func init() {
	rootCmd.AddCommand(configCmd)
	configCmd.AddCommand(configShowCmd)
	configCmd.AddCommand(configPathCmd)
}
</file>

<file path="cmd/search.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/spf13/cobra"
)

// searchCmd represents the search command
var searchCmd = &cobra.Command{
	Use:   "search <query>",
	Short: "Search tasks by title, description, or ID",
	Long: `Search for tasks using a query string that will be matched against task titles, descriptions, and IDs.
The search is case-insensitive and supports partial matches.

Examples:
  taskwing search "authentication"       # Find tasks containing "authentication"
  taskwing search "urgent API"          # Find tasks containing both "urgent" and "API"
  taskwing search --json "database"     # Output results in JSON format
  taskwing search --status pending "fix" # Search only in pending tasks`,
	Args: cobra.MinimumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		taskStore, err := GetStore()
		if err != nil {
			HandleError("Error: Could not initialize the task store.", err)
		}
		defer taskStore.Close()

		query := strings.Join(args, " ")
		statusFilter, _ := cmd.Flags().GetString("status")
		priorityFilter, _ := cmd.Flags().GetString("priority")
		jsonOutput, _ := cmd.Flags().GetBool("json")

		// Create search filter
		filterFn := func(task models.Task) bool {
			// Status filter
			if statusFilter != "" && string(task.Status) != statusFilter {
				return false
			}

			// Priority filter
			if priorityFilter != "" && string(task.Priority) != priorityFilter {
				return false
			}

			// Search query
			queryLower := strings.ToLower(query)
			titleLower := strings.ToLower(task.Title)
			descLower := strings.ToLower(task.Description)
			idLower := strings.ToLower(task.ID)

			return strings.Contains(titleLower, queryLower) || 
				   strings.Contains(descLower, queryLower) || 
				   strings.Contains(idLower, queryLower)
		}

		// Search tasks
		tasks, err := taskStore.ListTasks(filterFn, nil)
		if err != nil {
			HandleError("Failed to search tasks", err)
		}

		if len(tasks) == 0 {
			if jsonOutput {
				fmt.Println("[]")
			} else {
				fmt.Printf("No tasks found matching query: %s\n", query)
			}
			return
		}

		if jsonOutput {
			// Output as JSON
			jsonData, err := json.MarshalIndent(tasks, "", "  ")
			if err != nil {
				HandleError("Failed to marshal search results to JSON", err)
				return
			}
			fmt.Println(string(jsonData))
		} else {
			// Output as formatted text
			fmt.Printf("Found %d task(s) matching query: %s\n\n", len(tasks), query)
			for i, task := range tasks {
				fmt.Printf("%d. %s (ID: %s)\n", i+1, task.Title, truncateUUID(task.ID))
				fmt.Printf("   Status: %s | Priority: %s\n", task.Status, task.Priority)
				if task.Description != "" {
					desc := task.Description
					if len(desc) > 100 {
						desc = desc[:97] + "..."
					}
					fmt.Printf("   Description: %s\n", desc)
				}
				if len(task.Dependencies) > 0 {
					fmt.Printf("   Dependencies: %s\n", truncateUUIDList(task.Dependencies))
				}
				fmt.Println()
			}
		}
	},
}

func init() {
	rootCmd.AddCommand(searchCmd)

	// Optional filtering flags
	searchCmd.Flags().String("status", "", "Filter search results by status")
	searchCmd.Flags().String("priority", "", "Filter search results by priority")
	searchCmd.Flags().Bool("json", false, "Output search results in JSON format")
}
</file>

<file path="QUICKSTART.md">
# TaskWing Quick Start Guide üöÄ

Get up and running with TaskWing in 5 minutes!

## Installation

Choose your preferred method:

```bash
# Option 1: Go install (recommended for developers)
go install github.com/josephgoksu/taskwing.app@latest

# Option 2: Download binary from releases
# Visit https://github.com/josephgoksu/taskwing.app/releases

# Option 3: Build from source
git clone https://github.com/josephgoksu/taskwing.app
cd taskwing-app
go build -o taskwing main.go
```

## First Steps

### 1. Initialize TaskWing

```bash
# Initialize in your project directory
taskwing init
```

This creates a `.taskwing/` directory with your task storage.

### 2. Add Your First Task

```bash
# Interactive mode (guided prompts)
taskwing add

# Non-interactive mode (automation-friendly)
taskwing add --title "Review pull requests" --priority high
```

### 3. View Your Tasks

```bash
# List all tasks
taskwing list

# Search tasks
taskwing search "review"

# Filter by status/priority
taskwing list --status pending --priority high
```

### 4. Manage Tasks

```bash
# Mark task as done
taskwing done <task-id>

# Update a task
taskwing update <task-id>

# Get detailed info
taskwing show <task-id>

# Delete a task
taskwing delete <task-id>
```

## Common Workflows

### Daily Task Management

```bash
# Morning: Check today's priorities
taskwing list --priority high,urgent

# Add a quick task
taskwing add --title "Fix critical bug" --priority urgent

# Throughout the day: Mark tasks complete
taskwing done <task-id>

# Evening: Review what's left
taskwing list --status pending
```

### Project Planning

```bash
# Add project tasks with dependencies
taskwing add --title "Design API" --priority high
taskwing add --title "Implement API" --dependencies <design-task-id>
taskwing add --title "Write tests" --dependencies <implement-task-id>

# View project structure
taskwing list
```

### Team Collaboration

```bash
# Export tasks for sharing
taskwing list --json > team-tasks.json

# Add tasks in scripts/CI
taskwing add --non-interactive --title "Deploy to staging" --priority medium
```

## AI Integration (MCP)

Connect TaskWing to Claude or other AI tools:

```bash
# Start MCP server
taskwing mcp

# Use with Claude Code or other MCP clients
# The AI can now create, update, and manage your tasks!
```

## JSON Output for Automation

```bash
# Get JSON output for scripts
taskwing list --json
taskwing show <task-id> --json

# Pipe to other tools
taskwing list --json | jq '.tasks[] | select(.priority == "urgent")'
```

## Configuration

TaskWing works out of the box, but you can customize:

```bash
# View current config
taskwing config show

# Set data directory
taskwing config data_dir ~/.my-tasks

# View config file location
taskwing config path
```

## Tips & Tricks

**üî• Power User Tips:**

- Use short task IDs: Just type the first few characters
- Chain commands: `taskwing add --title "Fix bug" && taskwing list`
- Search everything: `taskwing search` looks in titles, descriptions, and IDs
- JSON everywhere: Add `--json` to any command for automation
- Non-interactive mode: Perfect for scripts and CI/CD

**ü§ñ AI Integration:**

- Start `taskwing mcp` and connect to Claude Code
- Let AI help you break down complex projects
- Use AI to prioritize and organize tasks
- Generate tasks from meeting notes or emails

**üìÅ Organization:**

- Use project-specific `.taskwing/` directories
- Set up different priorities for different types of work
- Use dependencies to model project workflows
- Export tasks to JSON for backup or sharing

## Need Help?

```bash
# Command help
taskwing --help
taskwing add --help

# Verbose output for debugging
taskwing --verbose list

# Check configuration
taskwing config show
```

**Ready to be productive? Start with:**

```bash
taskwing init
taskwing add
```

That's it! You're now ready to manage tasks like a pro with TaskWing! üéØ
</file>

<file path="cmd/errors.go">
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/viper"
)

// HandleError provides a centralized way to manage CLI errors.
// It prints a user-friendly message by default. If the --verbose
// flag is set, it prints the full technical error.
// After printing the message, it exits the application with a status code of 1.
// DEPRECATED: Use PrintError for recoverable errors or HandleFatalError for unrecoverable ones.
func HandleError(userMsg string, technicalErr error) {
	PrintError(userMsg, technicalErr)
	os.Exit(1)
}

// HandleFatalError handles unrecoverable errors that should terminate the application.
func HandleFatalError(userMsg string, technicalErr error) {
	PrintError(userMsg, technicalErr)
	os.Exit(1)
}

// PrintError prints an error message without exiting, allowing for recovery.
func PrintError(userMsg string, technicalErr error) {
	if viper.GetBool("verbose") && technicalErr != nil {
		// In verbose mode, print the detailed, underlying technical error.
		fmt.Fprintf(os.Stderr, "Error: %v\n", technicalErr)
	} else {
		// By default, print the clean, user-friendly message.
		fmt.Fprintln(os.Stderr, userMsg)
	}
}

// LogError logs an error without printing to stderr if verbose mode is off.
func LogError(msg string, err error) {
	if viper.GetBool("verbose") {
		if err != nil {
			fmt.Fprintf(os.Stderr, "[DEBUG] %s: %v\n", msg, err)
		} else {
			fmt.Fprintf(os.Stderr, "[DEBUG] %s\n", msg)
		}
	}
}
</file>

<file path="cmd/mcp_advanced_tools.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/josephgoksu/taskwing.app/store"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// BulkTaskParams for bulk operations
type BulkTaskParams struct {
	TaskIDs  []string `json:"task_ids" mcp:"List of task IDs to operate on"`
	Action   string   `json:"action" mcp:"Action to perform: complete, cancel, delete, prioritize"`
	Priority string   `json:"priority,omitempty" mcp:"New priority for prioritize action"`
}

// TaskAnalyticsParams for analytics queries
type TaskAnalyticsParams struct {
	Period string `json:"period,omitempty" mcp:"Time period: today, week, month, all"`
	GroupBy string `json:"group_by,omitempty" mcp:"Group results by: status, priority, none"`
}

// TaskSearchParams for advanced search
type TaskSearchParams struct {
	Query       string   `json:"query" mcp:"Search query supporting AND, OR, NOT operators"`
	Tags        []string `json:"tags,omitempty" mcp:"Filter by tags"`
	DateFrom    string   `json:"date_from,omitempty" mcp:"Filter tasks created after this date (YYYY-MM-DD)"`
	DateTo      string   `json:"date_to,omitempty" mcp:"Filter tasks created before this date (YYYY-MM-DD)"`
	HasSubtasks bool     `json:"has_subtasks,omitempty" mcp:"Filter tasks that have subtasks"`
}

// TaskSummaryResponse provides a high-level summary
type TaskSummaryResponse struct {
	Summary        string          `json:"summary"`
	TotalTasks     int             `json:"total_tasks"`
	ActiveTasks    int             `json:"active_tasks"`
	CompletedToday int             `json:"completed_today"`
	DueToday       int             `json:"due_today"`
	Blocked        int             `json:"blocked"`
	Context        *TaskContext    `json:"context"`
}

// BulkOperationResponse for bulk operations
type BulkOperationResponse struct {
	Succeeded   int      `json:"succeeded"`
	Failed      int      `json:"failed"`
	Errors      []string `json:"errors,omitempty"`
	UpdatedTasks []string `json:"updated_task_ids"`
}

// bulkTaskHandler handles bulk operations on multiple tasks
func bulkTaskHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[BulkTaskParams, BulkOperationResponse] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[BulkTaskParams]) (*mcp.CallToolResultFor[BulkOperationResponse], error) {
		args := params.Arguments

		if len(args.TaskIDs) == 0 {
			return nil, NewMCPError("NO_TASKS_SPECIFIED", "No task IDs provided for bulk operation", nil)
		}

		response := BulkOperationResponse{
			UpdatedTasks: []string{},
			Errors:      []string{},
		}

		for _, taskID := range args.TaskIDs {
			var err error
			
			switch strings.ToLower(args.Action) {
			case "complete":
				_, err = taskStore.MarkTaskDone(taskID)
			case "cancel":
				_, err = taskStore.UpdateTask(taskID, map[string]interface{}{
					"status": models.StatusCancelled,
				})
			case "delete":
				err = taskStore.DeleteTask(taskID)
			case "prioritize":
				if args.Priority == "" {
					err = fmt.Errorf("priority required for prioritize action")
				} else {
					_, err = taskStore.UpdateTask(taskID, map[string]interface{}{
						"priority": args.Priority,
					})
				}
			default:
				err = fmt.Errorf("invalid action: %s", args.Action)
			}

			if err != nil {
				response.Failed++
				response.Errors = append(response.Errors, fmt.Sprintf("Task %s: %v", taskID, err))
			} else {
				response.Succeeded++
				response.UpdatedTasks = append(response.UpdatedTasks, taskID)
			}
		}

		resultText := fmt.Sprintf("Bulk %s operation: %d succeeded, %d failed", 
			args.Action, response.Succeeded, response.Failed)

		// If all operations failed, return as an error instead of IsError flag
		if response.Failed > 0 && response.Succeeded == 0 {
			errorMsg := fmt.Sprintf("All %d operations failed: %s", response.Failed, strings.Join(response.Errors, "; "))
			return nil, fmt.Errorf("bulk %s operation failed: %s", args.Action, errorMsg)
		}

		return &mcp.CallToolResultFor[BulkOperationResponse]{
			Content: []mcp.Content{
				&mcp.TextContent{Text: resultText},
			},
			StructuredContent: response,
		}, nil
	}
}

// taskSummaryHandler provides a high-level task summary
func taskSummaryHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[struct{}, TaskSummaryResponse] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[struct{}]) (*mcp.CallToolResultFor[TaskSummaryResponse], error) {
		// Get all tasks
		tasks, err := taskStore.ListTasks(nil, nil)
		if err != nil {
			return nil, WrapStoreError(err, "list", "")
		}

		// Build context
		context, err := BuildTaskContext(taskStore)
		if err != nil {
			return nil, fmt.Errorf("failed to build context: %w", err)
		}

		// Calculate summary metrics
		now := time.Now()
		today := now.Truncate(24 * time.Hour)
		
		response := TaskSummaryResponse{
			TotalTasks: len(tasks),
			Context:    context,
		}

		for _, task := range tasks {
			// Count active tasks
			if task.Status == models.StatusPending || task.Status == models.StatusInProgress {
				response.ActiveTasks++
			}

			// Count completed today
			if task.Status == models.StatusCompleted && task.CompletedAt != nil && task.CompletedAt.After(today) {
				response.CompletedToday++
			}

			// Count blocked
			if task.Status == models.StatusBlocked {
				response.Blocked++
			}
		}

		// Generate summary text
		summaryParts := []string{
			fmt.Sprintf("%d total tasks", response.TotalTasks),
			fmt.Sprintf("%d active", response.ActiveTasks),
			fmt.Sprintf("%d completed today", response.CompletedToday),
		}

		if response.Blocked > 0 {
			summaryParts = append(summaryParts, fmt.Sprintf("%d blocked", response.Blocked))
		}

		response.Summary = strings.Join(summaryParts, ", ")

		// Add context-based insights
		if context.ProjectHealth != "excellent" {
			response.Summary += fmt.Sprintf(". Project health: %s", context.ProjectHealth)
		}

		return &mcp.CallToolResultFor[TaskSummaryResponse]{
			Content: []mcp.Content{
				&mcp.TextContent{Text: response.Summary},
			},
			StructuredContent: response,
		}, nil
	}
}

// advancedSearchHandler provides powerful search capabilities
func advancedSearchHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[TaskSearchParams, TaskListResponse] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[TaskSearchParams]) (*mcp.CallToolResultFor[TaskListResponse], error) {
		args := params.Arguments

		// Parse date filters
		var dateFrom, dateTo time.Time
		var err error
		
		if args.DateFrom != "" {
			dateFrom, err = time.Parse("2006-01-02", args.DateFrom)
			if err != nil {
				return nil, NewMCPError("INVALID_DATE", "Invalid date_from format", map[string]interface{}{
					"expected": "YYYY-MM-DD",
					"provided": args.DateFrom,
				})
			}
		}

		if args.DateTo != "" {
			dateTo, err = time.Parse("2006-01-02", args.DateTo)
			if err != nil {
				return nil, NewMCPError("INVALID_DATE", "Invalid date_to format", map[string]interface{}{
					"expected": "YYYY-MM-DD",
					"provided": args.DateTo,
				})
			}
		}

		// Create advanced filter
		filterFn := func(task models.Task) bool {
			// Date range filter
			if !dateFrom.IsZero() && task.CreatedAt.Before(dateFrom) {
				return false
			}
			if !dateTo.IsZero() && task.CreatedAt.After(dateTo.Add(24*time.Hour)) {
				return false
			}

			// Query filter with basic operators
			if args.Query != "" {
				query := strings.ToLower(args.Query)
				title := strings.ToLower(task.Title)
				desc := strings.ToLower(task.Description)

				// Simple operator parsing
				if strings.Contains(query, " and ") {
					parts := strings.Split(query, " and ")
					for _, part := range parts {
						part = strings.TrimSpace(part)
						if !strings.Contains(title, part) && !strings.Contains(desc, part) {
							return false
						}
					}
				} else if strings.Contains(query, " or ") {
					parts := strings.Split(query, " or ")
					found := false
					for _, part := range parts {
						part = strings.TrimSpace(part)
						if strings.Contains(title, part) || strings.Contains(desc, part) {
							found = true
							break
						}
					}
					if !found {
						return false
					}
				} else if strings.HasPrefix(query, "not ") {
					negQuery := strings.TrimPrefix(query, "not ")
					if strings.Contains(title, negQuery) || strings.Contains(desc, negQuery) {
						return false
					}
				} else {
					// Simple contains search
					if !strings.Contains(title, query) && !strings.Contains(desc, query) {
						return false
					}
				}
			}

			// Subtask filter
			if args.HasSubtasks && len(task.SubtaskIDs) == 0 {
				return false
			}

			return true
		}

		// List tasks with advanced filter
		tasks, err := taskStore.ListTasks(filterFn, nil)
		if err != nil {
			return nil, WrapStoreError(err, "search", "")
		}

		// Convert to response
		taskResponses := make([]TaskResponse, len(tasks))
		for i, task := range tasks {
			taskResponses[i] = taskToResponse(task)
		}

		response := TaskListResponse{
			Tasks: taskResponses,
			Count: len(taskResponses),
		}

		return &mcp.CallToolResultFor[TaskListResponse]{
			Content: []mcp.Content{
				&mcp.TextContent{
					Text: fmt.Sprintf("Found %d tasks matching search criteria", len(tasks)),
				},
			},
			StructuredContent: response,
		}, nil
	}
}

// RegisterAdvancedMCPTools registers additional MCP tools
func RegisterAdvancedMCPTools(server *mcp.Server, taskStore store.TaskStore) error {
	// Bulk operations tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "bulk-tasks",
		Description: "Perform bulk operations on multiple tasks at once. Supports complete, cancel, delete, and prioritize actions.",
	}, bulkTaskHandler(taskStore))

	// Task summary tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "task-summary",
		Description: "Get a comprehensive summary of all tasks including metrics, project health, and actionable insights.",
	}, taskSummaryHandler(taskStore))

	// Advanced search tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "search-tasks",
		Description: "Advanced task search with support for logical operators (AND, OR, NOT), date ranges, and complex filters.",
	}, advancedSearchHandler(taskStore))

	return nil
}
</file>

<file path="cmd/mcp_context.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/josephgoksu/taskwing.app/store"
)

// TaskContext provides rich context about tasks for AI tools
type TaskContext struct {
	TotalTasks      int                       `json:"total_tasks"`
	TasksByStatus   map[string]int            `json:"tasks_by_status"`
	TasksByPriority map[string]int            `json:"tasks_by_priority"`
	OverdueTasks    int                       `json:"overdue_tasks"`
	BlockedTasks    int                       `json:"blocked_tasks"`
	RecentActivity  []ActivityEntry           `json:"recent_activity"`
	Suggestions     []string                  `json:"suggestions"`
	ProjectHealth   string                    `json:"project_health"`
	Metrics         ProjectMetrics            `json:"metrics"`
}

// ActivityEntry represents a recent task activity
type ActivityEntry struct {
	Timestamp   time.Time `json:"timestamp"`
	TaskID      string    `json:"task_id"`
	TaskTitle   string    `json:"task_title"`
	Action      string    `json:"action"`
	Description string    `json:"description"`
}

// ProjectMetrics provides project-level metrics
type ProjectMetrics struct {
	CompletionRate      float64 `json:"completion_rate"`
	AverageTaskAge      float64 `json:"average_task_age_days"`
	TasksCompletedWeek  int     `json:"tasks_completed_this_week"`
	TasksCreatedWeek    int     `json:"tasks_created_this_week"`
	VelocityTrend       string  `json:"velocity_trend"` // increasing, decreasing, stable
}

// BuildTaskContext creates a comprehensive context for AI tools
func BuildTaskContext(taskStore store.TaskStore) (*TaskContext, error) {
	tasks, err := taskStore.ListTasks(nil, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to get tasks for context: %w", err)
	}

	context := &TaskContext{
		TotalTasks:      len(tasks),
		TasksByStatus:   make(map[string]int),
		TasksByPriority: make(map[string]int),
		RecentActivity:  []ActivityEntry{},
		Suggestions:     []string{},
	}

	now := time.Now()
	weekAgo := now.AddDate(0, 0, -7)
	var totalAge float64
	var completedTasks int
	var tasksCompletedThisWeek int
	var tasksCreatedThisWeek int

	// Analyze tasks
	for _, task := range tasks {
		// Count by status
		context.TasksByStatus[string(task.Status)]++

		// Count by priority
		context.TasksByPriority[string(task.Priority)]++

		// Check for overdue tasks (assuming tasks older than 30 days in pending are overdue)
		if task.Status == models.StatusPending && now.Sub(task.CreatedAt) > 30*24*time.Hour {
			context.OverdueTasks++
		}

		// Count blocked tasks
		if task.Status == models.StatusBlocked {
			context.BlockedTasks++
		}

		// Calculate age
		totalAge += now.Sub(task.CreatedAt).Hours() / 24

		// Count completed tasks
		if task.Status == models.StatusCompleted {
			completedTasks++
			if task.CompletedAt != nil && task.CompletedAt.After(weekAgo) {
				tasksCompletedThisWeek++
			}
		}

		// Count recently created tasks
		if task.CreatedAt.After(weekAgo) {
			tasksCreatedThisWeek++
		}

		// Track recent activity
		if task.UpdatedAt.After(now.AddDate(0, 0, -3)) {
			action := "updated"
			if task.CreatedAt.Equal(task.UpdatedAt) {
				action = "created"
			} else if task.Status == models.StatusCompleted && task.CompletedAt != nil && task.CompletedAt.Equal(task.UpdatedAt) {
				action = "completed"
			}

			context.RecentActivity = append(context.RecentActivity, ActivityEntry{
				Timestamp:   task.UpdatedAt,
				TaskID:      task.ID,
				TaskTitle:   task.Title,
				Action:      action,
				Description: fmt.Sprintf("Task %s was %s", task.Title, action),
			})
		}
	}

	// Sort recent activity by timestamp (most recent first)
	sort.Slice(context.RecentActivity, func(i, j int) bool {
		return context.RecentActivity[i].Timestamp.After(context.RecentActivity[j].Timestamp)
	})

	// Limit to 10 most recent activities
	if len(context.RecentActivity) > 10 {
		context.RecentActivity = context.RecentActivity[:10]
	}

	// Calculate metrics
	if len(tasks) > 0 {
		context.Metrics.CompletionRate = float64(completedTasks) / float64(len(tasks)) * 100
		context.Metrics.AverageTaskAge = totalAge / float64(len(tasks))
	}
	context.Metrics.TasksCompletedWeek = tasksCompletedThisWeek
	context.Metrics.TasksCreatedWeek = tasksCreatedThisWeek

	// Determine velocity trend
	if tasksCompletedThisWeek > tasksCreatedThisWeek {
		context.Metrics.VelocityTrend = "increasing"
	} else if tasksCompletedThisWeek < tasksCreatedThisWeek {
		context.Metrics.VelocityTrend = "decreasing"
	} else {
		context.Metrics.VelocityTrend = "stable"
	}

	// Generate project health assessment
	context.ProjectHealth = assessProjectHealth(context)

	// Generate suggestions
	context.Suggestions = generateSuggestions(context)

	return context, nil
}

// assessProjectHealth provides an overall health assessment
func assessProjectHealth(ctx *TaskContext) string {
	score := 100.0

	// Deduct points for various issues
	if ctx.OverdueTasks > 0 {
		score -= float64(ctx.OverdueTasks) * 5
	}

	if ctx.BlockedTasks > 0 {
		score -= float64(ctx.BlockedTasks) * 3
	}

	if ctx.Metrics.CompletionRate < 50 {
		score -= 20
	}

	if ctx.Metrics.VelocityTrend == "decreasing" {
		score -= 10
	}

	// Determine health status
	switch {
	case score >= 90:
		return "excellent"
	case score >= 75:
		return "good"
	case score >= 60:
		return "fair"
	case score >= 40:
		return "needs attention"
	default:
		return "critical"
	}
}

// generateSuggestions creates actionable suggestions based on context
func generateSuggestions(ctx *TaskContext) []string {
	suggestions := []string{}

	if ctx.OverdueTasks > 0 {
		suggestions = append(suggestions, fmt.Sprintf("Review and update %d overdue tasks", ctx.OverdueTasks))
	}

	if ctx.BlockedTasks > 0 {
		suggestions = append(suggestions, fmt.Sprintf("Address blockers for %d blocked tasks", ctx.BlockedTasks))
	}

	if ctx.TasksByPriority["urgent"] > 5 {
		suggestions = append(suggestions, "Too many urgent tasks - consider re-prioritizing")
	}

	if ctx.Metrics.CompletionRate < 30 {
		suggestions = append(suggestions, "Low completion rate - focus on closing existing tasks")
	}

	if ctx.Metrics.VelocityTrend == "decreasing" {
		suggestions = append(suggestions, "Task creation outpacing completion - consider capacity planning")
	}

	if len(ctx.RecentActivity) == 0 {
		suggestions = append(suggestions, "No recent activity - project may be stalled")
	}

	return suggestions
}

// EnrichToolResponse adds context to tool responses
func EnrichToolResponse(response string, context *TaskContext) string {
	var contextInfo []string

	if context.ProjectHealth != "excellent" && context.ProjectHealth != "good" {
		contextInfo = append(contextInfo, fmt.Sprintf("Project health: %s", context.ProjectHealth))
	}

	if context.OverdueTasks > 0 {
		contextInfo = append(contextInfo, fmt.Sprintf("%d tasks are overdue", context.OverdueTasks))
	}

	if len(contextInfo) > 0 {
		return fmt.Sprintf("%s\n\nContext: %s", response, strings.Join(contextInfo, ", "))
	}

	return response
}
</file>

<file path="cmd/mcp_errors.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"errors"
	"fmt"
	"strings"
)

// MCP error types for better error categorization
var (
	ErrInvalidInput      = errors.New("invalid input")
	ErrTaskNotFound      = errors.New("task not found")
	ErrDependencyConflict = errors.New("dependency conflict")
	ErrPermissionDenied  = errors.New("permission denied")
	ErrResourceConflict  = errors.New("resource conflict")
)

// MCPError provides structured error information for MCP responses
type MCPError struct {
	Code    string                 `json:"code"`
	Message string                 `json:"message"`
	Details map[string]interface{} `json:"details,omitempty"`
}

func (e *MCPError) Error() string {
	return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// NewMCPError creates a new structured MCP error
func NewMCPError(code string, message string, details map[string]interface{}) *MCPError {
	return &MCPError{
		Code:    code,
		Message: message,
		Details: details,
	}
}

// ValidateTaskInput validates common task input parameters
func ValidateTaskInput(title, priority, status string) error {
	// Title validation
	if title != "" && len(strings.TrimSpace(title)) < 3 {
		return NewMCPError("INVALID_TITLE", "Task title must be at least 3 characters long", map[string]interface{}{
			"field": "title",
			"value": title,
		})
	}

	// Priority validation
	if priority != "" {
		validPriorities := map[string]bool{"low": true, "medium": true, "high": true, "urgent": true}
		if !validPriorities[strings.ToLower(priority)] {
			return NewMCPError("INVALID_PRIORITY", "Invalid priority value", map[string]interface{}{
				"field":           "priority",
				"value":           priority,
				"valid_values":    []string{"low", "medium", "high", "urgent"},
			})
		}
	}

	// Status validation
	if status != "" {
		validStatuses := map[string]bool{
			"pending": true, "in-progress": true, "completed": true,
			"cancelled": true, "on-hold": true, "blocked": true, "needs-review": true,
		}
		if !validStatuses[strings.ToLower(status)] {
			return NewMCPError("INVALID_STATUS", "Invalid status value", map[string]interface{}{
				"field":        "status",
				"value":        status,
				"valid_values": []string{"pending", "in-progress", "completed", "cancelled", "on-hold", "blocked", "needs-review"},
			})
		}
	}

	return nil
}

// WrapStoreError wraps store errors with more context
func WrapStoreError(err error, operation string, taskID string) error {
	if err == nil {
		return nil
	}

	// Check for common error patterns
	errStr := err.Error()
	
	if strings.Contains(errStr, "not found") {
		return NewMCPError("TASK_NOT_FOUND", fmt.Sprintf("Task %s not found", taskID), map[string]interface{}{
			"operation": operation,
			"task_id":   taskID,
		})
	}

	if strings.Contains(errStr, "circular dependency") {
		return NewMCPError("CIRCULAR_DEPENDENCY", "Operation would create a circular dependency", map[string]interface{}{
			"operation": operation,
			"task_id":   taskID,
		})
	}

	if strings.Contains(errStr, "dependents") {
		return NewMCPError("HAS_DEPENDENTS", "Cannot delete task with dependent tasks", map[string]interface{}{
			"operation": operation,
			"task_id":   taskID,
		})
	}

	// Generic error
	return NewMCPError("OPERATION_FAILED", fmt.Sprintf("%s operation failed: %v", operation, err), map[string]interface{}{
		"operation":     operation,
		"task_id":       taskID,
		"original_error": err.Error(),
	})
}
</file>

<file path="cmd/mcp_prompts.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"context"
	"fmt"
	"strings"

	"github.com/josephgoksu/taskwing.app/store"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// taskGenerationPromptHandler generates tasks from natural language descriptions
func taskGenerationPromptHandler(taskStore store.TaskStore) func(context.Context, *mcp.ServerSession, *mcp.GetPromptParams) (*mcp.GetPromptResult, error) {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.GetPromptParams) (*mcp.GetPromptResult, error) {
		// Get the description argument
		description := params.Arguments["description"]

		if strings.TrimSpace(description) == "" {
			return nil, fmt.Errorf("description argument is required")
		}

		// Get existing tasks for context
		tasks, err := taskStore.ListTasks(nil, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to get existing tasks: %w", err)
		}

		// Create context about existing tasks
		var existingTasksContext string
		if len(tasks) > 0 {
			existingTasksContext = fmt.Sprintf("\n\nExisting tasks in the system (%d tasks):\n", len(tasks))
			for _, task := range tasks {
				existingTasksContext += fmt.Sprintf("- %s (ID: %s, Status: %s, Priority: %s)\n",
					task.Title, task.ID, task.Status, task.Priority)
			}
		} else {
			existingTasksContext = "\n\nNo existing tasks in the system."
		}

		// Generate the prompt
		prompt := fmt.Sprintf(`You are a task management assistant helping to break down work into manageable tasks.

User's Request: %s

Please analyze this request and create well-structured tasks. For each task, provide:
1. A clear, actionable title
2. A detailed description of what needs to be done
3. Acceptance criteria that define when the task is complete
4. Appropriate priority level (low, medium, high, urgent)
5. Any dependencies between tasks

Guidelines:
- Break down complex work into smaller, manageable tasks
- Each task should be completable in a reasonable timeframe
- Use clear, specific language
- Consider dependencies and logical order
- Include testing and documentation tasks where appropriate
- Think about potential risks and edge cases

When suggesting task dependencies, consider:
- Tasks that must be completed before others can start
- Tasks that can be done in parallel
- Critical path items that might block other work%s

Please format your response as a structured breakdown with clear task definitions that can be easily converted into TaskWing tasks.`,
			description, existingTasksContext)

		logInfo("Generated task generation prompt")

		return &mcp.GetPromptResult{
			Description: fmt.Sprintf("Generate tasks from: %s", description),
			Messages: []*mcp.PromptMessage{
				{
					Role: "user",
					Content: &mcp.TextContent{
						Text: prompt,
					},
				},
			},
		}, nil
	}
}

// taskBreakdownPromptHandler breaks down a complex task into smaller subtasks
func taskBreakdownPromptHandler(taskStore store.TaskStore) func(context.Context, *mcp.ServerSession, *mcp.GetPromptParams) (*mcp.GetPromptResult, error) {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.GetPromptParams) (*mcp.GetPromptResult, error) {
		// Get the task_id argument
		taskID := params.Arguments["task_id"]

		if strings.TrimSpace(taskID) == "" {
			return nil, fmt.Errorf("task_id argument is required")
		}

		// Get the task
		task, err := taskStore.GetTask(taskID)
		if err != nil {
			return nil, fmt.Errorf("failed to get task: %w", err)
		}

		// Get related tasks (dependencies and dependents)
		var relatedTasksContext string
		if len(task.Dependencies) > 0 {
			relatedTasksContext += "\n\nDependencies:\n"
			for _, depID := range task.Dependencies {
				if depTask, err := taskStore.GetTask(depID); err == nil {
					relatedTasksContext += fmt.Sprintf("- %s (ID: %s)\n", depTask.Title, depTask.ID)
				}
			}
		}

		if len(task.Dependents) > 0 {
			relatedTasksContext += "\n\nDependent tasks:\n"
			for _, depID := range task.Dependents {
				if depTask, err := taskStore.GetTask(depID); err == nil {
					relatedTasksContext += fmt.Sprintf("- %s (ID: %s)\n", depTask.Title, depTask.ID)
				}
			}
		}

		// Generate the prompt
		prompt := fmt.Sprintf(`You are a task management assistant helping to break down a complex task into smaller, manageable subtasks.

Task to Break Down:
Title: %s
Description: %s
Acceptance Criteria: %s
Priority: %s
Status: %s%s

Please analyze this task and break it down into smaller, more manageable subtasks. For each subtask, provide:
1. A clear, actionable title
2. A detailed description of what needs to be done
3. Acceptance criteria that define when the subtask is complete
4. Appropriate priority level (considering the parent task's priority)
5. Any dependencies between subtasks

Guidelines:
- Each subtask should be completable independently
- Break down the work into logical, sequential steps
- Consider testing, documentation, and review tasks
- Ensure subtasks cover all aspects of the parent task
- Think about potential risks and edge cases
- Consider the existing dependencies and dependent tasks

The subtasks should collectively fulfill the parent task's acceptance criteria and move it toward completion.

Please format your response as a structured breakdown with clear subtask definitions that can be easily converted into TaskWing tasks.`,
			task.Title, task.Description, task.AcceptanceCriteria, task.Priority, task.Status, relatedTasksContext)

		logInfo(fmt.Sprintf("Generated task breakdown prompt for task: %s", task.ID))

		return &mcp.GetPromptResult{
			Description: fmt.Sprintf("Break down task: %s", task.Title),
			Messages: []*mcp.PromptMessage{
				{
					Role: "user",
					Content: &mcp.TextContent{
						Text: prompt,
					},
				},
			},
		}, nil
	}
}
</file>

<file path="cmd/mcp_resources.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/josephgoksu/taskwing.app/store"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// tasksResourceHandler provides access to all tasks in JSON format
func tasksResourceHandler(taskStore store.TaskStore) mcp.ResourceHandler {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.ReadResourceParams) (*mcp.ReadResourceResult, error) {
		// List all tasks
		tasks, err := taskStore.ListTasks(nil, nil)
		if err != nil {
			return nil, fmt.Errorf("failed to list tasks: %w", err)
		}

		// Convert to response format
		taskResponses := make([]TaskResponse, len(tasks))
		for i, task := range tasks {
			taskResponses[i] = taskToResponse(task)
		}

		// Marshal to JSON
		jsonData, err := json.MarshalIndent(taskResponses, "", "  ")
		if err != nil {
			return nil, fmt.Errorf("failed to marshal tasks to JSON: %w", err)
		}

		logInfo(fmt.Sprintf("Provided tasks resource with %d tasks", len(tasks)))

		return &mcp.ReadResourceResult{
			Contents: []*mcp.ResourceContents{
				{
					URI:      params.URI,
					MIMEType: "application/json",
					Text:     string(jsonData),
				},
			},
		}, nil
	}
}

// configResourceHandler provides access to TaskWing configuration
func configResourceHandler() mcp.ResourceHandler {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.ReadResourceParams) (*mcp.ReadResourceResult, error) {
		// Get current simple configuration
		config := GetConfig()

		// Use the simple config structure directly
		mcpConfig := config

		// Marshal to JSON
		jsonData, err := json.MarshalIndent(mcpConfig, "", "  ")
		if err != nil {
			return nil, fmt.Errorf("failed to marshal config to JSON: %w", err)
		}

		logInfo("Provided config resource")

		return &mcp.ReadResourceResult{
			Contents: []*mcp.ResourceContents{
				{
					URI:      params.URI,
					MIMEType: "application/json",
					Text:     string(jsonData),
				},
			},
		}, nil
	}
}
</file>

<file path="cmd/utils.go">
package cmd

import "github.com/josephgoksu/taskwing.app/models"

// Helper to convert priority to an integer for sorting
func priorityToInt(p models.TaskPriority) int {
	switch p {
	case models.PriorityUrgent:
		return 4
	case models.PriorityHigh:
		return 3
	case models.PriorityMedium:
		return 2
	case models.PriorityLow:
		return 1
	default:
		return 0 // Should not happen with validated data
	}
}

// Helper to convert status to an integer for sorting (example order)
func statusToInt(s models.TaskStatus) int {
	switch s {
	case models.StatusPending:
		return 1
	case models.StatusInProgress:
		return 2
	case models.StatusBlocked:
		return 3
	case models.StatusNeedsReview:
		return 4
	case models.StatusOnHold:
		return 5
	case models.StatusCompleted:
		return 6
	case models.StatusCancelled:
		return 7
	default:
		return 0 // Should not happen
	}
}
</file>

<file path="prompts/loader.go">
package prompts

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// PromptKey is a type for identifying specific prompts.
type PromptKey string

const (
	// KeyGenerateTasks is the key for the main task generation prompt.
	KeyGenerateTasks PromptKey = "GenerateTasks"
	// KeyEstimateTasks is the key for the task estimation prompt.
	KeyEstimateTasks PromptKey = "EstimateTasks"
	// KeyImprovePRD is the key for the PRD improvement prompt.
	KeyImprovePRD PromptKey = "ImprovePRD"
)

// promptConfig defines the default content and filename for a prompt.
type promptConfig struct {
	defaultContent string
	filename       string
}

// promptRegistry maps a PromptKey to its configuration.
var promptRegistry = map[PromptKey]promptConfig{
	KeyGenerateTasks: {
		defaultContent: GenerateTasksSystemPrompt,
		filename:       "generate_tasks_prompt.txt",
	},
	KeyEstimateTasks: {
		defaultContent: EstimateTasksSystemPrompt,
		filename:       "estimate_tasks_prompt.txt",
	},
	KeyImprovePRD: {
		defaultContent: ImprovePRDSystemPrompt,
		filename:       "improve_prd_prompt.txt",
	},
}

// GetPrompt searches for a user-provided prompt file in the project's templates
// directory. If found, it returns the content of that file. Otherwise, it returns
// the hardcoded default prompt content.
func GetPrompt(key PromptKey, templatesDir string) (string, error) {
	config, ok := promptRegistry[key]
	if !ok {
		return "", fmt.Errorf("unrecognized prompt key: %s", key)
	}

	// If templatesDir is not configured or is empty, always use default.
	if strings.TrimSpace(templatesDir) == "" {
		return config.defaultContent, nil
	}

	customPromptPath := filepath.Join(templatesDir, config.filename)

	// Check if the custom prompt file exists.
	if _, err := os.Stat(customPromptPath); err == nil {
		// File exists, read its content.
		content, readErr := os.ReadFile(customPromptPath)
		if readErr != nil {
			return "", fmt.Errorf("failed to read custom prompt file at %s: %w", customPromptPath, readErr)
		}
		// Use the custom prompt.
		fmt.Printf("Using custom prompt from: %s\n", customPromptPath) // Inform user
		return string(content), nil
	} else if !os.IsNotExist(err) {
		// Some other error occurred when checking for the file (e.g., permissions).
		return "", fmt.Errorf("error checking for custom prompt file at %s: %w", customPromptPath, err)
	}

	// File does not exist, so return the default content.
	return config.defaultContent, nil
}
</file>

<file path=".taskwing.example.yaml">
# TaskWing Configuration Example
# Copy this to .taskwing.yaml in your project or home directory

project:
  # Base directory for TaskWing files
  rootDir: ".taskwing"
  
  # Directory for task data (relative to rootDir)
  tasksDir: "tasks"
  
  # Log file path
  outputLogPath: "logs/taskwing.log"

data:
  # Task data file name
  file: "tasks.json"
  
  # Data format: json, yaml, or toml
  format: "json"

# Optional: LLM Configuration (for task generation)
# llm:
#   provider: "openai"
#   modelName: "gpt-5-mini-2025-08-07"
#   # apiKey: "sk-..." # Set via OPENAI_API_KEY or TASKWING_LLM_APIKEY
#   maxOutputTokens: 16384
#   temperature: 0.7

# Optional: Debug settings
debug: false
verbose: false
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

TaskWing is an AI-assisted CLI task manager for developers built in Go. It provides comprehensive task management with Model Context Protocol (MCP) integration for seamless AI tool interaction.

## Development Commands

### Building and Testing

```bash
# Build the binary
go build -o taskwing main.go

# Run tests (standard Go testing)
go test ./...

# Run with development setup
./taskwing init
./taskwing add
```

### Key CLI Commands for Testing

```bash
# Initialize TaskWing in current directory
taskwing init

# Core task operations
taskwing add                    # Interactive task creation
taskwing list [filters]         # List with optional filtering
taskwing update [task_id]       # Update existing task
taskwing delete [task_id]       # Delete task (checks dependencies)
taskwing done [task_id]         # Mark task completed
taskwing show [task_id]         # Show detailed task info

# MCP server for AI integration
taskwing mcp                    # Start MCP server
taskwing mcp -v                 # Start with verbose logging

# Configuration management
taskwing config [key] [value]   # Manage configuration
```

## Architecture

### Core Components

- **cmd/**: Cobra-based CLI commands with MCP integration
- **models/**: Core Task model with validation (go-playground/validator)
- **store/**: TaskStore interface with file-based implementation
- **llm/**: AI integration layer for task generation
- **prompts/**: System prompts for LLM interactions

### Key Data Flow

1. **CLI Commands** ‚Üí **TaskStore Interface** ‚Üí **File Storage** (JSON/YAML/TOML)
2. **MCP Server** ‚Üí **MCP Tools/Resources/Prompts** ‚Üí **TaskStore Interface**
3. **AI Tools** ‚Üî **MCP Protocol** ‚Üî **TaskWing**

### MCP Integration Architecture

TaskWing implements a full MCP server with:

- **6 Tools**: add-task, list-tasks, update-task, delete-task, mark-done, get-task
- **2 Resources**: taskwing://tasks (JSON data), taskwing://config (settings)
- **2 Prompts**: task-generation, task-breakdown

MCP implementation is split across:

- `cmd/mcp.go`: Server setup and tool registration
- `cmd/mcp_tools.go`: Tool handlers (CRUD operations)
- `cmd/mcp_resources.go`: Resource handlers (data access)
- `cmd/mcp_prompts.go`: Prompt handlers (AI assistance)

### Task Model

Tasks have comprehensive metadata:

- **Core Fields**: ID (UUID), Title, Description, AcceptanceCriteria
- **Status**: pending, in-progress, completed, cancelled, on-hold, blocked, needs-review
- **Priority**: low, medium, high, urgent
- **Relationships**: ParentID, SubtaskIDs, Dependencies, Dependents
- **Timestamps**: CreatedAt, UpdatedAt, CompletedAt

### Configuration System

Uses Viper with hierarchical configuration:

1. Project: `.taskwing/.taskwing.yaml`
2. Directory: `./.taskwing.yaml`
3. Home: `$HOME/.taskwing.yaml`

Environment variables with `TASKWING_` prefix override file settings.

Key configuration options:

- `project.rootDir`: Base directory (default: `.taskwing`)
- `project.tasksDir`: Tasks directory (default: `tasks`)
- `data.file`: Data file name (default: `tasks.json`)
- `data.format`: Storage format (json/yaml/toml)

### Store Interface

All persistence goes through `store.TaskStore` interface:

- **CRUD Operations**: CreateTask, GetTask, UpdateTask, DeleteTask
- **Querying**: ListTasks with filtering and sorting
- **Dependencies**: GetTaskWithDescendents for hierarchy
- **Data Integrity**: File locking (gofrs/flock) and checksum validation
- **Batch Operations**: DeleteTasks, DeleteAllTasks

### Interactive UI Patterns

Uses promptui for consistent interactive experiences:

- Task selection with search functionality
- Custom templates for task display
- Error handling with `ErrNoTasksFound` for empty selections

### Dependencies and Key Libraries

**CLI Framework**: spf13/cobra + spf13/viper
**UI**: manifoldco/promptui for interactive prompts
**Validation**: go-playground/validator with struct tags
**Display**: jedib0t/go-pretty for table formatting
**MCP**: modelcontextprotocol/go-sdk for AI integration
**Storage**: File-based with gofrs/flock for concurrency safety

## Code Patterns

### Error Handling

- Use `ErrNoTasksFound` for interactive selection scenarios
- Wrap errors with context using `fmt.Errorf`
- Validate all structs using validator tags

### MCP Tool Implementation

- All tools use typed parameters with `omitempty` JSON tags for optional fields
- Tools return structured content with text descriptions
- Error responses use `isError: true` in CallToolResult, not JSON-RPC errors

### Task Dependencies

- Circular dependency validation prevents invalid relationships
- Dependents are managed automatically when dependencies are set
- Delete operations check for dependents before allowing removal

### Configuration Access

- Use `GetConfig()` function in cmd package for unified config access
- Configuration is loaded once during command initialization
- Environment variables automatically override file settings
</file>

<file path="example.env">
# TaskWing Environment Variables Example
# Copy this file to .env and fill in your actual values.
# Do NOT commit your .env file to version control if it contains sensitive information.

# --- LLM Configuration ---
# Used by the 'taskwing generate tasks' command.

# General LLM Settings (can be overridden by .taskwing/.taskwing.yaml)
# TASKWING_LLM_PROVIDER="openai"  # or "google"
# TASKWING_LLM_MODELNAME="gpt-4o-mini" # Example: "gpt-4o-mini", "gpt-4o", "gemini-1.5-pro-latest"
# TASKWING_LLM_MAXOUTPUTTOKENS=2048
# TASKWING_LLM_TEMPERATURE=0.7

# OpenAI Specific (Required if provider is "openai")
# OPENAI_API_KEY="sk-your_openai_api_key_here"
# Alternatively, you can use TASKWING_LLM_APIKEY for OpenAI if OPENAI_API_KEY is not set.
# TASKWING_LLM_APIKEY="sk-your_openai_api_key_here"

# Google Cloud Specific (Required if provider is "google")
# TASKWING_LLM_PROJECTID="your-gcp-project-id"
# For Google Cloud, authentication is typically handled via Application Default Credentials (ADC)
# or a service account key JSON file (GOOGLE_APPLICATION_CREDENTIALS).
# If you are using an API Key for Google (less common for Vertex AI direct calls but might be supported by some proxy/gateway):
# GOOGLE_API_KEY="your_google_api_key_here"
# TASKWING_LLM_APIKEY="your_google_api_key_here"

# --- Other Configurations ---
# (Add other environment variables as your application grows)

# Example: Verbose logging for TaskWing CLI (can also be set via --verbose flag)
# TASKWING_VERBOSE=true

# Example: Custom path for the main configuration file (overrides default search paths)
# TASKWING_CONFIG="/custom/path/to/.taskwing.yaml"

# Note: Actual API keys should be in your local .env file, not committed here.
</file>

<file path="MCP_GUIDE.md">
# MCP Integration Guide

This guide explains how to integrate TaskWing with AI tools using the Model Context Protocol (MCP).

## Overview

TaskWing's MCP server enables AI tools to directly manage your tasks through a standardized protocol. This allows for seamless integration with AI assistants like Claude Code, Cursor, and other MCP-compatible tools.

```mermaid
sequenceDiagram
    participant AI as AI Tool
    participant MCP as TaskWing MCP
    participant Store as Task Store

    AI->>MCP: Initialize Connection
    MCP->>AI: Capabilities (Tools, Resources, Prompts)

    AI->>MCP: add-task {"title": "New Feature"}
    MCP->>Store: Create Task
    Store->>MCP: Task Created
    MCP->>AI: Task Response

    AI->>MCP: list-tasks {"status": "pending"}
    MCP->>Store: Query Tasks
    Store->>MCP: Filtered Tasks
    MCP->>AI: Task List
```

## Quick Setup

### 1. Start MCP Server

```bash
# Start the MCP server
taskwing mcp

# Or with verbose logging for debugging
taskwing mcp -v
```

The server runs over stdin/stdout and will remain active until the AI tool disconnects.

### 2. Configure Your AI Tool

#### Claude Code

Add to your Claude Code MCP configuration file:

```json
{
  "mcpServers": {
    "taskwing": {
      "command": "taskwing",
      "args": ["mcp"],
      "env": {
        "TASKWING_DATA_DIR": ".taskwing"
      }
    }
  }
}
```

#### Cursor IDE

Add to your Cursor settings:

```json
{
  "mcp": {
    "servers": {
      "taskwing": {
        "command": "taskwing",
        "args": ["mcp"]
      }
    }
  }
}
```

#### Other AI Tools

For any MCP-compatible tool, use:

- **Command**: `taskwing`
- **Arguments**: `["mcp"]`
- **Protocol**: stdin/stdout JSON-RPC

## MCP Tools Reference

### Task Management Tools

| Tool          | Purpose          | Required Args | Optional Args                                                                      |
| ------------- | ---------------- | ------------- | ---------------------------------------------------------------------------------- |
| `add-task`    | Create new task  | `title`       | `description`, `acceptanceCriteria`, `priority`, `dependencies`                    |
| `list-tasks`  | Query tasks      | None          | `status`, `priority`, `search`, `parentId`, `sortBy`, `sortOrder`                  |
| `update-task` | Modify task      | `id`          | `title`, `description`, `acceptanceCriteria`, `status`, `priority`, `dependencies` |
| `delete-task` | Remove task      | `id`          | None                                                                               |
| `mark-done`   | Complete task    | `id`          | None                                                                               |
| `get-task`    | Get task details | `id`          | None                                                                               |

### Advanced Tools

| Tool           | Purpose                                                        | Required Args        | Optional Args                                  |
| -------------- | -------------------------------------------------------------- | -------------------- | ---------------------------------------------- |
| `bulk-tasks`   | Perform bulk operations (complete, cancel, delete, prioritize) | `task_ids`, `action` | `priority` (for 'prioritize' action)           |
| `task-summary` | Get a high-level summary of all tasks and project health       | None                 | None                                           |
| `search-tasks` | Advanced search with logical operators and date filters        | `query`              | `tags`, `date_from`, `date_to`, `has_subtasks` |

### Example Tool Usage

```json
{
  "tool": "add-task",
  "arguments": {
    "title": "Implement user authentication",
    "description": "Add login and registration functionality",
    "acceptanceCriteria": "Users can log in, register, and reset passwords",
    "priority": "high"
  }
}
```

## MCP Resources

### taskwing://tasks

Provides read-only access to all tasks in JSON format.

**Usage**: Perfect for AI tools that need to understand your current task list and project status.

### taskwing://config

Exposes TaskWing configuration settings.

**Usage**: Helps AI tools understand your project structure and preferences.

## MCP Prompts

### task-generation

Generates structured tasks from natural language descriptions.

**Arguments**:

- `description` (required): Natural language description of work to be done

**Example**:

```json
{
  "prompt": "task-generation",
  "arguments": {
    "description": "Create a REST API for user management with authentication"
  }
}
```

### task-breakdown

Breaks down complex tasks into smaller, manageable subtasks.

**Arguments**:

- `task_id` (required): ID of the task to break down

**Example**:

```json
{
  "prompt": "task-breakdown",
  "arguments": {
    "task_id": "abc123-def456-ghi789"
  }
}
```

## Common Workflows

### 1. AI-Assisted Task Creation

1. Describe your work to the AI tool
2. AI uses `task-generation` prompt to create structured tasks
3. AI uses `add-task` tool to create tasks in TaskWing
4. Review and refine tasks as needed

### 2. Project Planning

1. AI reads current tasks via `taskwing://tasks` resource
2. AI analyzes project status and dependencies
3. AI suggests new tasks or modifications
4. AI creates tasks using appropriate tools

### 3. Task Breakdown

1. Identify complex tasks using `list-tasks`
2. Use `task-breakdown` prompt for detailed breakdown
3. Create subtasks with `add-task`
4. Update original task with `update-task`

## Troubleshooting

### MCP Server Won't Start

```bash
# Check TaskWing is properly built
go build -o taskwing main.go

# Ensure TaskWing is initialized
./taskwing init

# Test basic functionality
./taskwing list
```

### AI Tool Can't Connect

1. **Verify command path**: Ensure `taskwing` is in PATH or use absolute path
2. **Check permissions**: Verify TaskWing has read/write access to project directory
3. **Test manually**: Run `taskwing mcp -v` to see detailed logs

### No Tasks Visible

1. **Check initialization**: Run `taskwing init` in your project
2. **Verify data file**: Ensure `.taskwing/tasks/tasks.json` exists
3. **Test with CLI**: Create a task with `taskwing add` and verify with `taskwing list`

## Security

- MCP server communicates only over stdin/stdout (no network exposure)
- All data remains local to your project
- AI tools can only access tasks and configuration through defined MCP interfaces
- No sensitive data is exposed through the MCP protocol

## Advanced Configuration

### Custom Data Directory

```bash
export TASKWING_PROJECT_ROOTDIR="/path/to/custom/location"
taskwing mcp
```

### Project-Specific MCP Setup

Create `.taskwing/.taskwing.yaml`:

```yaml
project:
  rootDir: ".taskwing"
  tasksDir: "tasks"

data:
  file: "tasks.json"
  format: "json"
```

Then start MCP server from the project directory:

```bash
cd /path/to/your/project
taskwing mcp
```

## Best Practices

1. **Initialize TaskWing** in each project before using MCP
2. **Use descriptive task titles** for better AI understanding
3. **Set up dependencies** properly for complex workflows
4. **Regular backups** of your `.taskwing` directory
5. **Use verbose mode** (`-v`) when debugging MCP issues

---

For more information, visit the [TaskWing repository](https://github.com/josephgoksu/taskwing.app).
</file>

<file path=".github/workflows/release.yml">
name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Run tests
        run: go test ./...

  goreleaser:
    runs-on: ubuntu-latest
    needs: test
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Run GoReleaser
        uses: goreleaser/goreleaser-action@v5
        with:
          distribution: goreleaser
          version: latest
          args: release --clean
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
</file>

<file path="cmd/mcp_tools.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"context"
	"fmt"
	"sort"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/josephgoksu/taskwing.app/models"
	"github.com/josephgoksu/taskwing.app/store"
	"github.com/modelcontextprotocol/go-sdk/mcp"
)

// addTaskHandler creates a new task
func addTaskHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[AddTaskParams, TaskResponse] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[AddTaskParams]) (*mcp.CallToolResultFor[TaskResponse], error) {
		args := params.Arguments
		logToolCall("add-task", args)

		// Validate required fields
		if strings.TrimSpace(args.Title) == "" {
			return nil, NewMCPError("MISSING_TITLE", "Task title is required", map[string]interface{}{
				"field": "title",
			})
		}

		// Validate input
		if err := ValidateTaskInput(args.Title, args.Priority, ""); err != nil {
			return nil, err
		}

		// Set priority with default
		priority := models.PriorityMedium
		if args.Priority != "" {
			switch strings.ToLower(args.Priority) {
			case "low":
				priority = models.PriorityLow
			case "medium":
				priority = models.PriorityMedium
			case "high":
				priority = models.PriorityHigh
			case "urgent":
				priority = models.PriorityUrgent
			}
		}

		// Create new task
		task := models.Task{
			ID:                 uuid.New().String(),
			Title:              strings.TrimSpace(args.Title),
			Description:        strings.TrimSpace(args.Description),
			AcceptanceCriteria: strings.TrimSpace(args.AcceptanceCriteria),
			Status:             models.StatusPending,
			Priority:           priority,
			Dependencies:       args.Dependencies,
			Dependents:         []string{},
			CreatedAt:          time.Now(),
			UpdatedAt:          time.Now(),
		}

		// Validate task
		if err := models.ValidateStruct(task); err != nil {
			return nil, NewMCPError("VALIDATION_FAILED", fmt.Sprintf("Task validation failed: %s", err.Error()), nil)
		}

		// Create task in store
		createdTask, err := taskStore.CreateTask(task)
		if err != nil {
			return nil, WrapStoreError(err, "create", task.ID)
		}

		logInfo(fmt.Sprintf("Created task: %s", createdTask.ID))

		// Get context for enriched response
		context, _ := BuildTaskContext(taskStore)
		responseText := fmt.Sprintf("Created task '%s' with ID: %s", createdTask.Title, createdTask.ID)
		if context != nil {
			responseText = EnrichToolResponse(responseText, context)
		}

		return &mcp.CallToolResultFor[TaskResponse]{
			Content: []mcp.Content{
				&mcp.TextContent{
					Text: responseText,
				},
			},
			StructuredContent: taskToResponse(createdTask),
			IsError: false,
		}, nil
	}
}

// listTasksHandler lists tasks with optional filtering
func listTasksHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[ListTasksParams, TaskListResponse] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[ListTasksParams]) (*mcp.CallToolResultFor[TaskListResponse], error) {
		args := params.Arguments

		// Create filter function
		filterFn := func(task models.Task) bool {
			// Filter by status
			if args.Status != "" {
				if string(task.Status) != args.Status {
					return false
				}
			}

			// Filter by priority
			if args.Priority != "" {
				if string(task.Priority) != args.Priority {
					return false
				}
			}

			// Filter by parent ID
			if args.ParentID != "" {
				if task.ParentID == nil || *task.ParentID != args.ParentID {
					return false
				}
			}

			// Search in title and description
			if args.Search != "" {
				search := strings.ToLower(args.Search)
				title := strings.ToLower(task.Title)
				description := strings.ToLower(task.Description)
				if !strings.Contains(title, search) && !strings.Contains(description, search) {
					return false
				}
			}

			return true
		}

		// Create sort function
		var sortFn func([]models.Task) []models.Task
		if args.SortBy != "" {
			sortFn = createSortFunction(args.SortBy, args.SortOrder)
		}

		// List tasks
		tasks, err := taskStore.ListTasks(filterFn, sortFn)
		if err != nil {
			return nil, WrapStoreError(err, "list", "multiple")
		}

		// Convert to response format
		taskResponses := make([]TaskResponse, len(tasks))
		for i, task := range tasks {
			taskResponses[i] = taskToResponse(task)
		}

		response := TaskListResponse{
			Tasks: taskResponses,
			Count: len(taskResponses),
		}

		logInfo(fmt.Sprintf("Listed %d tasks", len(tasks)))

		// Get context for enriched response
		context, _ := BuildTaskContext(taskStore)
		responseText := fmt.Sprintf("Found %d tasks", len(tasks))
		if context != nil {
			responseText = EnrichToolResponse(responseText, context)
		}

		return &mcp.CallToolResultFor[TaskListResponse]{
			Content: []mcp.Content{
				&mcp.TextContent{
					Text: responseText,
				},
			},
			StructuredContent: response,
		}, nil
	}
}

// updateTaskHandler updates an existing task
func updateTaskHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[UpdateTaskParams, TaskResponse] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[UpdateTaskParams]) (*mcp.CallToolResultFor[TaskResponse], error) {
		args := params.Arguments

		// Validate required fields
		if strings.TrimSpace(args.ID) == "" {
			return nil, NewMCPError("MISSING_ID", "Task ID is required for update", nil)
		}

		// Build updates map
		updates := make(map[string]interface{})

		if strings.TrimSpace(args.Title) != "" {
			updates["title"] = strings.TrimSpace(args.Title)
		}

		if args.Description != "" {
			updates["description"] = strings.TrimSpace(args.Description)
		}

		if args.AcceptanceCriteria != "" {
			updates["acceptanceCriteria"] = strings.TrimSpace(args.AcceptanceCriteria)
		}

		if args.Status != "" {
			if err := ValidateTaskInput("", "", args.Status); err != nil {
				return nil, err
			}
			updates["status"] = models.TaskStatus(args.Status)
		}

		if args.Priority != "" {
			if err := ValidateTaskInput("", args.Priority, ""); err != nil {
				return nil, err
			}
			updates["priority"] = models.TaskPriority(args.Priority)
		}

		if args.Dependencies != nil {
			updates["dependencies"] = args.Dependencies
		}

		// Update task
		updatedTask, err := taskStore.UpdateTask(args.ID, updates)
		if err != nil {
			return nil, WrapStoreError(err, "update", args.ID)
		}

		logInfo(fmt.Sprintf("Updated task: %s", updatedTask.ID))

		// Get context for enriched response
		context, _ := BuildTaskContext(taskStore)
		responseText := fmt.Sprintf("Updated task '%s' (ID: %s)", updatedTask.Title, updatedTask.ID)
		if context != nil {
			responseText = EnrichToolResponse(responseText, context)
		}

		return &mcp.CallToolResultFor[TaskResponse]{
			Content: []mcp.Content{
				&mcp.TextContent{
					Text: responseText,
				},
			},
			StructuredContent: taskToResponse(updatedTask),
		}, nil
	}
}

// deleteTaskHandler deletes a task
func deleteTaskHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[DeleteTaskParams, bool] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[DeleteTaskParams]) (*mcp.CallToolResultFor[bool], error) {
		args := params.Arguments

		// Validate required fields
		if strings.TrimSpace(args.ID) == "" {
			return nil, NewMCPError("MISSING_ID", "Task ID is required for deletion", nil)
		}

		// Get task to check for dependents and for response text
		task, err := taskStore.GetTask(args.ID)
		if err != nil {
			return nil, WrapStoreError(err, "get_for_delete", args.ID)
		}

		// Check if task has dependents
		if len(task.Dependents) > 0 {
			return nil, NewMCPError("HAS_DEPENDENTS", "Cannot delete task with dependent tasks", map[string]interface{}{
				"task_id":    args.ID,
				"dependents": task.Dependents,
			})
		}

		// Delete task
		if err := taskStore.DeleteTask(args.ID); err != nil {
			return nil, WrapStoreError(err, "delete", args.ID)
		}

		logInfo(fmt.Sprintf("Deleted task: %s", args.ID))

		// Get context for enriched response
		context, _ := BuildTaskContext(taskStore)
		responseText := fmt.Sprintf("Deleted task '%s' (ID: %s)", task.Title, task.ID)
		if context != nil {
			responseText = EnrichToolResponse(responseText, context)
		}

		return &mcp.CallToolResultFor[bool]{
			Content: []mcp.Content{
				&mcp.TextContent{
					Text: responseText,
				},
			},
			StructuredContent: true,
		}, nil
	}
}

// markDoneHandler marks a task as completed
func markDoneHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[MarkDoneParams, TaskResponse] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[MarkDoneParams]) (*mcp.CallToolResultFor[TaskResponse], error) {
		args := params.Arguments

		// Validate required fields
		if strings.TrimSpace(args.ID) == "" {
			return nil, NewMCPError("MISSING_ID", "Task ID is required to mark as done", nil)
		}

		// Mark task as done
		completedTask, err := taskStore.MarkTaskDone(args.ID)
		if err != nil {
			return nil, WrapStoreError(err, "mark_done", args.ID)
		}

		logInfo(fmt.Sprintf("Marked task as done: %s", completedTask.ID))

		// Get context for enriched response
		context, _ := BuildTaskContext(taskStore)
		responseText := fmt.Sprintf("Marked task '%s' as completed (ID: %s)", completedTask.Title, completedTask.ID)
		if context != nil {
			responseText = EnrichToolResponse(responseText, context)
		}

		return &mcp.CallToolResultFor[TaskResponse]{
			Content: []mcp.Content{
				&mcp.TextContent{
					Text: responseText,
				},
			},
			StructuredContent: taskToResponse(completedTask),
		}, nil
	}
}

// getTaskHandler retrieves a specific task
func getTaskHandler(taskStore store.TaskStore) mcp.ToolHandlerFor[GetTaskParams, TaskResponse] {
	return func(ctx context.Context, ss *mcp.ServerSession, params *mcp.CallToolParamsFor[GetTaskParams]) (*mcp.CallToolResultFor[TaskResponse], error) {
		args := params.Arguments

		// Validate required fields
		if strings.TrimSpace(args.ID) == "" {
			return nil, NewMCPError("MISSING_ID", "Task ID is required to get a task", nil)
		}

		// Get task
		task, err := taskStore.GetTask(args.ID)
		if err != nil {
			return nil, WrapStoreError(err, "get", args.ID)
		}

		logInfo(fmt.Sprintf("Retrieved task: %s", task.ID))

		// Get context for enriched response
		context, _ := BuildTaskContext(taskStore)
		responseText := fmt.Sprintf("Task '%s' (ID: %s)", task.Title, task.ID)
		if context != nil {
			responseText = EnrichToolResponse(responseText, context)
		}

		return &mcp.CallToolResultFor[TaskResponse]{
			Content: []mcp.Content{
				&mcp.TextContent{
					Text: responseText,
				},
			},
			StructuredContent: taskToResponse(task),
		}, nil
	}
}

// Helper function to create sort function
func createSortFunction(sortBy, sortOrder string) func([]models.Task) []models.Task {
	return func(tasks []models.Task) []models.Task {
		sort.SliceStable(tasks, func(i, j int) bool {
			t1 := tasks[i]
			t2 := tasks[j]
			var less bool
			switch strings.ToLower(sortBy) {
			case "id":
				less = t1.ID < t2.ID
			case "title":
				less = strings.ToLower(t1.Title) < strings.ToLower(t2.Title)
			case "status":
				less = statusToInt(t1.Status) < statusToInt(t2.Status)
			case "priority":
				less = priorityToInt(t1.Priority) < priorityToInt(t2.Priority)
			case "createdat":
				less = t1.CreatedAt.Before(t2.CreatedAt)
			case "updatedat":
				less = t1.UpdatedAt.Before(t2.UpdatedAt)
			default:
				// Default to createdAt if sort field is unknown
				less = t1.CreatedAt.Before(t2.CreatedAt)
			}
			if strings.ToLower(sortOrder) == "desc" {
				return !less
			}
			return less
		})
		return tasks
	}
}
</file>

<file path="cmd/mcp.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"context"
	"fmt"
	"log"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/josephgoksu/taskwing.app/store"
	"github.com/modelcontextprotocol/go-sdk/mcp"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// mcpCmd represents the mcp command
var mcpCmd = &cobra.Command{
	Use:   "mcp",
	Short: "Start MCP server for AI tool integration",
	Long: `Start a Model Context Protocol (MCP) server to enable AI tools like Claude Code,
Cursor, and other AI assistants to interact with TaskWing tasks.

The MCP server runs over stdin/stdout and provides tools for:
- Adding new tasks
- Listing and filtering tasks
- Updating existing tasks
- Deleting tasks
- Marking tasks as done
- Getting task details

Example usage with Claude Code:
  taskwing mcp

The server will run until the client disconnects.`,
	RunE: func(cmd *cobra.Command, args []string) error {
		return runMCPServer(cmd.Context())
	},
}

func init() {
	rootCmd.AddCommand(mcpCmd)
	// MCP server inherits verbose flag from root command
}

func runMCPServer(ctx context.Context) error {

	// Initialize TaskWing store
	taskStore, err := GetStore()
	if err != nil {
		return fmt.Errorf("failed to initialize task store: %w", err)
	}
	defer taskStore.Close()

	// Create MCP server
	impl := &mcp.Implementation{
		Name:    "taskwing",
		Version: version,
	}
	
	// Create server options with notification handlers
	serverOpts := &mcp.ServerOptions{
		// Handle the initialized notification properly
		InitializedHandler: func(ctx context.Context, serverSession *mcp.ServerSession, params *mcp.InitializedParams) {
			logInfo("MCP client initialized successfully")
		},
	}
	
	server := mcp.NewServer(impl, serverOpts)

	// Register MCP tools
	if err := registerMCPTools(server, taskStore); err != nil {
		return fmt.Errorf("failed to register MCP tools: %w", err)
	}

	// Register advanced MCP tools
	if err := RegisterAdvancedMCPTools(server, taskStore); err != nil {
		return fmt.Errorf("failed to register advanced MCP tools: %w", err)
	}

	// Register MCP resources
	if err := registerMCPResources(server, taskStore); err != nil {
		return fmt.Errorf("failed to register MCP resources: %w", err)
	}

	// Register MCP prompts
	if err := registerMCPPrompts(server, taskStore); err != nil {
		return fmt.Errorf("failed to register MCP prompts: %w", err)
	}

	// Run the server over stdin/stdout
	if err := server.Run(ctx, mcp.NewStdioTransport()); err != nil {
		return fmt.Errorf("MCP server failed: %w", err)
	}

	return nil
}

func registerMCPTools(server *mcp.Server, taskStore store.TaskStore) error {
	// Add task tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "add-task",
		Description: "Create a new task with comprehensive details. Returns the created task with its unique ID. Validates all inputs and checks for dependency conflicts.",
	}, addTaskHandler(taskStore))

	// List tasks tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "list-tasks",
		Description: "List and filter tasks with powerful search capabilities. Supports filtering by status, priority, parent task, and text search. Returns task count and detailed task information.",
	}, listTasksHandler(taskStore))

	// Update task tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "update-task",
		Description: "Update any properties of an existing task. Supports partial updates - only provide fields you want to change. Validates all changes and maintains data integrity.",
	}, updateTaskHandler(taskStore))

	// Delete task tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "delete-task",
		Description: "Safely delete a task by ID. Prevents deletion of tasks with dependents to maintain referential integrity. Returns clear error messages if deletion is blocked.",
	}, deleteTaskHandler(taskStore))

	// Mark task done tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "mark-done",
		Description: "Mark a task as completed and set its completion timestamp. This is a convenience method that updates status to 'completed' and records completion time.",
	}, markDoneHandler(taskStore))

	// Get task tool
	mcp.AddTool(server, &mcp.Tool{
		Name:        "get-task",
		Description: "Retrieve comprehensive details about a specific task including all metadata, relationships, and timestamps. Useful for examining task state before updates.",
	}, getTaskHandler(taskStore))

	return nil
}

func registerMCPResources(server *mcp.Server, taskStore store.TaskStore) error {
	// Tasks resource - provides access to task data
	server.AddResource(&mcp.Resource{
		URI:         "taskwing://tasks",
		Name:        "tasks",
		Description: "Access to all tasks in JSON format",
		MIMEType:    "application/json",
	}, tasksResourceHandler(taskStore))

	// Config resource - provides access to TaskWing configuration
	server.AddResource(&mcp.Resource{
		URI:         "taskwing://config",
		Name:        "config",
		Description: "TaskWing configuration settings",
		MIMEType:    "application/json",
	}, configResourceHandler())

	return nil
}

func registerMCPPrompts(server *mcp.Server, taskStore store.TaskStore) error {
	// Task generation prompt
	server.AddPrompt(&mcp.Prompt{
		Name:        "task-generation",
		Description: "Generate tasks from natural language descriptions",
		Arguments: []*mcp.PromptArgument{
			{
				Name:        "description",
				Description: "Natural language description of work to be done",
				Required:    true,
			},
		},
	}, taskGenerationPromptHandler(taskStore))

	// Task breakdown prompt
	server.AddPrompt(&mcp.Prompt{
		Name:        "task-breakdown",
		Description: "Break down a complex task into smaller subtasks",
		Arguments: []*mcp.PromptArgument{
			{
				Name:        "task_id",
				Description: "ID of the task to break down",
				Required:    true,
			},
		},
	}, taskBreakdownPromptHandler(taskStore))

	return nil
}

// Task-related type definitions for MCP tools
type AddTaskParams struct {
	Title              string   `json:"title" mcp:"Task title (required)"`
	Description        string   `json:"description,omitempty" mcp:"Task description"`
	AcceptanceCriteria string   `json:"acceptanceCriteria,omitempty" mcp:"Acceptance criteria for task completion"`
	Priority           string   `json:"priority,omitempty" mcp:"Task priority: low, medium, high, urgent"`
	Dependencies       []string `json:"dependencies,omitempty" mcp:"List of task IDs this task depends on"`
}

type ListTasksParams struct {
	Status    string `json:"status,omitempty" mcp:"Filter by status: pending, in-progress, completed, cancelled, on-hold, blocked, needs-review"`
	Priority  string `json:"priority,omitempty" mcp:"Filter by priority: low, medium, high, urgent"`
	Search    string `json:"search,omitempty" mcp:"Search in title and description"`
	ParentID  string `json:"parentId,omitempty" mcp:"Filter by parent task ID"`
	SortBy    string `json:"sortBy,omitempty" mcp:"Sort by: id, title, priority, createdAt, updatedAt"`
	SortOrder string `json:"sortOrder,omitempty" mcp:"Sort order: asc, desc"`
}

type UpdateTaskParams struct {
	ID                 string   `json:"id" mcp:"Task ID to update (required)"`
	Title              string   `json:"title,omitempty" mcp:"New task title"`
	Description        string   `json:"description,omitempty" mcp:"New task description"`
	AcceptanceCriteria string   `json:"acceptanceCriteria,omitempty" mcp:"New acceptance criteria"`
	Status             string   `json:"status,omitempty" mcp:"New task status"`
	Priority           string   `json:"priority,omitempty" mcp:"New task priority"`
	Dependencies       []string `json:"dependencies,omitempty" mcp:"New dependencies list"`
}

type DeleteTaskParams struct {
	ID string `json:"id" mcp:"Task ID to delete (required)"`
}

type MarkDoneParams struct {
	ID string `json:"id" mcp:"Task ID to mark as done (required)"`
}

type GetTaskParams struct {
	ID string `json:"id" mcp:"Task ID to retrieve (required)"`
}

// Tool response types
type TaskResponse struct {
	ID                 string   `json:"id"`
	Title              string   `json:"title"`
	Description        string   `json:"description"`
	AcceptanceCriteria string   `json:"acceptanceCriteria"`
	Status             string   `json:"status"`
	Priority           string   `json:"priority"`
	Dependencies       []string `json:"dependencies"`
	Dependents         []string `json:"dependents"`
	CreatedAt          string   `json:"createdAt"`
	UpdatedAt          string   `json:"updatedAt"`
	CompletedAt        *string  `json:"completedAt"`
}

type TaskListResponse struct {
	Tasks []TaskResponse `json:"tasks"`
	Count int            `json:"count"`
}

func taskToResponse(task models.Task) TaskResponse {
	var completedAt *string
	if task.CompletedAt != nil {
		completed := task.CompletedAt.Format("2006-01-02T15:04:05Z")
		completedAt = &completed
	}

	return TaskResponse{
		ID:                 task.ID,
		Title:              task.Title,
		Description:        task.Description,
		AcceptanceCriteria: task.AcceptanceCriteria,
		Status:             string(task.Status),
		Priority:           string(task.Priority),
		Dependencies:       task.Dependencies,
		Dependents:         task.Dependents,
		CreatedAt:          task.CreatedAt.Format("2006-01-02T15:04:05Z"),
		UpdatedAt:          task.UpdatedAt.Format("2006-01-02T15:04:05Z"),
		CompletedAt:        completedAt,
	}
}

func logError(err error) {
	if viper.GetBool("verbose") {
		log.Printf("[MCP ERROR] %v", err)
	}
}

func logInfo(msg string) {
	if viper.GetBool("verbose") {
		log.Printf("[MCP INFO] %s", msg)
	}
}

func logDebug(msg string) {
	if viper.GetBool("verbose") {
		log.Printf("[MCP DEBUG] %s", msg)
	}
}

func logToolCall(toolName string, params interface{}) {
	if viper.GetBool("verbose") {
		log.Printf("[MCP TOOL] %s called with params: %+v", toolName, params)
	}
}
</file>

<file path="cmd/reset.go">
package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

// resetCmd represents the reset command
var resetCmd = &cobra.Command{
	Use:   "reset",
	Short: "Resets the TaskWing project by removing its configuration and data.",
	Long: `Resets the current TaskWing project.
This command will remove the project's root directory (e.g., '.taskwing/'),
which includes all task data, logs, and any project-specific configuration files stored within it.
It allows you to start over by running 'taskwing init' again.
This command does NOT delete global configuration files (e.g., in your home directory)
or configuration files specified explicitly via the --config flag if they are outside
the project's root directory.`,
	Run: func(cmd *cobra.Command, args []string) {
		// Ensure configuration is loaded to get project paths
		// initConfig() is called by cobra.OnInitialize in root.go, so GlobalAppConfig should be populated.
		cfg := GetConfig()
		projectRootDir := cfg.Project.RootDir

		// Check if the project root directory exists
		if _, err := os.Stat(projectRootDir); os.IsNotExist(err) {
			fmt.Printf("No TaskWing project found at '%s' to reset. Nothing to do.\n", projectRootDir)
			// If viper is using a config file, mention it.
			configFileUsed := viper.ConfigFileUsed()
			if configFileUsed != "" {
				fmt.Printf("Note: A configuration file was loaded from '%s'. This file was not touched.\n", configFileUsed)
			}
			return
		}

		fmt.Printf("The following directory and all its contents will be PERMANENTLY DELETED:\n")
		fmt.Printf("- %s\n\n", projectRootDir)
		fmt.Printf("This includes all tasks, logs, and project-specific configurations within this directory.\n")

		prompt := promptui.Prompt{
			Label:     fmt.Sprintf("Are you sure you want to reset the project by deleting '%s'?", projectRootDir),
			IsConfirm: true,
		}

		_, err := prompt.Run()
		if err != nil {
			// Handles 'no' (promptui.ErrAbort) and actual errors
			if err == promptui.ErrAbort {
				fmt.Println("Project reset cancelled.")
				os.Exit(0)
			}
			HandleError("Error: Could not get confirmation for project reset.", err)
			return // Unreachable, for clarity
		}

		fmt.Printf("Deleting project directory '%s'...\n", projectRootDir)
		err = os.RemoveAll(projectRootDir)
		if err != nil {
			HandleError(fmt.Sprintf("Error: Failed to delete project directory '%s'. Check permissions or delete it manually.", projectRootDir), err)
		}

		fmt.Printf("TaskWing project at '%s' has been reset successfully.\n", projectRootDir)
		fmt.Println("You can now run 'taskwing init' to start a new project.")

		// Advise about potentially loaded config file if it wasn't inside projectRootDir
		configFileUsed := viper.ConfigFileUsed()
		if configFileUsed != "" {
			absProjectRootDir, absErr := filepath.Abs(projectRootDir)
			if absErr == nil {
				absConfigFileUsed, absConfErr := filepath.Abs(configFileUsed)
				if absConfErr == nil {
					if !strings.HasPrefix(strings.ToLower(absConfigFileUsed), strings.ToLower(absProjectRootDir)) && absConfigFileUsed != absProjectRootDir {
						fmt.Printf("Note: The configuration file loaded from '%s' was not part of the deleted project directory and has not been removed.\n", configFileUsed)
					}
				}
			} else if !strings.Contains(strings.ToLower(configFileUsed), strings.ToLower(projectRootDir)) { // Fallback to simple string check if absolute path resolution fails
				fmt.Printf("Note: The configuration file loaded from '%s' may not have been part of the deleted project directory and might not have been removed.\n", configFileUsed)
			}
		}
	},
}

func init() {
	rootCmd.AddCommand(resetCmd)
}
</file>

<file path="cmd/show.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"fmt"
	"strings"
	"time"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/josephgoksu/taskwing.app/store"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
)

// showCmd represents the show command
var showCmd = &cobra.Command{
	Use:   "show [task_id]",
	Short: "Show details for a specific task",
	Long: `Displays detailed information about a single task, including its description,
status, priority, dependencies, parent, and subtasks.

If a task_id is provided, it will show details for that specific task.
Otherwise, it will present an interactive menu to select a task.`,
	Args: cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		taskStore, err := GetStore()
		if err != nil {
			HandleError("Error: could not get the task store", err)
		}
		defer taskStore.Close()

		var taskToShow models.Task
		var selectedTaskID string

		if len(args) > 0 {
			selectedTaskID = args[0]
		} else {
			// No ID provided, use interactive selector
			allTasks, err := taskStore.ListTasks(nil, nil)
			if err != nil {
				HandleError("Error: Could not list tasks for selection.", err)
			}
			if len(allTasks) == 0 {
				fmt.Println("No tasks found.")
				return
			}

			// Using the existing selectTaskInteractive function from root.go
			selectedTask, err := selectTaskInteractive(taskStore, nil, "Select a task to view its details")
			if err != nil {
				if err == promptui.ErrInterrupt {
					fmt.Println("Operation cancelled.")
					return
				}
				HandleError("Error: Could not select a task.", err)
			}
			selectedTaskID = selectedTask.ID
		}

		taskToShow, err = taskStore.GetTask(selectedTaskID)
		if err != nil {
			HandleError(fmt.Sprintf("Error: Could not retrieve task with ID '%s'.", selectedTaskID), err)
		}

		displayTaskDetails(taskToShow, taskStore)
	},
}

// displayTaskDetails prints a formatted view of a single task's details.
func displayTaskDetails(task models.Task, store store.TaskStore) {
	fmt.Println(strings.Repeat("-", 40))
	fmt.Printf("Task Details: %s\n", task.Title)
	fmt.Println(strings.Repeat("-", 40))

	fmt.Printf("  %-20s %s\n", "ID:", task.ID)
	fmt.Printf("  %-20s %s\n", "Status:", task.Status)
	fmt.Printf("  %-20s %s\n", "Priority:", task.Priority)
	fmt.Printf("  %-20s %s\n", "Created At:", task.CreatedAt.Format(time.RFC1123))
	fmt.Printf("  %-20s %s\n", "Last Updated:", task.UpdatedAt.Format(time.RFC1123))
	if task.CompletedAt != nil {
		fmt.Printf("  %-20s %s\n", "Completed At:", task.CompletedAt.Format(time.RFC1123))
	}

	fmt.Println(strings.Repeat("-", 40))

	// Description
	if task.Description != "" {
		fmt.Println("Description:")
		fmt.Printf("  %s\n", task.Description)
		fmt.Println(strings.Repeat("-", 40))
	}

	// Acceptance Criteria
	if task.AcceptanceCriteria != "" {
		fmt.Println("Acceptance Criteria:")
		// Split by newline and indent each line for readability
		for _, line := range strings.Split(task.AcceptanceCriteria, "\n") {
			fmt.Printf("  %s\n", line)
		}
		fmt.Println(strings.Repeat("-", 40))
	}

	// Relationships
	// Parent Task
	if task.ParentID != nil && *task.ParentID != "" {
		parentTask, err := store.GetTask(*task.ParentID)
		if err == nil {
			fmt.Printf("Parent Task: %s (ID: %s)\n", parentTask.Title, *task.ParentID)
		} else {
			fmt.Printf("Parent Task ID: %s (Could not fetch full details)\n", *task.ParentID)
		}
	} else {
		fmt.Println("Parent Task: None")
	}

	// Subtasks
	if len(task.SubtaskIDs) > 0 {
		fmt.Println("Subtasks:")
		for _, subID := range task.SubtaskIDs {
			subTask, err := store.GetTask(subID)
			if err == nil {
				fmt.Printf("  - %s (ID: %s, Status: %s)\n", subTask.Title, subID, subTask.Status)
			} else {
				fmt.Printf("  - (ID: %s - Could not fetch details)\n", subID)
			}
		}
	} else {
		fmt.Println("Subtasks: None")
	}

	// Dependencies
	if len(task.Dependencies) > 0 {
		fmt.Println("Depends On (Dependencies):")
		for _, depID := range task.Dependencies {
			depTask, err := store.GetTask(depID)
			if err == nil {
				fmt.Printf("  - %s (ID: %s, Status: %s)\n", depTask.Title, depID, depTask.Status)
			} else {
				fmt.Printf("  - (ID: %s - Could not fetch details)\n", depID)
			}
		}
	} else {
		fmt.Println("Depends On: None")
	}

	// Dependents
	if len(task.Dependents) > 0 {
		fmt.Println("Is a Dependency For (Dependents):")
		for _, depID := range task.Dependents {
			depTask, err := store.GetTask(depID)
			if err == nil {
				fmt.Printf("  - %s (ID: %s, Status: %s)\n", depTask.Title, depID, depTask.Status)
			} else {
				fmt.Printf("  - (ID: %s - Could not fetch details)\n", depID)
			}
		}
	} else {
		fmt.Println("Is a Dependency For: None")
	}

	fmt.Println(strings.Repeat("-", 40))
}

func init() {
	rootCmd.AddCommand(showCmd)
}
</file>

<file path="llm/factory.go">
package llm

import (
	"fmt"
	// Ensure no import from "github.com/josephgoksu/taskwing.app/cmd"
)

// NewProvider is a factory function that returns an instance of an llm.Provider
// based on the provided LLM configuration.
func NewProvider(config *LLMConfig) (Provider, error) {
	if config == nil {
		return nil, fmt.Errorf("LLM configuration cannot be nil")
	}

	apiKey := config.APIKey

	switch config.Provider {
	case "openai":
		if apiKey == "" {
			return nil, fmt.Errorf("OpenAI provider selected but API key is missing")
		}
		return NewOpenAIProvider(apiKey), nil
	case "": // No provider specified
		return nil, fmt.Errorf("no LLM provider specified in configuration")
	default:
		return nil, fmt.Errorf("unsupported LLM provider: %s", config.Provider)
	}
}
</file>

<file path="LICENSE">
Commons Clause License Condition v1.0

The Software is provided to you by the Licensor under the License, as defined below, subject to the following condition.

Without limiting other conditions in the License, the grant of rights under the License does not include the right to Sell the Software.

For purposes of the foregoing, "Sell" means to practice any or all of the rights granted to you under the License to provide to third parties, for a fee or other consideration (including without limitation fees for hosting or consulting/support services related to the Software), a product or service whose value derives, entirely or substantially, from the functionality of the Software. Any license notice or attribution required by the License must also include this Commons Clause License Condition notice.

---

The MIT License (MIT)

Copyright (c) 2024 The TaskWing Authors

Permission is hereby granted, free of charge, to a person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="main.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package main

import "github.com/josephgoksu/taskwing.app/cmd"

func main() {
	cmd.Execute()
}
</file>

<file path="product.xml">
<TaskWingApp>
  <Title>TaskWing.app</Title>
  <Subtitle>AI-Powered Task Management for Developers</Subtitle>
  <AlternativeSubtitle>Intelligent Task Generation</AlternativeSubtitle>
  <Overview>
    TaskWing.app is an open-source, AI-assisted task manager built for modern development workflows. Designed for engineers, indie hackers, and teams, it automates project planning, task breakdown, prioritization, and workflow clarity‚Äîso you can focus on building, not managing.
  </Overview>
  <KeyFeatures>
    <Feature>AI-Powered Task Generation: Automatically generate a complete project plan from a Product Requirements Document (PRD), including tasks, subtasks, priorities, and dependencies.</Feature>
    <Feature>Automated PRD Refinement: Optionally use an LLM to automatically improve your PRD for better clarity and more accurate task generation before planning.</Feature>
    <Feature>Interactive CLI Workflow: A powerful and user-friendly command-line interface for all core operations, with interactive prompts for creating, viewing, and completing tasks.</Feature>
    <Feature>Hierarchical &amp; Dependency-Aware: Full support for creating nested subtasks and defining dependencies between tasks, ensuring a logical project flow.</Feature>
    <Feature>Advanced Task Views: List tasks in a simple table or a hierarchical tree view. Powerful filtering by status, priority, or text search, and sorting by any field.</Feature>
    <Feature>Robust Local-First Storage: Persist tasks locally in JSON, YAML, or TOML. Data integrity is ensured through file locking and checksum verification.</Feature>
    <Feature>Secure &amp; Configurable: All configurations and API keys are stored locally and never leave your machine. Configure your preferred LLM provider (OpenAI currently supported) and model via config files or environment variables.</Feature>
    <Feature>Project Scaffolding &amp; Portability: Use the `init` command to quickly set up a new project. Built-in backup and restore commands make your data portable.</Feature>
  </KeyFeatures>
  <UseCases>
    <UseCase>Solo indie devs planning side projects with AI assistance.</UseCase>
    <UseCase>Product teams breaking down PRDs or RFCs into structured sprints.</UseCase>
    <UseCase>Open-source maintainers managing issues and PRs with automated clarity.</UseCase>
    <UseCase>Anyone who wants to "fly above" project chaos.</UseCase>
  </UseCases>
  <Tags>
    <Tag>AI</Tag>
    <Tag>devtools</Tag>
    <Tag>golang</Tag>
    <Tag>taskmanager</Tag>
    <Tag>open-source</Tag>
    <Tag>CLI</Tag>
    <Tag>editor-integration</Tag>
  </Tags>
</TaskWingApp>
</file>

<file path="cmd/add.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"fmt"
	"os"
	"strings"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
)

// addCmd represents the add command
var addCmd = &cobra.Command{
	Use:   "add",
	Short: "Add a new task",
	Long:  `Add a new task to the task manager. Prompts for title, description, priority, tags, dependencies, and optional parent task ID.`,
	Run: func(cmd *cobra.Command, args []string) {
		taskStore, err := GetStore()
		if err != nil {
			HandleError("Error: Could not initialize the task store.", err)
		}
		defer taskStore.Close()

		// Check if running in non-interactive mode
		nonInteractive, _ := cmd.Flags().GetBool("non-interactive")

		// Get title from flag or prompt
		title, err := cmd.Flags().GetString("title")
		if err != nil {
			HandleError("Error getting title flag", err)
		}
		if title == "" {
			if nonInteractive {
				HandleError("Title is required in non-interactive mode. Use --title flag.", nil)
				return
			}
			// Interactive prompt for title
			titlePrompt := promptui.Prompt{
				Label: "Task Title",
				Validate: func(input string) error {
					if len(strings.TrimSpace(input)) < 3 {
						return fmt.Errorf("title must be at least 3 characters long")
					}
					return nil
				},
			}
			title, err = titlePrompt.Run()
			if err != nil {
				if err == promptui.ErrInterrupt {
					fmt.Println("Task addition cancelled.")
					os.Exit(0)
				}
				HandleError("Error: Failed to read task title.", err)
			}
		}

		// Get description from flag or prompt
		description, err := cmd.Flags().GetString("description")
		if err != nil {
			HandleError("Error getting description flag", err)
		}
		if description == "" && !nonInteractive {
			descriptionPrompt := promptui.Prompt{
				Label: "Task Description (optional)",
			}
			description, err = descriptionPrompt.Run()
			if err != nil && err != promptui.ErrInterrupt {
				HandleError("Error: Failed to read task description.", err)
			}
		}

		// ... (similar logic for priority, dependencies, parentID)

		// Get priority from flag or prompt
		priorityStr, err := cmd.Flags().GetString("priority")
		if err != nil {
			HandleError("Error getting priority flag", err)
		}
		if priorityStr == "" {
			if nonInteractive {
				priorityStr = "medium" // Default priority in non-interactive mode
			} else {
				priorityPrompt := promptui.Select{
					Label: "Select Priority",
					Items: []string{"low", "medium", "high", "urgent"},
				}
				_, priorityStr, err = priorityPrompt.Run()
				if err != nil && err != promptui.ErrInterrupt {
					HandleError("Error: Failed to select priority.", err)
				}
			}
		}

		// Get dependencies from flag or prompt
		dependenciesStr, err := cmd.Flags().GetString("dependencies")
		if err != nil {
			HandleError("Error getting dependencies flag", err)
		}
		if dependenciesStr == "" && !nonInteractive {
			dependenciesPrompt := promptui.Prompt{
				Label: "Dependencies (comma-separated task IDs, optional)",
			}
			dependenciesStr, err = dependenciesPrompt.Run()
			if err != nil && err != promptui.ErrInterrupt {
				HandleError("Error: Failed to read dependencies.", err)
			}
		}
		var dependencies []string
		if dependenciesStr != "" {
			dependencies = strings.Split(dependenciesStr, ",")
			for i, dep := range dependencies {
				dependencies[i] = strings.TrimSpace(dep)
			}
		}

		// Get Parent ID from flag or prompt
		parentIDStr, err := cmd.Flags().GetString("parentID")
		if err != nil {
			HandleError("Error getting parentID flag", err)
		}
		if parentIDStr == "" && !nonInteractive {
			parentSelectPrompt := promptui.Prompt{
				Label: "Parent Task ID (optional, press Enter to skip)",
			}
			parentIDStr, err = parentSelectPrompt.Run()
			if err != nil && err != promptui.ErrInterrupt {
				HandleError("Error: Failed to read parent task ID.", err)
			}
		}
		var parentID *string
		if parentIDStr != "" {
			parentID = &parentIDStr
		}

		// Create the new task
		newTask := models.Task{
			Title:        title,
			Description:  description,
			Status:       models.StatusPending,
			Priority:     models.TaskPriority(priorityStr),
			Dependencies: dependencies,
			ParentID:     parentID,
		}

		createdTask, err := taskStore.CreateTask(newTask)
		if err != nil {
			HandleError("Error: Could not create the new task.", err)
		}

		fmt.Printf("‚úÖ Task added successfully!\n")
		fmt.Printf("ID: %s\nTitle: %s\n", createdTask.ID, createdTask.Title)
	},
}

func init() {
	rootCmd.AddCommand(addCmd)

	// Here you will define your flags and configuration settings.
	addCmd.Flags().String("title", "", "Title of the task")
	addCmd.Flags().String("description", "", "Description of the task")
	addCmd.Flags().String("priority", "medium", "Priority of the task (low, medium, high, urgent)")
	addCmd.Flags().String("dependencies", "", "Comma-separated task IDs that this task depends on")
	addCmd.Flags().String("parentID", "", "ID of the parent task")
	addCmd.Flags().Bool("non-interactive", false, "Run in non-interactive mode (requires --title flag)")

	// Cobra supports Persistent Flags which will work for this command
	// and all subcommands, e.g.:
	// addCmd.PersistentFlags().String("foo", "", "A help for foo")

	// Cobra supports local flags which will only run when this command
	// is called directly, e.g.:
	// addCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}

// getStore was moved to root.go or a central cmd utility file
/*
func getStore() (store.TaskStore, error) {
	// For now, using FileTaskStore with default config.
	// This should ideally come from a config loader (e.g., Viper in config.go)
	s := store.NewFileTaskStore()
	// Config can be expanded or loaded from viper
	err := s.Initialize(map[string]string{
		"dataFile":       "tasks.json",
		"dataFileFormat": "json",
	})
	if err != nil {
		return nil, fmt.Errorf("failed to initialize store: %w", err)
	}
	return s, nil
}
*/
</file>

<file path="cmd/list.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"strings"

	"github.com/jedib0t/go-pretty/v6/table"
	"github.com/josephgoksu/taskwing.app/models"
	"github.com/josephgoksu/taskwing.app/store"
	"github.com/spf13/cobra"
)

// listCmd represents the list command
var listCmd = &cobra.Command{
	Use:   "list",
	Short: "Lists tasks with filtering and sorting options",
	Long:  `Lists tasks with various filtering (status, priority, text, tags) and sorting capabilities.`,
	Run: func(cmd *cobra.Command, args []string) {
		taskStore, err := GetStore()
		if err != nil {
			HandleError("Error: could not get the task store", err)
		}
		defer taskStore.Close()

		// Retrieve filter flag values
		statusFilter, _ := cmd.Flags().GetString("status")
		priorityFilter, _ := cmd.Flags().GetString("priority")
		titleContainsFilter, _ := cmd.Flags().GetString("title-contains")
		descContainsFilter, _ := cmd.Flags().GetString("description-contains")
		searchQuery, _ := cmd.Flags().GetString("search")

		// New flags for subtask filtering
		filterByParentID, _ := cmd.Flags().GetString("parent")
		filterTopLevel, _ := cmd.Flags().GetBool("top-level")
		renderAsTree, _ := cmd.Flags().GetBool("tree")
		showAllTasks, _ := cmd.Flags().GetBool("all")
		jsonOutput, _ := cmd.Flags().GetBool("json")

		// Retrieve sorting flag values
		sortBy, _ := cmd.Flags().GetString("sort-by")
		sortOrder, _ := cmd.Flags().GetString("sort-order")

		var filterFns []func(models.Task) bool

		// Build filter functions based on flags
		if statusFilter != "" {
			statuses := strings.Split(strings.ToLower(statusFilter), ",")
			statusSet := make(map[models.TaskStatus]bool)
			for _, s := range statuses {
				statusSet[models.TaskStatus(s)] = true
			}
			filterFns = append(filterFns, func(t models.Task) bool {
				return statusSet[models.TaskStatus(strings.ToLower(string(t.Status)))]
			})
		}

		if priorityFilter != "" {
			priorities := strings.Split(strings.ToLower(priorityFilter), ",")
			prioSet := make(map[models.TaskPriority]bool)
			for _, p := range priorities {
				prioSet[models.TaskPriority(p)] = true
			}
			filterFns = append(filterFns, func(t models.Task) bool {
				return prioSet[models.TaskPriority(strings.ToLower(string(t.Priority)))]
			})
		}

		if titleContainsFilter != "" {
			lowerTitleFilter := strings.ToLower(titleContainsFilter)
			filterFns = append(filterFns, func(t models.Task) bool {
				return strings.Contains(strings.ToLower(t.Title), lowerTitleFilter)
			})
		}

		if descContainsFilter != "" {
			lowerDescFilter := strings.ToLower(descContainsFilter)
			filterFns = append(filterFns, func(t models.Task) bool {
				return strings.Contains(strings.ToLower(t.Description), lowerDescFilter)
			})
		}

		if searchQuery != "" {
			lowerSearchQuery := strings.ToLower(searchQuery)
			filterFns = append(filterFns, func(t models.Task) bool {
				return strings.Contains(strings.ToLower(t.Title), lowerSearchQuery) ||
					strings.Contains(strings.ToLower(t.Description), lowerSearchQuery) ||
					strings.Contains(strings.ToLower(t.ID), lowerSearchQuery)
			})
		}

		// New hierarchical filtering logic for non-tree view
		if !renderAsTree {
			if filterByParentID != "" {
				// --parent is specified, this takes precedence for hierarchy
				filterFns = append(filterFns, func(t models.Task) bool {
					return t.ParentID != nil && *t.ParentID == filterByParentID
				})
			} else if filterTopLevel {
				// --top-level is specified
				filterFns = append(filterFns, func(t models.Task) bool {
					return t.ParentID == nil || *t.ParentID == ""
				})
			} else if !showAllTasks {
				// DEFAULT table view: neither --parent, nor --top-level, nor --all is specified.
				// Show only top-level tasks.
				filterFns = append(filterFns, func(t models.Task) bool {
					return t.ParentID == nil || *t.ParentID == ""
				})
			}
			// If showAllTasks is true AND filterByParentID=="" AND !filterTopLevel, no *additional* hierarchical filter is added here.
			// This means list ALL tasks (subject to other filters like status, etc.).
		}

		// Ensure --top-level and --parent are not used together (this check should be effective).
		if filterTopLevel && filterByParentID != "" {
			// This is a user input error, not a technical one.
			fmt.Fprintln(os.Stderr, "Error: --top-level and --parent flags cannot be used together.")
			os.Exit(1)
		}

		// If --tree is used with a task ID argument, ensure other filters respect this context.
		// The task ID argument for list is not standard, so we will assume for now that
		// if a task ID is given (args[0]), and --tree is active, that ID is the root of the tree.
		var treeRootID string
		if len(args) > 0 && renderAsTree {
			treeRootID = args[0]
			// Potentially, one might want to clear other filters if a specific tree root is given,
			// or apply them only to the children of that root. For now, existing filters will select the pool of tasks
			// and if treeRootID is set, we start rendering from that task if it's in the pool.
		}

		// Composite filter function
		var finalFilterFn func(models.Task) bool
		if len(filterFns) > 0 {
			finalFilterFn = func(t models.Task) bool {
				for _, fn := range filterFns {
					if !fn(t) {
						return false
					}
				}
				return true
			}
		}

		// Sorting function
		var finalSortFn func([]models.Task) []models.Task
		if sortBy != "" {
			finalSortFn = func(tasks []models.Task) []models.Task {
				sort.SliceStable(tasks, func(i, j int) bool {
					t1 := tasks[i]
					t2 := tasks[j]
					var less bool
					switch strings.ToLower(sortBy) {
					case "id":
						less = t1.ID < t2.ID
					case "title":
						less = strings.ToLower(t1.Title) < strings.ToLower(t2.Title)
					case "status":
						less = statusToInt(t1.Status) < statusToInt(t2.Status)
					case "priority":
						less = priorityToInt(t1.Priority) < priorityToInt(t2.Priority)
					case "createdat":
						less = t1.CreatedAt.Before(t2.CreatedAt)
					case "updatedat":
						less = t1.UpdatedAt.Before(t2.UpdatedAt)
					default:
						// Default to createdAt if sort field is unknown
						less = t1.CreatedAt.Before(t2.CreatedAt)
					}
					if strings.ToLower(sortOrder) == "desc" {
						return !less
					}
					return less
				})
				return tasks
			}
		}

		tasks, err := taskStore.ListTasks(finalFilterFn, finalSortFn)
		if err != nil {
			HandleError("Failed to list tasks with filters/sorting", err)
		}

		if len(tasks) == 0 {
			if jsonOutput {
				fmt.Println("[]")
			} else {
				fmt.Println("No tasks found matching your criteria.")
			}
			return
		}

		if jsonOutput {
			// Output as JSON
			jsonData, err := json.MarshalIndent(tasks, "", "  ")
			if err != nil {
				HandleError("Failed to marshal tasks to JSON", err)
				return
			}
			fmt.Println(string(jsonData))
		} else if renderAsTree {
			displayTasksAsTree(tasks, treeRootID, taskStore, 0, finalFilterFn) // Pass taskStore for fetching children
		} else {
			t := table.NewWriter()
			t.SetOutputMirror(os.Stdout)
			t.SetStyle(table.StyleLight)
			t.AppendHeader(table.Row{"ID", "Title", "Status", "Priority", "ParentID", "Dependencies", "Dependents"})

			for _, task := range tasks {
				dependenciesStr := truncateUUIDList(task.Dependencies)
				dependentsStr := truncateUUIDList(task.Dependents)

				parentIDStr := "-"
				if task.ParentID != nil && *task.ParentID != "" {
					parentIDStr = truncateUUID(*task.ParentID)
				}

				t.AppendRow(table.Row{
					truncateUUID(task.ID),
					task.Title,
					task.Status,
					task.Priority,
					parentIDStr,
					dependenciesStr,
					dependentsStr,
				})
			}
			t.Render()
		}
	},
}

func init() {
	rootCmd.AddCommand(listCmd)

	// Filtering flags
	listCmd.Flags().String("status", "", "Filter by status (comma-separated, e.g., pending,in-progress)")
	listCmd.Flags().String("priority", "", "Filter by priority (comma-separated, e.g., high,urgent)")
	listCmd.Flags().String("title-contains", "", "Filter by text in title (case-insensitive)")
	listCmd.Flags().String("description-contains", "", "Filter by text in description (case-insensitive)")
	listCmd.Flags().String("search", "", "Generic search across title, description, ID (case-insensitive)")

	// Sorting flags
	listCmd.Flags().String("sort-by", "createdAt", "Sort tasks by field (id, title, status, priority, createdAt, updatedAt)")
	listCmd.Flags().String("sort-order", "asc", "Sort order (asc or desc)")

	// Subtask filtering flags
	listCmd.Flags().String("parent", "", "Filter tasks by Parent ID (shows direct subtasks of the given parent)")
	listCmd.Flags().Bool("top-level", false, "Filter to show only top-level tasks (tasks without a parent)")
	listCmd.Flags().Bool("tree", false, "Display tasks in a hierarchical tree structure. If a task ID is provided as an argument, the tree starts from that task.")
	listCmd.Flags().Bool("all", false, "Show all tasks in a flat list, including subtasks (overrides default top-level filtering for table view).")

	// Output format flags
	listCmd.Flags().Bool("json", false, "Output results in JSON format for automation and scripting")
}

// displayTasksAsTree recursively prints tasks in a tree structure.
// allTasks is the initial pool of tasks (potentially pre-filtered).
// currentTaskID is the ID of the task to start the current branch from (if "", print all top-level trees in allTasks).
// store is needed to fetch children details if not in allTasks (though ideally allTasks contains everything needed).
// indentLevel is for pretty printing.
// originalFilterFn is the filter applied to the initial list, to potentially check if a child should be displayed.
func displayTasksAsTree(allTasks []models.Task, currentTaskID string, store store.TaskStore, indentLevel int, originalFilterFn func(models.Task) bool) {
	if currentTaskID != "" { // Displaying a specific subtree
		var rootTask models.Task
		found := false
		for _, t := range allTasks {
			if t.ID == currentTaskID {
				// If an original filter was applied, the root of the tree must also satisfy it.
				if originalFilterFn == nil || originalFilterFn(t) {
					rootTask = t
					found = true
				}
				break
			}
		}
		if !found {
			// If the specified root ID was not found in the filtered list, try to fetch it directly.
			// This allows `list <id> --tree` even if `<id>` itself doesn't match other filters (e.g. --status), showing its subtree.
			fetchedRoot, err := store.GetTask(currentTaskID)
			if err == nil {
				rootTask = fetchedRoot
				found = true
			} else {
				HandleError(fmt.Sprintf("Error: Task ID %s specified for tree view not found.", currentTaskID), err)
				return // Unreachable due to HandleError exiting, but good practice.
			}
		}
		if found {
			printTaskWithIndent(rootTask, indentLevel)
			for _, subID := range rootTask.SubtaskIDs {
				displayTasksAsTree(allTasks, subID, store, indentLevel+1, originalFilterFn)
			}
		}
	} else { // Displaying all top-level tasks in the provided list as trees
		parentMap := make(map[string][]models.Task)
		topLevelTasks := []models.Task{}

		for _, task := range allTasks {
			if originalFilterFn != nil && !originalFilterFn(task) {
				continue // Skip tasks that don't match the main filter
			}
			if task.ParentID == nil || *task.ParentID == "" {
				topLevelTasks = append(topLevelTasks, task)
			} else {
				parentMap[*task.ParentID] = append(parentMap[*task.ParentID], task)
			}
		}

		// A simple sort for top-level tasks, e.g., by CreatedAt or Title, can be added here if needed.
		// sort.Slice(topLevelTasks, func(i, j int) bool { return topLevelTasks[i].CreatedAt.Before(topLevelTasks[j].CreatedAt) })

		for _, rootTask := range topLevelTasks {
			printTaskWithIndent(rootTask, indentLevel)
			recursivelyPrintChildren(rootTask, parentMap, store, indentLevel+1, originalFilterFn)
		}
	}
}

// recursivelyPrintChildren is a helper for displayTasksAsTree when starting from all top-level tasks.
// It uses a pre-built parentMap for efficiency within the initial filtered list.
func recursivelyPrintChildren(parentTask models.Task, parentMap map[string][]models.Task, store store.TaskStore, indentLevel int, originalFilterFn func(models.Task) bool) {
	// Children directly from parentMap (already filtered by originalFilterFn during map construction)
	if children, ok := parentMap[parentTask.ID]; ok {
		// Can sort children here if needed, e.g. by title or creation date
		for _, childTask := range children {
			printTaskWithIndent(childTask, indentLevel)
			recursivelyPrintChildren(childTask, parentMap, store, indentLevel+1, originalFilterFn)
		}
	} else if len(parentTask.SubtaskIDs) > 0 {
		// If children were not in parentMap (e.g. not matching original filter, or --tree <id> scenario)
		// but SubtaskIDs exist, fetch them directly. This path is more for the specific treeRootID scenario.
		// In the all-tasks tree, parentMap should be comprehensive for tasks matching the filter.
		for _, subID := range parentTask.SubtaskIDs {
			// This part could be complex if we need to re-evaluate originalFilterFn for lazily fetched children.
			// For now, if we are in this branch for the general tree, it implies these children were not in the initial `allTasks` that matched the filter.
			// We might decide not to print them, or fetch and print them regardless of the original filter.
			// For --tree <id>, this is how we fetch the entire subtree.
			subTask, err := store.GetTask(subID) // This assumes store.GetTask is efficient enough.
			if err == nil {
				// Decide if originalFilterFn should apply to these dynamically fetched children.
				// If --tree <id> is used, we typically want the whole subtree of <id>.
				// If --tree is used with general filters, children not matching filter might be skipped.
				// Current logic for all-tasks tree relies on parentMap, which respects originalFilterFn.
				// This else-if branch is more for the `currentTaskID != ""` path of displayTasksAsTree.
				printTaskWithIndent(subTask, indentLevel)
				recursivelyPrintChildren(subTask, parentMap, store, indentLevel+1, originalFilterFn) // parentMap won't be used for these
			}
		}
	}
}

// Helper function to truncate UUIDs for display
func truncateUUID(id string) string {
	if len(id) > 8 {
		return id[:8]
	}
	return id
}

// Helper function to truncate a list of UUIDs for display
func truncateUUIDList(ids []string) string {
	if len(ids) == 0 {
		return "-"
	}
	truncated := make([]string, len(ids))
	for i, id := range ids {
		truncated[i] = truncateUUID(id)
	}
	return strings.Join(truncated, ", ")
}

func printTaskWithIndent(task models.Task, indentLevel int) {
	indent := strings.Repeat("  ", indentLevel) // 2 spaces per indent level
	prefix := "\u251C\u2500\u2500 "             // ‚îú‚îÄ‚îÄ
	if indentLevel == 0 {
		prefix = ""
	} else {
		// This part needs a way to know if it's the last child to use \u2514\u2500\u2500 (‚îî‚îÄ‚îÄ)
		// For simplicity, always using ‚îú‚îÄ‚îÄ. A more complex tree renderer would track siblings.
	}
	fmt.Printf("%s%s[%s] %s (%s) Subtasks: %d, Parent: %s\n",
		indent,
		prefix,
		truncateUUID(task.ID),
		task.Title,
		task.Status,
		len(task.SubtaskIDs),
		printParentID(task.ParentID),
	)
}

func printParentID(parentID *string) string {
	if parentID == nil || *parentID == "" {
		return "none"
	}
	return *parentID
}
</file>

<file path="cmd/root.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/josephgoksu/taskwing.app/store"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	// cfgFile is the path to the configuration file.
	cfgFile string
	// verbose enables verbose output.
	verbose bool
	// ErrNoTasksFound is returned when an interactive selection is attempted but no tasks are available.
	ErrNoTasksFound = errors.New("no tasks found matching your criteria")
	// version is the application version.
	version = "0.1.0"
)

// rootCmd represents the base command when called without any subcommands
var rootCmd = &cobra.Command{
	Use:   "taskwing",
	Short: "TaskWing CLI helps you manage your tasks efficiently.",
	Long: `TaskWing CLI is a comprehensive tool to manage your tasks from the command line.
It allows you to initialize a task repository, add, list, update, and delete tasks.`,
	Run: func(cmd *cobra.Command, args []string) {
		// return help if no args are provided
		if len(args) == 0 {
			cmd.Help()
			os.Exit(0)
		}

		// otherwise, run the subcommand
	},
}

// Execute adds all child commands to the root command and sets flags appropriately.
// This is called by main.main(). It only needs to happen once to the rootCmd.
func Execute() {
	err := rootCmd.Execute()
	if err != nil {
		os.Exit(1)
	}
}

func init() {
	cobra.OnInitialize(InitConfig)

	// Here you will define your flags and configuration settings.
	// Cobra supports persistent flags, which, if defined here,
	// will be global for your application.
	rootCmd.PersistentFlags().StringVarP(&cfgFile, "config", "c", "", "config file (default is $HOME/.taskwing.yaml or ./.taskwing.yaml)")
	rootCmd.PersistentFlags().BoolVarP(&verbose, "verbose", "v", false, "enable verbose output")

	// Bind persistent flags to Viper
	viper.BindPFlag("config", rootCmd.PersistentFlags().Lookup("config"))
	viper.BindPFlag("verbose", rootCmd.PersistentFlags().Lookup("verbose"))

	// Cobra also supports local flags, which will only run
	// when this action is called directly.
	// Example:
	// rootCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}

// initConfig is defined in config.go

// GetTaskFilePath returns the full path to the tasks file
func GetTaskFilePath() string {
	config := GetConfig()
	return filepath.Join(config.Project.RootDir, config.Project.TasksDir, config.Data.File)
}

// GetStore initializes and returns the task store using the unified AppConfig.
func GetStore() (store.TaskStore, error) {
	s := store.NewFileTaskStore()
	config := GetConfig()

	taskFilePath := GetTaskFilePath()

	err := s.Initialize(map[string]string{
		"dataFile":       taskFilePath,
		"dataFileFormat": config.Data.Format,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to initialize store at %s: %w", taskFilePath, err)
	}
	return s, nil
}

// selectTaskInteractive presents a prompt to the user to select a task from a list.
// It can be filtered using the provided filter function.
func selectTaskInteractive(taskStore store.TaskStore, filterFn func(models.Task) bool, label string) (models.Task, error) {
	tasks, err := taskStore.ListTasks(filterFn, nil)
	if err != nil {
		return models.Task{}, fmt.Errorf("failed to list tasks for selection: %w", err)
	}

	if len(tasks) == 0 {
		return models.Task{}, ErrNoTasksFound
	}

	templates := &promptui.SelectTemplates{
		Label:    "{{ . }}?",
		Active:   `> {{ .Title | cyan }} (ID: {{ .ID }}, Status: {{ .Status }})`,
		Inactive: `  {{ .Title | faint }} (ID: {{ .ID }}, Status: {{ .Status }})`,
		Selected: `{{ "‚úî" | green }} {{ .Title | faint }} (ID: {{ .ID }})`,
		Details: `
--------- Task Details ----------
{{ "ID:\t" | faint }} {{ .ID }}
{{ "Title:\t" | faint }} {{ .Title }}
{{ "Description:\t" | faint }} {{ .Description }}
{{ "Status:\t" | faint }} {{ .Status }}
{{ "Priority:\t" | faint }} {{ .Priority }}`,
	}

	searcher := func(input string, index int) bool {
		task := tasks[index]
		name := strings.ToLower(task.Title)
		id := task.ID
		input = strings.ToLower(input)
		return strings.Contains(name, input) || strings.Contains(id, input)
	}

	prompt := promptui.Select{
		Label:     label,
		Items:     tasks,
		Templates: templates,
		Searcher:  searcher,
	}

	i, _, err := prompt.Run()
	if err != nil {
		return models.Task{}, err // Return error as is (includes promptui.ErrInterrupt)
	}

	return tasks[i], nil
}
</file>

<file path="cmd/version.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"fmt"

	"github.com/spf13/cobra"
)

// versionCmd represents the version command
var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "Print the version number of TaskWing",
	Long:  `All software has versions. This is TaskWing's.`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Printf("TaskWing CLI version %s\n", version)
	},
}

func init() {
	rootCmd.AddCommand(versionCmd)

	// Here you will define your flags and configuration settings.

	// Cobra supports Persistent Flags which will work for this command
	// and all subcommands, e.g.:
	// versionCmd.PersistentFlags().String("foo", "", "A help for foo")

	// Cobra supports local flags which will only run when this command
	// is called directly, e.g.:
	// versionCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}
</file>

<file path="models/task.go">
package models

import (
	"fmt"
	"strings"
	"time"

	"github.com/go-playground/validator/v10"
)

// TaskStatus represents the possible statuses of a task.
type TaskStatus string

const (
	StatusPending     TaskStatus = "pending"
	StatusInProgress  TaskStatus = "in-progress"
	StatusCompleted   TaskStatus = "completed"
	StatusCancelled   TaskStatus = "cancelled"
	StatusOnHold      TaskStatus = "on-hold"
	StatusBlocked     TaskStatus = "blocked"
	StatusNeedsReview TaskStatus = "needs-review"
)

// TaskPriority represents the priority levels of a task.
type TaskPriority string

const (
	PriorityLow    TaskPriority = "low"
	PriorityMedium TaskPriority = "medium"
	PriorityHigh   TaskPriority = "high"
	PriorityUrgent TaskPriority = "urgent"
)

// Task represents a unit of work.
type Task struct {
	ID                 string       `json:"id" validate:"required,uuid4"`
	Title              string       `json:"title" validate:"required,min=3,max=255"`
	Description        string       `json:"description,omitempty"`
	AcceptanceCriteria string       `json:"acceptanceCriteria,omitempty"`
	Status             TaskStatus   `json:"status" validate:"required,oneof=pending in-progress completed cancelled on-hold blocked needs-review"`
	ParentID           *string      `json:"parentId,omitempty" validate:"omitempty,uuid4"` // ID of the parent task
	SubtaskIDs         []string     `json:"subtaskIds,omitempty" validate:"dive,uuid4"`    // IDs of direct children tasks
	Dependencies       []string     `json:"dependencies,omitempty" validate:"dive,uuid4"`  // Slice of Task IDs this task depends on
	Dependents         []string     `json:"dependents,omitempty" validate:"dive,uuid4"`    // Slice of Task IDs that depend on this task (managed internally)
	Priority           TaskPriority `json:"priority" validate:"required,oneof=low medium high urgent"`
	CreatedAt          time.Time    `json:"createdAt" validate:"required"`
	UpdatedAt          time.Time    `json:"updatedAt" validate:"required"`
	CompletedAt        *time.Time   `json:"completedAt,omitempty"` // Optional: pointer to allow null
}

// TaskList represents a collection of tasks.
type TaskList struct {
	Tasks []Task `json:"tasks" validate:"dive"`
	// Could add pagination metadata here in the future
	TotalCount int `json:"totalCount"`
	Page       int `json:"page,omitempty"`
	PerPage    int `json:"perPage,omitempty"`
}

// global validator instance
var validate *validator.Validate

func init() {
	validate = validator.New()
	// Register custom validation functions here if needed
}

// ValidateStruct performs validation on any struct that has validation tags.
func ValidateStruct(s interface{}) error {
	if validate == nil {
		// This should ideally not happen if init() runs correctly,
		// but as a safeguard or for tests running in isolation.
		validate = validator.New()
	}
	err := validate.Struct(s)
	if err != nil {
		// Optionally, format validation errors for better readability
		validationErrors := err.(validator.ValidationErrors)
		var errorMessages []string
		for _, e := range validationErrors {
			// Customize error messages based on e.g. e.Tag(), e.Field(), e.Param()
			errorMessages = append(errorMessages, fmt.Sprintf("Validation failed on field '%s': rule '%s' (value: '%v')", e.StructNamespace(), e.Tag(), e.Value()))
		}
		return fmt.Errorf("%s", strings.Join(errorMessages, "; ")) // Simplified error return
	}
	return nil
}
</file>

<file path="prompts/prompts.go">
package prompts

// LLMPrompts holds templates for interacting with Large Language Models.
const (
	// System prompts define the persona and instructions for the LLM.

	// GenerateTasksSystemPrompt is the system prompt for the main task generation feature.
	// It instructs the LLM to act as a project manager and extract tasks from a PRD.
	GenerateTasksSystemPrompt = `<instructions>
You are an expert project manager AI. Your sole purpose is to deconstruct a Product Requirements Document (PRD) into a structured, hierarchical list of actionable engineering tasks.
</instructions>

<context>
The user will provide a PRD. This document contains all the necessary information. You must base your output exclusively on the content of this document.
</context>

<task>
Analyze the PRD and generate a complete list of tasks and subtasks. For every task and subtask, you must extract or infer the following fields:

1.  **title**: A concise and clear title for the task.
2.  **description**: A detailed description of the task's requirements. If no specific description is available in the PRD, use the title as the description. This field must always be populated.
3.  **acceptanceCriteria**: A short, bulleted list of 2-4 specific, verifiable conditions that must be met for the task to be considered complete.
4.  **priority**: Infer the task's priority from the document. Use one of these values: "low", "medium", "high", "urgent". If the priority is ambiguous, default to "medium".
5.  **tempId**: A unique, sequential integer ID for the task, starting from 1. This ID is used *only* for resolving dependencies within this JSON output.
6.  **subtasks**: A list of nested task objects that are direct children of the current task. If there are no subtasks, provide an empty list ` + "`" + `[]` + "`" + `.
7.  **dependsOnIds**: A list of ` + "`" + `tempId` + "`" + `s of other tasks from this same PRD that the current task depends on. If there are no dependencies, provide an empty list ` + "`" + `[]` + "`" + `. Only include ` + "`" + `tempId` + "`" + `s that you have also generated in your output.
</task>

<rules>
- **Task Granularity:** Focus on significant, actionable engineering tasks (e.g., "Implement user authentication endpoint," "Design database schema for profiles"). Avoid creating tasks for trivial items like documentation updates, simple configuration changes, or minor code refactoring unless the PRD explicitly calls them out as major work items. Consolidate closely related, small steps into a single, comprehensive task.
- **Strict JSON Output:** Your entire response MUST be a single, valid JSON object. Do not include any text, explanations, or Markdown formatting before or after the JSON object.
- **Root Key:** The root of the JSON object must be a key named "tasks".
- **Task Array:** The value of the "tasks" key must be an array of task objects, even if there is only one top-level task.
- **Completeness:** Ensure all actionable items from the PRD are captured as either a task or a subtask.
- **Recursive Structure:** The structure for subtasks is identical to the structure for top-level tasks.
</rules>

<output_format>
Return ONLY the following JSON structure. Do not deviate from this format.

{
  "tasks": [
    {
      "title": "Example Task Title",
      "description": "A detailed description of what needs to be done for this task.",
      "acceptanceCriteria": "- Criterion 1 is met.\n- Criterion 2 is verified.",
      "priority": "high",
      "tempId": 1,
      "subtasks": [
        {
          "title": "Example Subtask Title",
          "description": "Description for the subtask.",
          "acceptanceCriteria": "- Sub-criterion 1 is done.",
          "priority": "medium",
          "tempId": 2,
          "subtasks": [],
          "dependsOnIds": []
        }
      ],
      "dependsOnIds": [3]
    },
    {
      "title": "Title of Another Task",
      "description": "This task is a dependency for the first task.",
      "acceptanceCriteria": "- Prerequisite is in place.",
      "priority": "medium",
      "tempId": 3,
      "subtasks": [],
      "dependsOnIds": []
    }
  ]
}
</output_format>`

	// EstimateTasksSystemPrompt is used to get a quick estimation of task count and complexity.
	EstimateTasksSystemPrompt = `You are an AI assistant helping to estimate the scope of work from a Product Requirements Document (PRD).
Analyze the provided PRD content and perform the following:
1. Estimate the total number of primary tasks and significant sub-tasks that would be generated from this document.
2. Assess the overall complexity of the PRD as "low", "medium", or "high".

Return your response as a single, compact JSON object with exactly two keys:
- "estimatedTaskCount": An integer representing the total estimated number of tasks.
- "estimatedComplexity": A string, one of "low", "medium", or "high".

Example response:
{
  "estimatedTaskCount": 25,
  "estimatedComplexity": "medium"
}
Ensure your output is only the JSON object and nothing else.`

	// ImprovePRDSystemPrompt guides the LLM to act as a technical writer and improve a PRD.
	ImprovePRDSystemPrompt = `<instructions>
You are a top-tier senior product manager and technical writer. Your primary directive is to transform a given Product Requirements Document (PRD) into a model of clarity, structure, and actionability for a high-performing engineering team.
</instructions>

<context>
The user will provide a PRD. This document contains the core requirements for a project or feature. Your analysis and improvements must be based solely on this document.
</context>

<task>
Your task is to meticulously analyze and rewrite the provided PRD. Your rewritten version must incorporate the following improvements:

1.  **Clarity and Precision:**
    - Eliminate all ambiguity, jargon, and vague language.
    - Correct any grammatical errors or awkward phrasing.
    - Ensure every sentence is precise and easily understood by engineers.

2.  **Logical Structure:**
    - Organize the entire document using clear and consistent Markdown formatting.
    - Use headings, subheadings, lists, and tables to create a scannable and logical hierarchy.

3.  **Completeness and Gap Analysis:**
    - If appropriate, add standard sections like "Assumptions," "Out of Scope," or "Success Metrics" if they are missing but clearly implied or necessary.

4.  **Actionability:**
    - Reframe all requirements into clear, verifiable, and testable statements. The team should know exactly what "done" looks like for each item.

5.  **Contextual Awareness:**
    - If the PRD appears to describe a brand new project (e.g., it mentions initial setup, repository creation, licensing), ensure these foundational steps are explicitly listed as required tasks.
    - If the PRD describes adding features to an existing project, focus only on refining the new requirements and integrating them logically with the implied existing system.
</task>

<rules>
- **Preserve Core Intent:** You MUST preserve the original intent and all core requirements of the document. Do not add new features or remove existing ones. Your role is to refine, not reinvent.
- **Markdown Only:** Your entire output must be the rewritten PRD in Markdown format.
- **No Extraneous Text:** Do NOT include any commentary, conversational text, or explanations before or after the Markdown content. Your response must be ONLY the improved PRD itself.
</rules>

<output_format>
Return ONLY the full, improved Markdown content of the PRD.
</output_format>`

	// User-facing prompts for CLI interaction.

	// GenerateTasksOverwriteConfirmation is shown when generating tasks would overwrite existing ones.
	GenerateTasksOverwriteConfirmation = "Warning: This will DELETE all existing tasks and generate new ones from the file. Proceed?"

	// GenerateTasksImprovementConfirmation asks the user if they want to use an LLM to improve the PRD.
	GenerateTasksImprovementConfirmation = "Do you want to use an LLM to improve the PRD before generating tasks? (This can increase clarity and lead to better tasks)"
)
</file>

<file path="store/interface.go">
package store

import "github.com/josephgoksu/taskwing.app/models"

// TaskStore defines the interface for task persistence.
// It outlines the contract for managing tasks, including CRUD operations,
// initialization, backup, restore, and resource cleanup.
type TaskStore interface {
	// Initialize configures the store with necessary parameters, such as
	// file path, data format, and any other backend-specific settings.
	// It should be called before any other store operations.
	Initialize(config map[string]string) error

	// CreateTask adds a new task to the store.
	// It returns the created task, potentially with store-generated fields
	// (e.g., updated timestamps) or an error if the operation fails.
	CreateTask(task models.Task) (models.Task, error)

	// GetTask retrieves a task by its unique identifier.
	// It returns the found task or an error if the task does not exist
	// or if the retrieval fails.
	GetTask(id string) (models.Task, error)

	// UpdateTask modifies an existing task in the store identified by its ID, applying the given updates.
	// The 'updates' map contains field names to their new values.
	// It returns the updated task or an error if the task is not found
	// or the update operation fails.
	UpdateTask(id string, updates map[string]interface{}) (models.Task, error)

	// DeleteTask removes a task from the store by its unique identifier.
	// It returns an error if the task is not found or the deletion fails.
	DeleteTask(id string) error

	// DeleteTasks removes a list of tasks from the store by their unique identifiers.
	// This is intended for batch operations, like recursive deletes.
	// It should be more performant than calling DeleteTask for each ID.
	// It returns the number of tasks successfully deleted, or an error.
	DeleteTasks(ids []string) (int, error)

	// DeleteAllTasks removes all tasks from the store.
	// This is a destructive operation.
	// It returns an error if the operation fails.
	DeleteAllTasks() error

	// MarkTaskDone marks a task as completed.
	// It sets the task's status to completed and updates relevant timestamps.
	// It returns the updated task or an error if the task is not found or the operation fails.
	MarkTaskDone(id string) (models.Task, error)

	// ListTasks retrieves a list of tasks.
	// It can optionally apply a filter function and a sort function to the tasks.
	// If filterFn is nil, all tasks are returned (subject to sorting).
	// If sortFn is nil, the tasks are returned in their natural order (e.g., as read from the store).
	// It returns a slice of tasks or an error if the operation fails.
	ListTasks(filterFn func(models.Task) bool, sortFn func([]models.Task) []models.Task) ([]models.Task, error)

	// GetTaskWithDescendants retrieves a root task and all of its descendants (subtasks, sub-subtasks, etc.).
	// The returned slice includes the root task itself.
	GetTaskWithDescendants(rootID string) ([]models.Task, error)

	// Backup creates a backup of the current task data to the specified destination path.
	// The format and method of backup are implementation-specific.
	// It returns an error if the backup operation fails.
	Backup(destinationPath string) error

	// Restore replaces the current task data with data from the specified source path.
	// This operation may be destructive to current data.
	// It returns an error if the restoration fails.
	Restore(sourcePath string) error

	// Close releases any resources held by the store, such as file locks or
	// database connections. It should be called when the store is no longer needed.
	Close() error
}
</file>

<file path=".goreleaser.yaml">
# GoReleaser configuration for TaskWing
# Documentation: https://goreleaser.com

# Pre-release hooks
before:
  hooks:
    - go mod tidy
    - go generate ./...
    - go test ./...

# Build configuration
builds:
  - id: taskwing
    binary: taskwing
    main: ./main.go
    env:
      - CGO_ENABLED=0
    goos:
      - linux
      - windows
      - darwin
    goarch:
      - amd64
      - arm64
      - arm
    goarm:
      - "6"
      - "7"
    ignore:
      - goos: windows
        goarch: arm64
      - goos: windows
        goarch: arm
    ldflags:
      - -s -w
      - -X github.com/josephgoksu/taskwing.app/cmd.version={{.Version}}
      - -X github.com/josephgoksu/taskwing.app/cmd.commit={{.Commit}}
      - -X github.com/josephgoksu/taskwing.app/cmd.date={{.Date}}

# Archive configuration
archives:
  - id: taskwing-archive
    name_template: >-
      {{ .ProjectName }}_
      {{- title .Os }}_
      {{- if eq .Arch "amd64" }}x86_64
      {{- else if eq .Arch "386" }}i386
      {{- else }}{{ .Arch }}{{ end }}
      {{- if .Arm }}v{{ .Arm }}{{ end }}
    format_overrides:
      - goos: windows
        format: zip
    files:
      - README.md
      - MCP_GUIDE.md
      - LICENSE
      - .taskwing.example.yaml

# Checksums
checksum:
  name_template: "checksums.txt"

# Changelog generation
changelog:
  sort: asc
  use: github
  filters:
    exclude:
      - "^docs:"
      - "^test:"
      - "^ci:"
      - "^chore:"
      - "merge conflict"
      - Merge pull request
      - Merge remote-tracking branch
      - Merge branch
  groups:
    - title: Features
      regexp: '^.*?feat(\(.+\))??!?:.+$'
      order: 0
    - title: "Bug fixes"
      regexp: '^.*?fix(\(.+\))??!?:.+$'
      order: 1
    - title: "Enhancements"
      regexp: '^.*?(enhancement|refactor)(\(.+\))??!?:.+$'
      order: 2
    - title: Others
      order: 999

# GitHub release configuration
release:
  github:
    owner: josephgoksu
    name: taskwing.app
  draft: false
  prerelease: auto
  mode: replace
  header: |
    ## TaskWing {{.Tag}}

    ### AI-Assisted CLI Task Manager for Developers

    TaskWing helps you manage tasks efficiently with powerful AI integration through the Model Context Protocol (MCP).

    ### Quick Start

    1. Download the appropriate binary for your platform
    2. Extract the archive
    3. Run `./taskwing init` to initialize TaskWing in your project
    4. Start managing tasks with `./taskwing add`

    ### AI Integration

    TaskWing supports MCP for seamless AI tool integration:
    ```bash
    # Start MCP server for AI tools
    ./taskwing mcp
    ```

    See the included MCP_GUIDE.md for detailed AI integration instructions.

  footer: |
    ---

    ### Installation

    **Homebrew (macOS/Linux):**
    ```bash
    # Coming soon
    ```

    **Manual Installation:**
    1. Download the appropriate binary for your platform from the assets below
    2. Extract the archive
    3. Move the binary to a directory in your PATH
    4. Run `taskwing --help` to get started

    **From Source:**
    ```bash
    git clone https://github.com/josephgoksu/taskwing.app
    cd taskwing.app
    go build -o taskwing main.go
    ```

    ---

    Released by [GoReleaser](https://github.com/goreleaser/goreleaser) üöÄ

# Homebrew tap (future)
brews:
  - name: taskwing
    description: "AI-assisted CLI task manager for developers"
    homepage: "https://github.com/josephgoksu/taskwing.app"
    license: "MIT"
    repository:
      owner: josephgoksu
      name: homebrew-tap
    directory: Formula
    commit_author:
      name: goreleaserbot
      email: bot@goreleaser.com
    commit_msg_template: "Brew formula update for {{ .ProjectName }} version {{ .Tag }}"
    skip_upload: true # Enable when homebrew-tap repo is ready

# Docker images (disabled - uncomment when ready)
# dockers:
#   - image_templates:
#     - "josephgoksu/taskwing:latest"
#     - "josephgoksu/taskwing:{{ .Tag }}"
#     - "josephgoksu/taskwing:v{{ .Major }}"
#     dockerfile: Dockerfile
#     build_flag_templates:
#     - "--pull"
#     - "--label=org.opencontainers.image.created={{.Date}}"
#     - "--label=org.opencontainers.image.title={{.ProjectName}}"
#     - "--label=org.opencontainers.image.revision={{.FullCommit}}"
#     - "--label=org.opencontainers.image.version={{.Version}}"
#     skip_push: true

# Snapcraft (disabled - uncomment when ready)
# snapcrafts:
#   - name: taskwing
#     summary: AI-assisted CLI task manager for developers
#     description: |
#       TaskWing is a command-line task management tool designed for developers
#       who want to organize their work efficiently while leveraging AI assistance
#       for better productivity.
#     grade: stable
#     confinement: strict
#     publish: false
#     license: MIT
</file>

<file path="README.md">
# TaskWing

**AI-powered CLI task manager built for developers**

[![Go](https://img.shields.io/badge/Go-1.24+-blue.svg)](https://golang.org)
[![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE)
[![MCP](https://img.shields.io/badge/MCP-Compatible-purple.svg)](https://modelcontextprotocol.io)

TaskWing integrates directly with Claude Code, Cursor, and other AI tools via the Model Context Protocol. Manage tasks from your terminal or let AI handle it for you.

## Why TaskWing?

- **ü§ñ AI-Native**: First CLI tool with full MCP integration for Claude Code/Cursor
- **‚ö° Zero Config**: Works out of the box, stores data locally
- **üîó Smart Dependencies**: Automatic dependency tracking and circular reference prevention
- **üöÄ Developer UX**: Built by developers who hate context switching

## Quick Start

```bash
# Install
go install github.com/josephgoksu/taskwing.app@latest

# Initialize
taskwing init

# Add task
taskwing add --title "Fix auth bug" --priority urgent

# AI Integration
taskwing mcp  # Connect to Claude Code/Cursor
```

## Core Commands

```bash
taskwing add                 # Interactive task creation
taskwing list --status pending --priority high
taskwing update <id>         # Modify existing task
taskwing done <id>           # Mark complete
taskwing delete <id>         # Remove task
```

## AI Integration (MCP)

Connect TaskWing to Claude Code or Cursor for AI-powered task management:

### Claude Code Setup

```json
{
  "mcpServers": {
    "taskwing": {
      "command": "taskwing",
      "args": ["mcp"]
    }
  }
}
```

### AI Capabilities

- **9 Tools**: CRUD operations, bulk actions, advanced search
- **2 Resources**: Live task data, configuration access
- **2 Prompts**: Task generation, breakdown assistance

Let AI create, organize, and manage your tasks while you focus on coding.

## Architecture

```
CLI Commands ‚îÄ‚îÄ‚ñ∫ Task Store ‚îÄ‚îÄ‚ñ∫ Local Files (JSON/YAML/TOML)
     ‚îÇ
     ‚îî‚îÄ‚îÄ‚ñ∫ MCP Server ‚îÄ‚îÄ‚ñ∫ AI Tools (Claude, Cursor, etc.)
```

**Local-first**: Your data stays on your machine. No cloud dependencies.

## Advanced Features

```bash
# Dependency management
taskwing add --dependencies "task1,task2"

# Advanced filtering
taskwing list --search "auth" --sort-by priority

# Bulk operations via AI
# "Mark all urgent auth tasks as completed"
```

## Development

```bash
git clone https://github.com/josephgoksu/taskwing.app
cd taskwing.app
go build -o taskwing main.go
go test ./...
```

## Contributing

We welcome contributions! TaskWing is built with:

- **Go 1.24+** with Cobra CLI framework
- **MCP SDK** for AI integration
- **Local file storage** with integrity checks

See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

## License

MIT License - see [LICENSE](LICENSE) file.

---

**Built for the terminal. Powered by AI. Made for developers.** üöÄ
</file>

<file path="cmd/delete.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"fmt"

	"github.com/josephgoksu/taskwing.app/store"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
)

var (
	recursive bool
)

// deleteCmd represents the delete command
var deleteCmd = &cobra.Command{
	Use:   "delete [task_id]",
	Short: "Delete a task",
	Long:  `Delete a task by its ID. If no ID is provided, an interactive list is shown. A confirmation prompt is always displayed before deletion.`,
	Args:  cobra.MaximumNArgs(1), // Allow 0 or 1 argument
	Run: func(cmd *cobra.Command, args []string) {
		recursive, _ = cmd.Flags().GetBool("recursive")

		taskStore, err := GetStore()
		if err != nil {
			HandleError("Error getting task store", err)
		}
		defer taskStore.Close()

		var taskIDToDelete string

		if len(args) > 0 {
			taskIDToDelete = args[0]
			// Minimal validation, store will confirm existence.
		} else {
			selectedTask, err := selectTaskInteractive(taskStore, nil, "Select task to delete")
			if err != nil {
				if err == promptui.ErrInterrupt {
					fmt.Println("Deletion cancelled.")
					return
				}
				if err == ErrNoTasksFound {
					fmt.Println("No tasks available to delete.")
					return
				}
				HandleError("Error: Could not select a task.", err)
			}
			taskIDToDelete = selectedTask.ID
		}

		if recursive {
			handleRecursiveDelete(taskStore, taskIDToDelete)
		} else {
			handleSingleDelete(taskStore, taskIDToDelete)
		}
	},
}

func handleSingleDelete(taskStore store.TaskStore, taskID string) {
	// Get task details for a better confirmation message.
	task, err := taskStore.GetTask(taskID)
	if err != nil {
		HandleError(fmt.Sprintf("Error: Could not find task with ID '%s'.", taskID), err)
	}

	confirmPrompt := promptui.Prompt{
		Label:     fmt.Sprintf("Are you sure you want to delete task '%s' (ID: %s)?", task.Title, taskID),
		IsConfirm: true,
	}
	_, err = confirmPrompt.Run()
	if err != nil {
		if err == promptui.ErrAbort {
			fmt.Println("Deletion cancelled.")
			return
		}
		HandleError("Error: Could not get confirmation for deletion.", err)
	}

	err = taskStore.DeleteTask(taskID)
	if err != nil {
		HandleError(fmt.Sprintf("Error: Failed to delete task '%s'.", task.Title), err)
	}

	fmt.Printf("Task '%s' (ID: %s) deleted successfully.\n", task.Title, taskID)
}

func handleRecursiveDelete(taskStore store.TaskStore, rootTaskID string) {
	tasksToDelete, err := taskStore.GetTaskWithDescendants(rootTaskID)
	if err != nil {
		HandleError(fmt.Sprintf("Error: Could not find task with ID '%s' to begin recursive delete.", rootTaskID), err)
	}

	if len(tasksToDelete) <= 1 {
		// If it's just one task, there are no descendants, so treat as a single delete.
		fmt.Println("No subtasks found. Proceeding with a single task delete.")
		handleSingleDelete(taskStore, rootTaskID)
		return
	}

	fmt.Printf("You are about to recursively delete the following %d tasks:\n", len(tasksToDelete))
	for _, t := range tasksToDelete {
		// Highlight the root of the deletion
		if t.ID == rootTaskID {
			fmt.Printf("- %s (ID: %s) [ROOT]\n", t.Title, t.ID)
		} else {
			fmt.Printf("- %s (ID: %s)\n", t.Title, t.ID)
		}
	}

	confirmPrompt := promptui.Prompt{
		Label:     "This action is irreversible. Are you sure you want to continue?",
		IsConfirm: true,
	}
	_, err = confirmPrompt.Run()
	if err != nil {
		if err == promptui.ErrAbort {
			fmt.Println("Recursive deletion cancelled.")
			return
		}
		HandleError("Error: Could not get confirmation for recursive deletion.", err)
	}

	idsToDelete := make([]string, len(tasksToDelete))
	for i, t := range tasksToDelete {
		idsToDelete[i] = t.ID
	}

	deletedCount, err := taskStore.DeleteTasks(idsToDelete)
	if err != nil {
		HandleError("Error: Failed to perform the recursive delete operation.", err)
	}

	fmt.Printf("Successfully deleted %d tasks.\n", deletedCount)
}

func init() {
	rootCmd.AddCommand(deleteCmd)
	deleteCmd.Flags().BoolP("recursive", "r", false, "Recursively delete the task and all its subtasks")

	// Here you will define your flags and configuration settings.

	// Cobra supports Persistent Flags which will work for this command
	// and all subcommands, e.g.:
	// deleteCmd.PersistentFlags().String("foo", "", "A help for foo")

	// Cobra supports local flags which will only run when this command
	// is called directly, e.g.:
	// deleteCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
}
</file>

<file path="cmd/done.go">
package cmd

import (
	"fmt"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
)

// doneCmd represents the done command
var doneCmd = &cobra.Command{
	Use:   "done [task_id]",
	Short: "Mark a task as done",
	Long:  `Mark a task as completed. If task_id is provided, it attempts to mark that task directly. Otherwise, it presents an interactive list to choose a task.`,
	Args:  cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		taskStore, err := GetStore()
		if err != nil {
			HandleError("Error: Could not initialize the task store.", err)
		}
		defer taskStore.Close()

		var taskToMarkDone models.Task

		if len(args) > 0 {
			taskID := args[0]
			taskToMarkDone, err = taskStore.GetTask(taskID)
			if err != nil {
				HandleError(fmt.Sprintf("Error: Could not find task with ID '%s'.", taskID), err)
			}
		} else {
			// Filter for tasks that are not yet completed
			notDoneFilter := func(t models.Task) bool {
				return t.Status != models.StatusCompleted
			}
			taskToMarkDone, err = selectTaskInteractive(taskStore, notDoneFilter, "Select task to mark as done")
			if err != nil {
				if err == promptui.ErrInterrupt {
					fmt.Println("Operation cancelled.")
					return
				}
				if err == ErrNoTasksFound {
					fmt.Println("No active tasks available to mark as done.")
					return
				}
				HandleError("Error: Could not select a task.", err)
			}
		}

		if taskToMarkDone.Status == models.StatusCompleted {
			fmt.Printf("Task '%s' (ID: %s) is already completed.\n", taskToMarkDone.Title, taskToMarkDone.ID)
			return
		}

		updatedTask, err := taskStore.MarkTaskDone(taskToMarkDone.ID)
		if err != nil {
			HandleError(fmt.Sprintf("Error: Failed to mark task '%s' as done.", taskToMarkDone.Title), err)
		}

		fmt.Printf("Task '%s' (ID: %s) marked as done successfully!\n", updatedTask.Title, updatedTask.ID)
	},
}

func init() {
	rootCmd.AddCommand(doneCmd)
}
</file>

<file path="cmd/update.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"fmt"
	"os"
	"strings"

	"github.com/josephgoksu/taskwing.app/models"
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
)

// updateCmd represents the update command
var updateCmd = &cobra.Command{
	Use:   "update [task_id]",
	Short: "Update an existing task",
	Long:  `Update an existing task. If task_id is provided, it attempts to update that task directly. Otherwise, it presents an interactive list to choose a task. Allows updating title, description, priority, status, tags, and dependencies.`,
	Args:  cobra.MaximumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		taskStore, err := GetStore()
		if err != nil {
			HandleError("Error: Could not initialize the task store.", err)
		}
		defer taskStore.Close()

		var taskToUpdate models.Task

		if len(args) > 0 {
			taskID := args[0]
			taskToUpdate, err = taskStore.GetTask(taskID)
			if err != nil {
				HandleError(fmt.Sprintf("Error: Could not find task with ID '%s'.", taskID), err)
			}
		} else {
			taskToUpdate, err = selectTaskInteractive(taskStore, nil, "Select task to update")
			if err != nil {
				if err == promptui.ErrInterrupt {
					fmt.Println("Update cancelled.")
					return
				}
				if err == ErrNoTasksFound {
					fmt.Println("No tasks available to update.")
					return
				}
				HandleError("Error: Could not select a task for updating.", err)
			}
		}

		fmt.Printf("Updating task: %s (ID: %s)\n", taskToUpdate.Title, taskToUpdate.ID)
		updates := make(map[string]interface{})
		interactive := true

		if cmd.Flags().Changed("title") {
			newTitle, _ := cmd.Flags().GetString("title")
			updates["title"] = newTitle
			interactive = false
		}
		if cmd.Flags().Changed("description") {
			newDesc, _ := cmd.Flags().GetString("description")
			updates["description"] = newDesc
			interactive = false
		}
		if cmd.Flags().Changed("priority") {
			newPrio, _ := cmd.Flags().GetString("priority")
			updates["priority"] = newPrio
			interactive = false
		}
		if cmd.Flags().Changed("status") {
			newStatus, _ := cmd.Flags().GetString("status")
			updates["status"] = newStatus
			interactive = false
		}
		if cmd.Flags().Changed("parentID") {
			newParentID, _ := cmd.Flags().GetString("parentID")
			if strings.ToLower(newParentID) == "none" || newParentID == "" {
				updates["parentId"] = nil
			} else {
				updates["parentId"] = newParentID
			}
			interactive = false
		}
		if cmd.Flags().Changed("dependencies") {
			newDeps, _ := cmd.Flags().GetString("dependencies")
			if strings.ToLower(newDeps) == "none" || strings.TrimSpace(newDeps) == "" {
				updates["dependencies"] = []string{}
			} else {
				updates["dependencies"] = strings.Split(strings.ReplaceAll(newDeps, " ", ""), ",")
			}
			interactive = false
		}

		if !interactive {
			if len(updates) == 0 {
				fmt.Println("No update flags provided. Use flags like --title, --description, etc. to update.")
				return
			}
		} else {
			// Fallback to original interactive prompts if no flags were used
			// Prompt for Title (existing)
			titlePrompt := promptui.Prompt{
				Label:   fmt.Sprintf("New Title (current: %s, press Enter to keep)", taskToUpdate.Title),
				Default: taskToUpdate.Title,
				Validate: func(input string) error {
					if len(input) < 3 && input != taskToUpdate.Title {
						return fmt.Errorf("title must be at least 3 characters long")
					}
					return nil
				},
			}
			newTitle, err := titlePrompt.Run()
			if err != nil {
				if err == promptui.ErrInterrupt {
					fmt.Println("Update cancelled.")
					os.Exit(0)
				}
				HandleError("Error: Failed to read new title.", err)
			} else if newTitle != taskToUpdate.Title {
				updates["title"] = newTitle
			}

			// Prompt for Description (existing)
			descPrompt := promptui.Prompt{
				Label:   fmt.Sprintf("New Description (current: %s, press Enter to keep)", taskToUpdate.Description),
				Default: taskToUpdate.Description,
			}
			newDesc, err := descPrompt.Run()
			if err != nil && err != promptui.ErrInterrupt {
				HandleError("Error: Failed to read new description.", err)
			} else if newDesc != taskToUpdate.Description {
				updates["description"] = newDesc
			}

			// Prompt for Priority (existing)
			currentPriorityIndex := 0
			priorityItems := []models.TaskPriority{models.PriorityLow, models.PriorityMedium, models.PriorityHigh, models.PriorityUrgent}
			for i, p := range priorityItems {
				if p == taskToUpdate.Priority {
					currentPriorityIndex = i
					break
				}
			}
			prioSelect := promptui.Select{
				Label:     fmt.Sprintf("New Priority (current: %s)", taskToUpdate.Priority),
				Items:     priorityItems,
				CursorPos: currentPriorityIndex,
			}
			_, newPriorityStr, err := prioSelect.Run()
			if err != nil {
				if err == promptui.ErrInterrupt {
					fmt.Println("Update cancelled.")
					os.Exit(0)
				}
				HandleError("Error: Could not select a new priority.", err)
			} else if models.TaskPriority(newPriorityStr) != taskToUpdate.Priority {
				updates["priority"] = newPriorityStr
			}

			// Prompt for Status (existing)
			currentStatusIndex := 0
			statusItems := []models.TaskStatus{models.StatusPending, models.StatusInProgress, models.StatusOnHold, models.StatusBlocked, models.StatusNeedsReview, models.StatusCompleted, models.StatusCancelled}
			for i, s := range statusItems {
				if s == taskToUpdate.Status {
					currentStatusIndex = i
					break
				}
			}
			statusSelect := promptui.Select{
				Label:     fmt.Sprintf("New Status (current: %s)", taskToUpdate.Status),
				Items:     statusItems,
				CursorPos: currentStatusIndex,
			}
			_, newStatusStr, err := statusSelect.Run()
			if err != nil {
				if err == promptui.ErrInterrupt {
					fmt.Println("Update cancelled.")
					os.Exit(0)
				}
				HandleError("Error: Could not select a new status.", err)
			} else if models.TaskStatus(newStatusStr) != taskToUpdate.Status {
				updates["status"] = newStatusStr
			}

			// Prompt for Managing Parent Task
			manageParentPrompt := promptui.Select{
				Label:     "Manage Parent Task?",
				Items:     []string{"Yes", "No"},
				CursorPos: 1, // Default to No
			}
			_, manageParentChoice, err := manageParentPrompt.Run()
			if err != nil && err != promptui.ErrInterrupt {
				HandleError("Error: Could not read parent management choice.", err)
			}

			if err == nil && manageParentChoice == "Yes" {
				currentParentIDStr := "none"
				if taskToUpdate.ParentID != nil && *taskToUpdate.ParentID != "" {
					currentParentIDStr = *taskToUpdate.ParentID
				}
				parentIDPrompt := promptui.Prompt{
					Label:   fmt.Sprintf("New Parent Task ID (current: %s, leave empty or 'none' to clear, Enter to keep current)", currentParentIDStr),
					Default: currentParentIDStr, // Allows user to press Enter to keep current
					// No complex validation here, store will validate existence and self-parenting
				}
				newParentIDStr, err := parentIDPrompt.Run()
				if err != nil && err != promptui.ErrInterrupt {
					HandleError("Error: Could not read new parent ID.", err)
				} else if err == nil && newParentIDStr != currentParentIDStr {
					trimmedNewParentID := strings.TrimSpace(newParentIDStr)
					if strings.ToLower(trimmedNewParentID) == "none" || trimmedNewParentID == "" {
						updates["parentId"] = nil // Signal to clear parent
					} else {
						updates["parentId"] = trimmedNewParentID
					}
				}
			}

			// Prompt for Managing Dependencies (existing)
			manageDepsPrompt := promptui.Select{
				Label:     "Manage Dependencies?",
				Items:     []string{"Yes", "No"},
				CursorPos: 1,
			}
			_, manageDepsChoice, err := manageDepsPrompt.Run()
			if err != nil && err != promptui.ErrInterrupt {
				HandleError("Error: Could not read dependency management choice.", err)
			}

			if err == nil && manageDepsChoice == "Yes" {
				currentDepsStr := strings.Join(taskToUpdate.Dependencies, ", ")
				depsPrompt := promptui.Prompt{
					Label:   fmt.Sprintf("New Dependencies (comma-separated IDs, current: [%s], Enter to keep, 'none' to clear)", currentDepsStr),
					Default: currentDepsStr,
				}
				newDepsStr, err := depsPrompt.Run()
				if err != nil && err != promptui.ErrInterrupt {
					HandleError("Error: Could not read new dependencies.", err)
				} else if err == nil && newDepsStr != currentDepsStr {
					if strings.ToLower(newDepsStr) == "none" || strings.TrimSpace(newDepsStr) == "" {
						updates["dependencies"] = []string{}
					} else {
						updates["dependencies"] = strings.Split(strings.ReplaceAll(newDepsStr, " ", ""), ",")
					}
				}
			}
		}

		if len(updates) == 0 {
			fmt.Println("No changes detected. Update cancelled.")
			return
		}

		updatedTask, err := taskStore.UpdateTask(taskToUpdate.ID, updates)
		if err != nil {
			HandleError(fmt.Sprintf("Error: Could not update task '%s'.", taskToUpdate.Title), err)
		}

		fmt.Printf("Task %s updated successfully! ID: %s\n", updatedTask.Title, updatedTask.ID)
		if _, ok := updates["parentId"]; ok {
			if updatedTask.ParentID != nil && *updatedTask.ParentID != "" {
				fmt.Printf("Updated Parent Task ID: %s\n", *updatedTask.ParentID)
			} else {
				fmt.Println("Parent task association has been removed.")
			}
		}
		if _, ok := updates["dependencies"]; ok {
			fmt.Printf("Updated Dependencies: %v\n", updatedTask.Dependencies)
		}
	},
}

func init() {
	rootCmd.AddCommand(updateCmd)
	updateCmd.Flags().String("title", "", "New title for the task")
	updateCmd.Flags().String("description", "", "New description for the task")
	updateCmd.Flags().String("priority", "", "New priority for the task (low, medium, high, urgent)")
	updateCmd.Flags().String("status", "", "New status for the task (e.g., pending, in-progress)")
	updateCmd.Flags().String("parentID", "", "New parent task ID. Use 'none' to remove parent.")
	updateCmd.Flags().String("dependencies", "", "New comma-separated list of dependency IDs. Use 'none' to clear.")
}
</file>

<file path="llm/openai.go">
package llm

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// OpenAIProvider implements the Provider interface for OpenAI LLMs.
type OpenAIProvider struct {
	apiKey string
	// Potentially add http.Client for custom timeouts, etc.
}

// NewOpenAIProvider creates a new OpenAIProvider.
func NewOpenAIProvider(apiKey string) *OpenAIProvider {
	return &OpenAIProvider{apiKey: apiKey}
}

// OpenAIRequestPayload defines the structure for the OpenAI API request.
type OpenAIRequestPayload struct {
	Model               string                `json:"model"`
	Messages            []OpenAIMessage       `json:"messages"`
	Temperature         float64               `json:"temperature,omitempty"`
	MaxTokens           int                   `json:"max_tokens,omitempty"`
	ResponseFormat      *OpenAIResponseFormat `json:"response_format,omitempty"`
}

// OpenAIResponseFormat specifies the output format for OpenAI (e.g., JSON object).
type OpenAIResponseFormat struct {
	Type string `json:"type"` // e.g., "json_object"
}

// OpenAIMessage defines a message in the conversation for OpenAI.
type OpenAIMessage struct {
	Role    string `json:"role"` // "system", "user", or "assistant"
	Content string `json:"content"`
}

// OpenAIResponsePayload defines the structure for the OpenAI API response.
type OpenAIResponsePayload struct {
	ID      string         `json:"id"`
	Object  string         `json:"object"`
	Created int64          `json:"created"`
	Model   string         `json:"model"`
	Choices []OpenAIChoice `json:"choices"`
	Usage   OpenAIUsage    `json:"usage"`
}

// OpenAIChoice defines a choice in the OpenAI response.
type OpenAIChoice struct {
	Index        int           `json:"index"`
	Message      OpenAIMessage `json:"message"`
	FinishReason string        `json:"finish_reason"`
}

// OpenAIUsage defines token usage statistics from OpenAI.
type OpenAIUsage struct {
	PromptTokens     int `json:"prompt_tokens"`
	CompletionTokens int `json:"completion_tokens"`
	TotalTokens      int `json:"total_tokens"`
}

// OpenAITaskResponseWrapper is used to unmarshal the JSON object returned by OpenAI
// when response_format is json_object and the prompt requests a list of tasks.
type OpenAITaskResponseWrapper struct {
	Tasks []TaskOutput `json:"tasks"`
}

// openAIEstimationData is used to unmarshal the JSON object returned by OpenAI
// for the estimation call.
type openAIEstimationData struct {
	EstimatedTaskCount  int    `json:"estimatedTaskCount"`
	EstimatedComplexity string `json:"estimatedComplexity"` // e.g., "low", "medium", "high"
}

const openAIAPIURL = "https://api.openai.com/v1/chat/completions"

// GenerateTasks for OpenAIProvider.
// TODO: Implement the actual API call and error handling.
func (p *OpenAIProvider) GenerateTasks(ctx context.Context, systemPrompt, prdContent string, modelName string, apiKey string, projectID string, maxTokens int, temperature float64) ([]TaskOutput, error) {
	if apiKey == "" {
		apiKey = p.apiKey // Use provider's key if per-call key is not given
	}
	if apiKey == "" {
		return nil, fmt.Errorf("OpenAI API key is not set")
	}

	userMessage := fmt.Sprintf("PRD Content:\n---\n%s\n---", prdContent)

	requestPayload := OpenAIRequestPayload{
		Model: modelName,
		Messages: []OpenAIMessage{
			{Role: "system", Content: systemPrompt},
			{Role: "user", Content: userMessage},
		},
		ResponseFormat: &OpenAIResponseFormat{Type: "json_object"},
	}

	// Use standard parameters for all models
	requestPayload.MaxTokens = maxTokens
	requestPayload.Temperature = temperature

	payloadBytes, err := json.Marshal(requestPayload)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal OpenAI request payload: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", openAIAPIURL, bytes.NewBuffer(payloadBytes))
	if err != nil {
		return nil, fmt.Errorf("failed to create OpenAI request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 90 * time.Second} // Increased timeout
	resp, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to send request to OpenAI: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		// Read the body for more detailed error information
		errorBodyBytes, readErr := io.ReadAll(resp.Body)
		if readErr != nil {
			// If reading the body fails, return the original status error
			return nil, fmt.Errorf("OpenAI API request failed with status %s (and failed to read error body: %v)", resp.Status, readErr)
		}
		// Return the status error along with the body content
		return nil, fmt.Errorf("OpenAI API request failed with status %s: %s", resp.Status, string(errorBodyBytes))
	}

	var responsePayload OpenAIResponsePayload
	if err := json.NewDecoder(resp.Body).Decode(&responsePayload); err != nil {
		return nil, fmt.Errorf("failed to decode OpenAI response: %w", err)
	}

	if len(responsePayload.Choices) == 0 {
		// It's good practice to log the full response if choices are empty unexpectedly.
		fullResponseBytes, _ := json.Marshal(responsePayload) // Best effort marshal
		fmt.Printf("OpenAI response had no choices. Full response: %s\n", string(fullResponseBytes))
		return nil, fmt.Errorf("OpenAI response contained no choices")
	}

	// Log the first choice and usage for debugging before accessing its content.
	fmt.Printf("DEBUG OpenAI Response - First Choice: %+v\n", responsePayload.Choices[0])
	fmt.Printf("DEBUG OpenAI Response - Usage: %+v\n", responsePayload.Usage)

	content := responsePayload.Choices[0].Message.Content
	// Also log the raw content string that will be unmarshalled
	fmt.Printf("DEBUG OpenAI Raw Content to Unmarshal: [%s]\n", content)

	var responseWrapper OpenAITaskResponseWrapper
	if err := json.Unmarshal([]byte(content), &responseWrapper); err != nil {
		// The error message already includes the content, but explicit logging before erroring can be useful.
		// fmt.Printf("Problematic OpenAI content before error: [%s]\n", content) // This would be redundant given the error format below
		return nil, fmt.Errorf("failed to unmarshal tasks JSON from OpenAI response content: %w. Content was: [%s]", err, content)
	}

	return responseWrapper.Tasks, nil
	// return nil, fmt.Errorf("OpenAI GenerateTasks not yet fully implemented")
}

// EstimateTaskParameters for OpenAIProvider.
func (p *OpenAIProvider) EstimateTaskParameters(ctx context.Context, systemPrompt, prdContent string, modelName string, apiKey string, projectID string, maxTokensForEstimation int, temperatureForEstimation float64) (EstimationOutput, error) {
	if apiKey == "" {
		apiKey = p.apiKey // Use provider's key if per-call key is not given
	}
	if apiKey == "" {
		return EstimationOutput{}, fmt.Errorf("OpenAI API key is not set for estimation")
	}

	userMessage := fmt.Sprintf("PRD Content:\n---\n%s\n---", prdContent)

	requestPayload := OpenAIRequestPayload{
		Model: modelName,
		Messages: []OpenAIMessage{
			{Role: "system", Content: systemPrompt},
			{Role: "user", Content: userMessage},
		},
		ResponseFormat: &OpenAIResponseFormat{Type: "json_object"},
	}

	// Use standard parameters for all models
	requestPayload.MaxTokens = maxTokensForEstimation
	requestPayload.Temperature = temperatureForEstimation

	payloadBytes, err := json.Marshal(requestPayload)
	if err != nil {
		return EstimationOutput{}, fmt.Errorf("failed to marshal OpenAI estimation request payload: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", openAIAPIURL, bytes.NewBuffer(payloadBytes))
	if err != nil {
		return EstimationOutput{}, fmt.Errorf("failed to create OpenAI estimation request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 60 * time.Second} // Shorter timeout for estimation
	resp, err := client.Do(req)
	if err != nil {
		return EstimationOutput{}, fmt.Errorf("failed to send estimation request to OpenAI: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		errorBodyBytes, readErr := io.ReadAll(resp.Body)
		if readErr != nil {
			return EstimationOutput{}, fmt.Errorf("OpenAI estimation API request failed with status %s (and failed to read error body: %v)", resp.Status, readErr)
		}
		return EstimationOutput{}, fmt.Errorf("OpenAI estimation API request failed with status %s: %s", resp.Status, string(errorBodyBytes))
	}

	var responsePayload OpenAIResponsePayload
	if err := json.NewDecoder(resp.Body).Decode(&responsePayload); err != nil {
		return EstimationOutput{}, fmt.Errorf("failed to decode OpenAI estimation response: %w", err)
	}

	if len(responsePayload.Choices) == 0 {
		fullResponseBytes, _ := json.Marshal(responsePayload)
		fmt.Printf("OpenAI estimation response had no choices. Full response: %s\n", string(fullResponseBytes))
		return EstimationOutput{}, fmt.Errorf("OpenAI estimation response contained no choices")
	}

	fmt.Printf("DEBUG OpenAI Estimation Response - First Choice: %+v\n", responsePayload.Choices[0])
	fmt.Printf("DEBUG OpenAI Estimation Response - Usage: %+v\n", responsePayload.Usage)

	content := responsePayload.Choices[0].Message.Content
	fmt.Printf("DEBUG OpenAI Estimation Raw Content to Unmarshal: [%s]\n", content)

	var estimationData openAIEstimationData
	if err := json.Unmarshal([]byte(content), &estimationData); err != nil {
		return EstimationOutput{}, fmt.Errorf("failed to unmarshal estimation JSON from OpenAI response content: %w. Content was: [%s]", err, content)
	}

	return EstimationOutput{
		EstimatedTaskCount:  estimationData.EstimatedTaskCount,
		EstimatedComplexity: estimationData.EstimatedComplexity,
	}, nil
}

// ImprovePRD sends the PRD content to OpenAI with a prompt to refine and improve it.
func (p *OpenAIProvider) ImprovePRD(ctx context.Context, systemPrompt, prdContent string, modelName string, apiKey string, projectID string, maxTokensForImprovement int, temperatureForImprovement float64) (string, error) {
	if apiKey == "" {
		apiKey = p.apiKey
	}
	if apiKey == "" {
		return "", fmt.Errorf("OpenAI API key is not set for PRD improvement")
	}

	userMessage := fmt.Sprintf("Please improve the following PRD content:\n---\n%s\n---", prdContent)

	requestPayload := OpenAIRequestPayload{
		Model: modelName, // GPT-5 Mini is the default model
		Messages: []OpenAIMessage{
			{Role: "system", Content: systemPrompt},
			{Role: "user", Content: userMessage},
		},
	}

	// Use standard parameters for all models
	requestPayload.MaxTokens = maxTokensForImprovement
	requestPayload.Temperature = temperatureForImprovement

	payloadBytes, err := json.Marshal(requestPayload)
	if err != nil {
		return "", fmt.Errorf("failed to marshal OpenAI PRD improvement request payload: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", openAIAPIURL, bytes.NewBuffer(payloadBytes))
	if err != nil {
		return "", fmt.Errorf("failed to create OpenAI PRD improvement request: %w", err)
	}
	req.Header.Set("Authorization", "Bearer "+apiKey)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 120 * time.Second} // Longer timeout for potentially large rewrites
	resp, err := client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to send PRD improvement request to OpenAI: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		errorBodyBytes, readErr := io.ReadAll(resp.Body)
		if readErr != nil {
			return "", fmt.Errorf("OpenAI PRD improvement API request failed with status %s (and failed to read error body: %v)", resp.Status, readErr)
		}
		return "", fmt.Errorf("OpenAI PRD improvement API request failed with status %s: %s", resp.Status, string(errorBodyBytes))
	}

	var responsePayload OpenAIResponsePayload
	if err := json.NewDecoder(resp.Body).Decode(&responsePayload); err != nil {
		return "", fmt.Errorf("failed to decode OpenAI PRD improvement response: %w", err)
	}

	if len(responsePayload.Choices) == 0 {
		return "", fmt.Errorf("OpenAI PRD improvement response contained no choices")
	}

	improvedContent := responsePayload.Choices[0].Message.Content
	return strings.TrimSpace(improvedContent), nil
}
</file>

<file path="store/file_store.go">
package store

import (
	"bytes"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"reflect"
	"slices"
	"strings"
	"time"

	"github.com/BurntSushi/toml"
	"github.com/gofrs/flock"
	"github.com/google/uuid"
	"github.com/josephgoksu/taskwing.app/models"
	"gopkg.in/yaml.v3"
)

const (
	defaultDataFile   = "tasks.json" // Default filename if only format implies extension
	dataFileKey       = "dataFile"
	dataFileFormatKey = "dataFileFormat"
	defaultDataFormat = "json"
	formatJSON        = "json"
	formatYAML        = "yaml"
	formatTOML        = "toml"
	checksumSuffix    = ".checksum"
)

// FileTaskStore implements the TaskStore interface using a file backend.
// It supports JSON, YAML, and TOML formats and uses file-level locking.
type FileTaskStore struct {
	filePath string
	tasks    map[string]models.Task
	// mu       sync.RWMutex // Replaced by flock
	flk    *flock.Flock
	format string // Stores the data format: "json", "yaml", or "toml"
}

// NewFileTaskStore creates a new instance of FileTaskStore.
// It does not initialize the store; Initialize must be called separately.
func NewFileTaskStore() *FileTaskStore {
	return &FileTaskStore{
		tasks: make(map[string]models.Task),
	}
}

// Initialize configures the FileTaskStore.
// It expects a 'dataFile' key in the config map specifying the path to the data file.
// If not provided, it defaults to 'tasks.json' in the current working directory.
// It loads existing tasks from the file if it exists and establishes a file lock.
func (s *FileTaskStore) Initialize(config map[string]string) error {
	if val, ok := config[dataFileKey]; ok && val != "" {
		s.filePath = val
	} else {
		// If filePath is not given, try to infer from format or use a default name with default format
		s.filePath = defaultDataFile // This might need adjustment based on format below
	}

	if val, ok := config[dataFileFormatKey]; ok && val != "" {
		formatLower := strings.ToLower(val)
		switch formatLower {
		case formatJSON, formatYAML, formatTOML:
			s.format = formatLower
		default:
			return fmt.Errorf("unsupported dataFileFormat: %s. Supported formats are json, yaml, toml", val)
		}
	} else {
		s.format = defaultDataFormat
	}

	// If filePath was the default and format is not JSON, adjust default filePath extension
	// This is a simple heuristic. Users providing a full filePath are responsible for its extension.
	if s.filePath == defaultDataFile && s.format != formatJSON {
		ext := filepath.Ext(s.filePath)
		s.filePath = strings.TrimSuffix(s.filePath, ext) + "." + s.format
	}

	// Ensure the directory for the file path exists
	dir := filepath.Dir(s.filePath)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %w", dir, err)
		}
	}

	// Initialize flock for the data file. The lock file will be s.filePath + ".lock"
	// or on some systems, the lock is directly on the file.
	s.flk = flock.New(s.filePath) // flock uses the file path itself for locking

	// Attempt to acquire an exclusive lock for initialization (e.g. creating file if not exists)
	// then downgrade or release based on operation. For initial load, a shared lock is enough.
	locked, err := s.flk.TryLock() // Try to get an exclusive lock for initial setup/check
	if err != nil {
		return fmt.Errorf("failed to acquire initial lock for %s: %w", s.filePath, err)
	}
	if !locked {
		// Could wait here or return an error. For now, assume we should get it.
		// This might happen if another process has an exclusive lock.
		// Let's try a blocking lock to ensure initialization completes if the file is momentarily locked.
		if err := s.flk.Lock(); err != nil {
			return fmt.Errorf("failed to acquire blocking initial lock for %s: %w", s.filePath, err)
		}
	}
	defer s.flk.Unlock() // Unlock after initialization sequence

	s.tasks = make(map[string]models.Task) // Reset tasks map
	return s.loadTasksFromFileInternal()   // Use internal version that assumes lock is held
}

// calculateChecksum computes the SHA256 checksum of the given data.
func calculateChecksum(data []byte) string {
	hasher := sha256.New()
	hasher.Write(data) // Write never returns an error
	return hex.EncodeToString(hasher.Sum(nil))
}

// loadTasksFromFileInternal reads tasks from the file, verifies checksum, and unmarshals.
func (s *FileTaskStore) loadTasksFromFileInternal() error {
	checksumFilePath := s.filePath + checksumSuffix

	data, err := os.ReadFile(s.filePath)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			s.tasks = make(map[string]models.Task)
			// If data file doesn't exist, checksum file shouldn't either. Clean up if it does.
			_ = os.Remove(checksumFilePath)
			if f, createErr := os.OpenFile(s.filePath, os.O_CREATE|os.O_RDWR, 0644); createErr != nil {
				return fmt.Errorf("failed to create data file %s: %w", s.filePath, createErr)
			} else {
				f.Close()
			}
			// Create an empty checksum file for a new empty data file
			if err := os.WriteFile(checksumFilePath, []byte(calculateChecksum([]byte{})), 0644); err != nil {
				// Non-critical, log or ignore. The next save will attempt to create it.
				fmt.Printf("Warning: could not write initial checksum file %s: %v\n", checksumFilePath, err)
			}
			return nil
		}
		return fmt.Errorf("failed to read data file %s: %w", s.filePath, err)
	}

	// Verify checksum if checksum file exists
	if _, err := os.Stat(checksumFilePath); err == nil {
		expectedChecksumBytes, readErr := os.ReadFile(checksumFilePath)
		if readErr != nil {
			return fmt.Errorf("failed to read checksum file %s: %w. Data file might be corrupt or tampered.", checksumFilePath, readErr)
		}
		expectedChecksum := strings.TrimSpace(string(expectedChecksumBytes))
		actualChecksum := calculateChecksum(data)

		if actualChecksum != expectedChecksum {
			return fmt.Errorf("checksum mismatch for %s. Expected %s, got %s. File is corrupt or tampered.", s.filePath, expectedChecksum, actualChecksum)
		}
	} else if !os.IsNotExist(err) {
		// Some other error trying to stat checksum file (e.g. permission denied)
		return fmt.Errorf("error checking checksum file %s: %w", checksumFilePath, err)
	}
	// If checksum file does not exist, and data file exists (and possibly non-empty),
	// this could be data from before checksums. We'll allow loading it,
	// and the next save will create a checksum file.

	if len(data) == 0 {
		// If data is empty, ensure checksum reflects this or is created.
		currentChecksum := calculateChecksum([]byte{})
		_ = os.WriteFile(checksumFilePath, []byte(currentChecksum), 0644) // best effort
		s.tasks = make(map[string]models.Task)
		return nil
	}

	var taskList models.TaskList
	switch s.format {
	case formatJSON:
		if err := json.Unmarshal(data, &taskList); err != nil {
			return fmt.Errorf("failed to unmarshal JSON from %s (checksum may have passed): %w", s.filePath, err)
		}
	case formatYAML:
		if err := yaml.Unmarshal(data, &taskList); err != nil {
			return fmt.Errorf("failed to unmarshal YAML from %s (checksum may have passed): %w", s.filePath, err)
		}
	case formatTOML:
		if err := toml.Unmarshal(data, &taskList); err != nil {
			return fmt.Errorf("failed to unmarshal TOML from %s (checksum may have passed): %w", s.filePath, err)
		}
	default:
		return fmt.Errorf("unsupported data format for loading: %s", s.format)
	}

	s.tasks = make(map[string]models.Task, len(taskList.Tasks))
	for _, task := range taskList.Tasks {
		s.tasks[task.ID] = task
	}
	return nil
}

// saveTasksToFileInternal writes tasks to file, then writes its checksum.
func (s *FileTaskStore) saveTasksToFileInternal() error {
	taskList := models.TaskList{
		Tasks:      make([]models.Task, 0, len(s.tasks)),
		TotalCount: len(s.tasks),
	}
	for _, task := range s.tasks {
		taskList.Tasks = append(taskList.Tasks, task)
	}

	var marshaledData []byte
	var err error

	switch s.format {
	case formatJSON:
		marshaledData, err = json.MarshalIndent(taskList, "", "  ")
	case formatYAML:
		marshaledData, err = yaml.Marshal(taskList)
	case formatTOML:
		buf := new(bytes.Buffer)
		if encodeErr := toml.NewEncoder(buf).Encode(taskList); encodeErr == nil {
			marshaledData = buf.Bytes()
		} else {
			err = fmt.Errorf("failed to marshal TOML: %w", encodeErr)
		}
	default:
		return fmt.Errorf("unsupported data format for saving: %s", s.format)
	}

	if err != nil {
		return fmt.Errorf("failed to marshal tasks to %s: %w", s.format, err)
	}

	tempFilePath := s.filePath + ".tmp"
	checksumFilePath := s.filePath + checksumSuffix
	tempChecksumFilePath := checksumFilePath + ".tmp"

	defer os.Remove(tempFilePath)
	defer os.Remove(tempChecksumFilePath)

	if err := os.WriteFile(tempFilePath, marshaledData, 0644); err != nil {
		return fmt.Errorf("failed to write to temporary data file %s: %w", tempFilePath, err)
	}

	// Data file written to temp, now calculate its checksum
	actualChecksum := calculateChecksum(marshaledData)
	if err := os.WriteFile(tempChecksumFilePath, []byte(actualChecksum), 0644); err != nil {
		return fmt.Errorf("failed to write to temporary checksum file %s: %w", tempChecksumFilePath, err)
	}

	// Atomically move data file and then checksum file
	if err := os.Rename(tempFilePath, s.filePath); err != nil {
		return fmt.Errorf("failed to rename temporary data file %s to %s: %w", tempFilePath, s.filePath, err)
	}
	// If renaming data file succeeded, then rename checksum file
	if err := os.Rename(tempChecksumFilePath, checksumFilePath); err != nil {
		// This is a problematic state: data file is updated, checksum file is not.
		// Attempt to remove the new data file to revert to a potentially more consistent state (old data, old checksum or no checksum)
		// Or, log prominently and alert. For now, return error and log this potential inconsistency.
		// A more robust solution might try to write the checksum again, or remove the main file if this fails.
		return fmt.Errorf("CRITICAL: data file %s updated, but failed to update checksum file %s from %s: %w. Store may be inconsistent.", s.filePath, checksumFilePath, tempChecksumFilePath, err)
	}

	return nil
}

// generateID creates a new universally unique identifier string.
func generateID() string {
	return uuid.NewString()
}

// addStringToSliceIfMissing adds a string to a slice if it's not already present.
// Returns the new slice.
func addStringToSliceIfMissing(slice []string, item string) []string {
	if !slices.Contains(slice, item) {
		return append(slice, item)
	}
	return slice
}

// removeStringFromSlice removes all occurrences of a string from a slice.
// Returns the new slice.
func removeStringFromSlice(slice []string, item string) []string {
	newSlice := make([]string, 0, len(slice))
	for _, s := range slice {
		if s != item {
			newSlice = append(newSlice, s)
		}
	}
	return newSlice
}

// CreateTask adds a new task to the store.
// It sets the ID, timestamps, and manages relationship consistency.
func (s *FileTaskStore) CreateTask(task models.Task) (models.Task, error) {
	if err := s.flk.Lock(); err != nil {
		return models.Task{}, fmt.Errorf("could not lock file for create: %w", err)
	}
	defer s.flk.Unlock()

	// Reload state from disk to ensure we are working with the latest version
	// in case of concurrent access, though the lock should serialize operations.
	if err := s.loadTasksFromFileInternal(); err != nil {
		return models.Task{}, fmt.Errorf("failed to reload tasks before create: %w", err)
	}

	// If ID is empty, generate one. Otherwise, validate the provided one.
	if task.ID == "" {
		task.ID = generateID()
	} else {
		if _, exists := s.tasks[task.ID]; exists {
			return models.Task{}, fmt.Errorf("task with ID '%s' already exists", task.ID)
		}
	}

	now := time.Now().UTC()
	task.CreatedAt = now
	task.UpdatedAt = now
	task.Dependents = []string{} // Ensure dependents is initialized and empty

	// Validate the task struct before proceeding
	if err := models.ValidateStruct(task); err != nil {
		return models.Task{}, fmt.Errorf("validation failed for new task: %w", err)
	}

	// --- Relationship Management ---

	// 1. Handle Parent-Child relationship
	if task.ParentID != nil && *task.ParentID != "" {
		parentTask, exists := s.tasks[*task.ParentID]
		if !exists {
			return models.Task{}, fmt.Errorf("parent task with ID '%s' not found", *task.ParentID)
		}
		parentTask.SubtaskIDs = addStringToSliceIfMissing(parentTask.SubtaskIDs, task.ID)
		parentTask.UpdatedAt = now
		s.tasks[*task.ParentID] = parentTask
	}

	// 2. Handle Dependencies
	if len(task.Dependencies) > 0 {
		for _, depID := range task.Dependencies {
			if depID == task.ID {
				return models.Task{}, fmt.Errorf("task cannot depend on itself")
			}
			dependencyTask, exists := s.tasks[depID]
			if !exists {
				return models.Task{}, fmt.Errorf("dependency task with ID '%s' not found", depID)
			}
			// Add this new task's ID to the dependent list of the task it depends on.
			dependencyTask.Dependents = addStringToSliceIfMissing(dependencyTask.Dependents, task.ID)
			dependencyTask.UpdatedAt = now
			s.tasks[depID] = dependencyTask
		}
	}

	s.tasks[task.ID] = task

	if err := s.saveTasksToFileInternal(); err != nil {
		// Attempt to revert in-memory changes on save failure.
		// This is best-effort and a transactional approach would be more robust.
		// For now, reloading from the unchanged file is the simplest "rollback".
		_ = s.loadTasksFromFileInternal()
		return models.Task{}, fmt.Errorf("failed to save new task: %w", err)
	}

	return task, nil
}

// GetTask retrieves a task by its unique identifier.
// This function assumes that a read lock (s.flk.RLock()) is already held by the caller if needed for safety with other ops.
// However, for a single Get, an exclusive lock for load might be simpler if tasks aren't kept hot.
// For simplicity and consistency with other ops, using exclusive lock for load.
func (s *FileTaskStore) GetTask(id string) (models.Task, error) {
	if err := s.flk.Lock(); err != nil { // Using exclusive lock to ensure fresh load and safety
		return models.Task{}, fmt.Errorf("failed to acquire lock for GetTask: %w", err)
	}
	defer s.flk.Unlock()

	if err := s.loadTasksFromFileInternal(); err != nil {
		return models.Task{}, fmt.Errorf("failed to load tasks for GetTask: %w", err)
	}

	task, ok := s.tasks[id]
	if !ok {
		return models.Task{}, fmt.Errorf("task with ID %s not found", id)
	}
	return task, nil
}

// UpdateTask modifies an existing task.
// It uses a map of updates and ensures relationship consistency (parents, dependencies).
func (s *FileTaskStore) UpdateTask(id string, updates map[string]interface{}) (models.Task, error) {
	if err := s.flk.Lock(); err != nil {
		return models.Task{}, fmt.Errorf("could not lock file for update: %w", err)
	}
	defer s.flk.Unlock()

	if err := s.loadTasksFromFileInternal(); err != nil {
		return models.Task{}, fmt.Errorf("failed to reload tasks before update: %w", err)
	}

	task, exists := s.tasks[id]
	if !exists {
		return models.Task{}, fmt.Errorf("task with ID '%s' not found", id)
	}
	originalTask := task // Keep a copy for potential rollback

	now := time.Now().UTC()
	task.UpdatedAt = now

	// Apply updates reflectively.
	for key, value := range updates {
		// Handle relationship fields separately.
		if key == "parentId" || key == "dependencies" {
			continue
		}
		// Use reflection to set field value.
		// This is simpler than a large switch but requires careful key matching.
		field := reflect.ValueOf(&task).Elem().FieldByName(strings.Title(key))
		if field.IsValid() && field.CanSet() {
			val := reflect.ValueOf(value)
			// Handle type conversion for fields that need it (e.g., string to custom type)
			if field.Type() != val.Type() {
				if converted, err := convertType(val.Interface(), field.Type()); err == nil {
					val = converted
				} else {
					return models.Task{}, fmt.Errorf("type conversion error for field %s: %w", key, err)
				}
			}
			field.Set(val)
		}
	}

	// Handle parent change
	if newParentID, ok := updates["parentId"]; ok {
		if err := s.updateParentLink(&task, newParentID, now); err != nil {
			return models.Task{}, err
		}
	}

	// Handle dependencies change
	if newDeps, ok := updates["dependencies"]; ok {
		if err := s.updateDependenciesLink(&task, newDeps, now); err != nil {
			return models.Task{}, err
		}
	}

	// Validate the updated task struct.
	if err := models.ValidateStruct(task); err != nil {
		return models.Task{}, fmt.Errorf("validation failed for updated task: %w", err)
	}

	s.tasks[id] = task

	if err := s.saveTasksToFileInternal(); err != nil {
		s.tasks[id] = originalTask // Rollback in-memory change
		// More complex rollback for parent/dependency changes would be needed for full atomicity.
		// For now, this is a best-effort rollback of the primary task.
		return models.Task{}, fmt.Errorf("failed to save updated task: %w", err)
	}

	return task, nil
}

// updateParentLink handles the logic for changing a task's parent.
func (s *FileTaskStore) updateParentLink(task *models.Task, newParentIDValue interface{}, now time.Time) error {
	var newParentID *string
	if newParentIDValue != nil {
		idStr, ok := newParentIDValue.(string)
		if !ok {
			return fmt.Errorf("invalid type for parentId; must be a string or nil")
		}
		newParentID = &idStr
	}

	// Prevent self-parenting
	if newParentID != nil && *newParentID == task.ID {
		return fmt.Errorf("task cannot be its own parent")
	}

	oldParentID := task.ParentID

	// No change, do nothing.
	if (oldParentID == nil && newParentID == nil) || (oldParentID != nil && newParentID != nil && *oldParentID == *newParentID) {
		return nil
	}

	// Remove from old parent's SubtaskIDs
	if oldParentID != nil && *oldParentID != "" {
		if oldParent, ok := s.tasks[*oldParentID]; ok {
			oldParent.SubtaskIDs = removeStringFromSlice(oldParent.SubtaskIDs, task.ID)
			oldParent.UpdatedAt = now
			s.tasks[*oldParentID] = oldParent
		}
	}

	// Add to new parent's SubtaskIDs
	if newParentID != nil && *newParentID != "" {
		if newParent, ok := s.tasks[*newParentID]; ok {
			// Check for circular dependency (new parent cannot be a subtask of the current task)
			if s.isSubtask(newParent, task.ID) {
				return fmt.Errorf("cannot set parent: '%s' is a subtask of '%s'", newParent.Title, task.Title)
			}
			newParent.SubtaskIDs = addStringToSliceIfMissing(newParent.SubtaskIDs, task.ID)
			newParent.UpdatedAt = now
			s.tasks[*newParentID] = newParent
		} else {
			return fmt.Errorf("new parent task with ID '%s' not found", *newParentID)
		}
	}

	task.ParentID = newParentID
	return nil
}

// isSubtask checks if a potential parent task is actually a subtask of the given task.
func (s *FileTaskStore) isSubtask(potentialParent models.Task, originalTaskID string) bool {
	if potentialParent.ParentID == nil {
		return false
	}
	if *potentialParent.ParentID == originalTaskID {
		return true
	}
	// Recurse up the chain
	if grandParent, ok := s.tasks[*potentialParent.ParentID]; ok {
		return s.isSubtask(grandParent, originalTaskID)
	}
	return false
}

// updateDependenciesLink handles the logic for changing a task's dependencies.
func (s *FileTaskStore) updateDependenciesLink(task *models.Task, newDepsValue interface{}, now time.Time) error {
	newDeps, ok := newDepsValue.([]string)
	if !ok {
		return fmt.Errorf("invalid type for dependencies; must be a []string")
	}

	oldDeps := task.Dependencies
	task.Dependencies = newDeps // Set new dependencies on the task struct

	// Determine which dependencies were added and which were removed.
	depsToAdd := []string{}
	depsToRemove := []string{}

	oldDepSet := make(map[string]bool)
	for _, id := range oldDeps {
		oldDepSet[id] = true
	}
	newDepSet := make(map[string]bool)
	for _, id := range newDeps {
		newDepSet[id] = true
	}

	for id := range newDepSet {
		if !oldDepSet[id] {
			depsToAdd = append(depsToAdd, id)
		}
	}
	for id := range oldDepSet {
		if !newDepSet[id] {
			depsToRemove = append(depsToRemove, id)
		}
	}

	// Remove this task from the Dependents list of tasks that are no longer dependencies.
	for _, depID := range depsToRemove {
		if depTask, ok := s.tasks[depID]; ok {
			depTask.Dependents = removeStringFromSlice(depTask.Dependents, task.ID)
			depTask.UpdatedAt = now
			s.tasks[depID] = depTask
		}
	}

	// Add this task to the Dependents list of new dependencies.
	for _, depID := range depsToAdd {
		if depID == task.ID {
			return fmt.Errorf("task cannot depend on itself")
		}
		if depTask, ok := s.tasks[depID]; ok {
			depTask.Dependents = addStringToSliceIfMissing(depTask.Dependents, task.ID)
			depTask.UpdatedAt = now
			s.tasks[depID] = depTask
		} else {
			return fmt.Errorf("new dependency task with ID '%s' not found", depID)
		}
	}

	return nil
}

// convertType attempts to convert an interface value to a target reflect.Type.
// This is a simplified converter for specific types used in Task.
func convertType(value interface{}, targetType reflect.Type) (reflect.Value, error) {
	valueType := reflect.TypeOf(value)
	if valueType == targetType {
		return reflect.ValueOf(value), nil
	}

	// Handle string to custom types like TaskStatus and TaskPriority
	if valueStr, ok := value.(string); ok {
		switch targetType {
		case reflect.TypeOf(models.TaskStatus("")):
			return reflect.ValueOf(models.TaskStatus(valueStr)), nil
		case reflect.TypeOf(models.TaskPriority("")):
			return reflect.ValueOf(models.TaskPriority(valueStr)), nil
		}
	}

	return reflect.Value{}, fmt.Errorf("unsupported type conversion from %v to %v", valueType, targetType)
}

// DeleteTask removes a task from the store by its unique identifier.
// It prevents deletion if other tasks depend on it or if the task itself has subtasks.
// If successful, it also removes itself from the Dependents list of tasks it depended on,
// and from the SubtaskIDs list of its parent task.
func (s *FileTaskStore) DeleteTask(id string) error {
	if err := s.flk.Lock(); err != nil {
		return fmt.Errorf("could not lock file for delete: %w", err)
	}
	defer s.flk.Unlock()

	if err := s.loadTasksFromFileInternal(); err != nil {
		return fmt.Errorf("failed to reload tasks before delete: %w", err)
	}

	taskToDelete, exists := s.tasks[id]
	if !exists {
		return fmt.Errorf("task with ID '%s' not found", id)
	}

	// --- Relationship Management ---
	now := time.Now().UTC()

	// 1. Update parent task if this was a subtask
	if taskToDelete.ParentID != nil && *taskToDelete.ParentID != "" {
		if parentTask, ok := s.tasks[*taskToDelete.ParentID]; ok {
			parentTask.SubtaskIDs = removeStringFromSlice(parentTask.SubtaskIDs, id)
			parentTask.UpdatedAt = now
			s.tasks[*taskToDelete.ParentID] = parentTask
		}
	}

	// 2. Remove this task from the Dependents list of its dependencies
	for _, depID := range taskToDelete.Dependencies {
		if depTask, ok := s.tasks[depID]; ok {
			depTask.Dependents = removeStringFromSlice(depTask.Dependents, id)
			depTask.UpdatedAt = now
			s.tasks[depID] = depTask
		}
	}

	// 3. Handle dependents of the task being deleted. For now, we disallow deletion of tasks that have dependents.
	// A more advanced implementation could offer to re-link dependents or delete them recursively.
	if len(taskToDelete.Dependents) > 0 {
		return fmt.Errorf("cannot delete task '%s': it is a dependency for other tasks (e.g., %s)", taskToDelete.Title, strings.Join(taskToDelete.Dependents, ", "))
	}

	// 4. Handle subtasks of the task being deleted. For now, disallow deletion of tasks with subtasks.
	if len(taskToDelete.SubtaskIDs) > 0 {
		return fmt.Errorf("cannot delete task '%s': it has subtasks. Please delete or re-assign subtasks first.", taskToDelete.Title)
	}

	// Finally, delete the task itself
	delete(s.tasks, id)

	if err := s.saveTasksToFileInternal(); err != nil {
		// Best-effort rollback
		_ = s.loadTasksFromFileInternal()
		return fmt.Errorf("failed to save after deleting task: %w", err)
	}

	return nil
}

// DeleteTasks removes a list of tasks in a single, atomic operation.
// It also cleans up all relationships related to the deleted tasks.
func (s *FileTaskStore) DeleteTasks(ids []string) (int, error) {
	if err := s.flk.Lock(); err != nil {
		return 0, fmt.Errorf("could not lock file for batch delete: %w", err)
	}
	defer s.flk.Unlock()

	if err := s.loadTasksFromFileInternal(); err != nil {
		return 0, fmt.Errorf("failed to reload tasks before batch delete: %w", err)
	}

	deleteSet := make(map[string]bool)
	for _, id := range ids {
		deleteSet[id] = true
	}

	deletedCount := 0
	now := time.Now().UTC()

	// Create a new map for tasks to keep, to avoid modifying while iterating.
	keptTasks := make(map[string]models.Task)
	for id, task := range s.tasks {
		if !deleteSet[id] {
			keptTasks[id] = task
		}
	}

	// Now iterate over the tasks we are keeping and clean up their relationships
	// to any tasks that were deleted.
	for id, task := range keptTasks {
		modified := false

		// Clean up parent link if parent was deleted.
		if task.ParentID != nil && deleteSet[*task.ParentID] {
			task.ParentID = nil
			modified = true
		}

		// Clean up dependencies list.
		newDeps := []string{}
		for _, depID := range task.Dependencies {
			if !deleteSet[depID] {
				newDeps = append(newDeps, depID)
			} else {
				modified = true
			}
		}
		if modified {
			task.Dependencies = newDeps
			task.UpdatedAt = now
			keptTasks[id] = task
		}
	}

	deletedCount = len(s.tasks) - len(keptTasks)
	s.tasks = keptTasks // Replace the old map with the cleaned one.

	if err := s.saveTasksToFileInternal(); err != nil {
		// Rollback is complex here; a simple reload is the safest option.
		_ = s.loadTasksFromFileInternal()
		return 0, fmt.Errorf("failed to save after batch deleting tasks: %w", err)
	}

	return deletedCount, nil
}

// DeleteAllTasks removes all tasks from the store.
// This is a destructive operation that wipes the entire task map.
func (s *FileTaskStore) DeleteAllTasks() error {
	if err := s.flk.Lock(); err != nil {
		return fmt.Errorf("failed to acquire write lock for DeleteAllTasks: %w", err)
	}
	defer s.flk.Unlock()

	// This is a destructive operation. The command layer should have already confirmed with the user.
	// Here we just perform the action by clearing the in-memory map.
	s.tasks = make(map[string]models.Task)

	// Save the now-empty task list to the file, overwriting the previous state.
	if err := s.saveTasksToFileInternal(); err != nil {
		// If saving fails, the file on disk is not touched, but the in-memory store is now empty.
		// Reloading would be necessary to get back to the previous state.
		// The error signals that the operation was not successful.
		return fmt.Errorf("failed to clear data file by saving empty task list: %w", err)
	}
	return nil
}

// MarkTaskDone marks a task as completed.
// Note: This does not currently automatically update statuses of dependent tasks.
func (s *FileTaskStore) MarkTaskDone(id string) (models.Task, error) {
	if err := s.flk.Lock(); err != nil {
		return models.Task{}, fmt.Errorf("failed to acquire write lock for MarkTaskDone: %w", err)
	}
	defer s.flk.Unlock()

	if err := s.loadTasksFromFileInternal(); err != nil {
		return models.Task{}, fmt.Errorf("failed to load tasks before marking done: %w", err)
	}

	task, ok := s.tasks[id]
	if !ok {
		return models.Task{}, fmt.Errorf("task with ID %s not found to mark as done", id)
	}

	originalTask := task // For potential revert

	now := time.Now().UTC()
	task.Status = models.StatusCompleted
	task.CompletedAt = &now
	task.UpdatedAt = now

	if err := models.ValidateStruct(task); err != nil {
		s.tasks[id] = originalTask // Revert
		return models.Task{}, fmt.Errorf("validation failed for task %s after marking done: %w", id, err)
	}

	s.tasks[id] = task
	if err := s.saveTasksToFileInternal(); err != nil {
		s.tasks[id] = originalTask // Revert
		return models.Task{}, fmt.Errorf("failed to save task %s after marking done: %w", id, err)
	}

	return task, nil
}

// ListTasks retrieves a list of tasks.
// It can optionally apply a filter function and a sort function to the tasks.
func (s *FileTaskStore) ListTasks(filterFn func(models.Task) bool, sortFn func([]models.Task) []models.Task) ([]models.Task, error) {
	// Use a read lock if loadTasksFromFileInternal is thread-safe for reads or if tasks are loaded once and kept in memory.
	// Given that loadTasksFromFileInternal re-reads, an exclusive lock is safer here to prevent reading partial writes from other ops.
	if err := s.flk.Lock(); err != nil { // Using exclusive lock for safety during load. Could optimize with RLock if load is safe.
		return nil, fmt.Errorf("failed to acquire lock for ListTasks: %w", err)
	}
	defer s.flk.Unlock()

	if err := s.loadTasksFromFileInternal(); err != nil {
		return nil, fmt.Errorf("failed to load tasks for ListTasks: %w", err)
	}

	if len(s.tasks) == 0 {
		return []models.Task{}, nil
	}

	taskList := make([]models.Task, 0, len(s.tasks))
	for _, task := range s.tasks {
		taskList = append(taskList, task)
	}

	if filterFn != nil {
		filteredTasks := make([]models.Task, 0)
		for _, task := range taskList {
			if filterFn(task) {
				filteredTasks = append(filteredTasks, task)
			}
		}
		taskList = filteredTasks
	}

	if sortFn != nil {
		sortFn(taskList) // Sorts in-place
	}

	return taskList, nil
}

// Backup creates a backup of the current task data to the specified destination path.
func (s *FileTaskStore) Backup(destinationPath string) error {
	if err := s.flk.RLock(); err != nil { // Shared lock for reading the data file
		return fmt.Errorf("failed to acquire read lock for backup: %w", err)
	}
	defer s.flk.Unlock()

	input, err := os.ReadFile(s.filePath)
	if err != nil {
		return fmt.Errorf("failed to read source file %s for backup: %w", s.filePath, err)
	}

	if err = os.WriteFile(destinationPath, input, 0644); err != nil {
		return fmt.Errorf("failed to write backup file to %s: %w", destinationPath, err)
	}
	// Note: Backup does not copy the .checksum file. The backed up data file
	// would need its checksum recalculated if restored and checksums are enforced strictly.
	// Or, the backup process could be enhanced to also copy the checksum file if it exists.
	return nil
}

// Restore replaces the current task data with data from the specified source path.
// It also removes any existing checksum file for the main data path, as the new data's
// checksum will be generated on the next save if the source isn't checksummed itself.
func (s *FileTaskStore) Restore(sourcePath string) error {
	if err := s.flk.Lock(); err != nil { // Exclusive lock for writing the data file
		return fmt.Errorf("failed to acquire lock for restore: %w", err)
	}
	defer s.flk.Unlock()

	sourceData, err := os.ReadFile(sourcePath)
	if err != nil {
		return fmt.Errorf("failed to read source backup file %s: %w", sourcePath, err)
	}

	tempFilePath := s.filePath + ".tmp_restore"
	defer os.Remove(tempFilePath)

	if err = os.WriteFile(tempFilePath, sourceData, 0644); err != nil {
		return fmt.Errorf("failed to write restored data to temporary file %s: %w", tempFilePath, err)
	}

	if err = os.Rename(tempFilePath, s.filePath); err != nil {
		return fmt.Errorf("failed to atomically replace file %s with restored data from %s: %w", s.filePath, sourcePath, err)
	}

	// Remove old checksum file as the restored data might not match it, or source may not have one.
	// A new checksum will be generated on the next successful save of tasks.
	checksumFilePath := s.filePath + checksumSuffix
	_ = os.Remove(checksumFilePath) // Best effort removal

	return s.loadTasksFromFileInternal()
}

// GetTaskWithDescendants fetches a task by its ID along with all its children, grandchildren, etc.
func (s *FileTaskStore) GetTaskWithDescendants(rootID string) ([]models.Task, error) {
	if err := s.flk.RLock(); err != nil {
		return nil, fmt.Errorf("could not acquire read lock for GetTaskWithDescendants: %w", err)
	}
	defer s.flk.Unlock()

	if _, exists := s.tasks[rootID]; !exists {
		return nil, fmt.Errorf("task with root ID '%s' not found", rootID)
	}

	allTasksInTree := make(map[string]models.Task)
	var findChildren func(taskID string)

	findChildren = func(taskID string) {
		if task, ok := s.tasks[taskID]; ok {
			// Add the current task to the map
			allTasksInTree[task.ID] = task
			// Recurse for all its children
			for _, subID := range task.SubtaskIDs {
				if _, alreadyProcessed := allTasksInTree[subID]; !alreadyProcessed {
					findChildren(subID)
				}
			}
		}
	}

	findChildren(rootID)

	// Convert map to slice
	result := make([]models.Task, 0, len(allTasksInTree))
	for _, task := range allTasksInTree {
		result = append(result, task)
	}

	return result, nil
}

// Close releases any resources held by the store, such as file locks.
// It attempts to unlock the file lock associated with the FileTaskStore.
// flock.Unlock() is idempotent and can be called even if the lock is not held by this process.
func (s *FileTaskStore) Close() error {
	if s.flk != nil {
		return s.flk.Unlock()
	}
	return nil
}
</file>

<file path=".gitignore">
# TaskWing data directories
.taskwing/
.tasks/

# TaskWing binary
taskwing

# Go binaries and artifacts
*.exe
*.exe~
*.dll
*.so
*.dylib
*.test
dist/

# Environment and local config
.env
.env.local

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Editor files
.vscode/
.idea/
*.swp
*.swo
*~

# Development tools
.cursor/
.cursorrules
.claude/

# Test files
test_*.py
*_test_*

# Logs
*.log
logs/

# Temporary files
tmp/
temp/
</file>

<file path="go.mod">
module github.com/josephgoksu/taskwing.app

go 1.24.3

require (
	github.com/BurntSushi/toml v1.5.0
	github.com/briandowns/spinner v1.23.2
	github.com/go-playground/validator/v10 v10.26.0
	github.com/gofrs/flock v0.12.1
	github.com/google/uuid v1.6.0
	github.com/jedib0t/go-pretty/v6 v6.6.7
	github.com/joho/godotenv v1.5.1
	github.com/manifoldco/promptui v0.9.0
	github.com/modelcontextprotocol/go-sdk v0.2.0
	github.com/spf13/cobra v1.9.1
	github.com/spf13/viper v1.20.1
	gopkg.in/yaml.v3 v3.0.1
)

require (
	github.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e // indirect
	github.com/fatih/color v1.7.0 // indirect
	github.com/fsnotify/fsnotify v1.8.0 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-viper/mapstructure/v2 v2.2.1 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-colorable v0.1.2 // indirect
	github.com/mattn/go-isatty v0.0.8 // indirect
	github.com/mattn/go-runewidth v0.0.16 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/rivo/uniseg v0.4.7 // indirect
	github.com/sagikazarmark/locafero v0.7.0 // indirect
	github.com/sourcegraph/conc v0.3.0 // indirect
	github.com/spf13/afero v1.12.0 // indirect
	github.com/spf13/cast v1.7.1 // indirect
	github.com/spf13/pflag v1.0.6 // indirect
	github.com/subosito/gotenv v1.6.0 // indirect
	github.com/yosida95/uritemplate/v3 v3.0.2 // indirect
	go.uber.org/atomic v1.9.0 // indirect
	go.uber.org/multierr v1.9.0 // indirect
	golang.org/x/crypto v0.33.0 // indirect
	golang.org/x/net v0.34.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/term v0.29.0 // indirect
	golang.org/x/text v0.22.0 // indirect
)
</file>

<file path="cmd/config.go">
package cmd

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/go-playground/validator/v10"
	"github.com/joho/godotenv"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

const (
	configName = ".taskwing"
	envPrefix  = "TASKWING"
)

// LLMConfig holds configuration for Large Language Model interactions.
type LLMConfig struct {
	Provider                   string  `mapstructure:"provider" validate:"omitempty,oneof=openai google"`
	ModelName                  string  `mapstructure:"modelName" validate:"omitempty,min=1"`
	APIKey                     string  `mapstructure:"apiKey" validate:"omitempty,min=1"`    // Sensitive, primarily for ENV var loading
	ProjectID                  string  `mapstructure:"projectId" validate:"omitempty,min=1"` // For Google Cloud
	MaxOutputTokens            int     `mapstructure:"maxOutputTokens" validate:"omitempty,min=1"`
	Temperature                float64 `mapstructure:"temperature" validate:"omitempty,min=0,max=2"`
	EstimationTemperature      float64 `mapstructure:"estimationTemperature" validate:"omitempty,min=0,max=2"`
	EstimationMaxOutputTokens  int     `mapstructure:"estimationMaxOutputTokens" validate:"omitempty,min=1"`
	ImprovementTemperature     float64 `mapstructure:"improvementTemperature" validate:"omitempty,min=0,max=2"`
	ImprovementMaxOutputTokens int     `mapstructure:"improvementMaxOutputTokens" validate:"omitempty,min=1"`
}

// ProjectConfig holds project path related configuration
type ProjectConfig struct {
	RootDir       string `mapstructure:"rootDir" validate:"required"`       // Base directory for all project-specific files
	TasksDir      string `mapstructure:"tasksDir" validate:"required"`      // Relative to RootDir
	TemplatesDir  string `mapstructure:"templatesDir" validate:"required"`  // Relative to RootDir
	OutputLogPath string `mapstructure:"outputLogPath" validate:"required"` // Can be relative to RootDir or absolute
}

// DataConfig holds data storage-related configuration
type DataConfig struct {
	File   string `mapstructure:"file" validate:"required"`
	Format string `mapstructure:"format" validate:"required,oneof=json yaml toml"`
}

// AppConfig holds the application's entire configuration
type AppConfig struct {
	Greeting string        `mapstructure:"greeting"`
	Verbose  bool          `mapstructure:"verbose"`
	Config   string        `mapstructure:"config"`
	Project  ProjectConfig `mapstructure:"project" validate:"required"`
	Data     DataConfig    `mapstructure:"data" validate:"required"`
	LLM      LLMConfig     `mapstructure:"llm" validate:"omitempty"` // LLM config is optional overall
}

// GlobalAppConfig holds the global application configuration instance.
var GlobalAppConfig AppConfig

// validate is a single instance of Translate, it caches struct info
var validate *validator.Validate

func init() {
	validate = validator.New()
}

// validateAppConfig performs validation on the AppConfig struct.
func validateAppConfig(config *AppConfig) error {
	errs := validate.Struct(config)
	if errs != nil {
		// Optionally, you can iterate through errs to get more specific error messages.
		// For now, just return the full error object.
		return errs
	}
	return nil
}

// InitConfig reads in config file and ENV variables if set.
func InitConfig() {
	// Load .env file first if present
	if err := godotenv.Load(); err != nil {
		// It's okay if .env file doesn't exist.
		// If verbose, we could print a notice, but it's not critical.
	}

	// Environment variable handling must be set up BEFORE reading the config file
	// or checking for cfgFile, so that env vars can influence config loading if needed
	// (e.g. an env var pointing to a config directory, though not used here directly).
	viper.SetEnvPrefix(envPrefix)                          // e.g., TASKWING_VERBOSE
	viper.AutomaticEnv()                                   // Read in environment variables that match
	viper.SetEnvKeyReplacer(strings.NewReplacer(".", "_")) // Replace dots with underscores in env var names

	cfgFileFlag := viper.GetString("config") // Value from --config flag

	// Determine project root directory for config search path priority
	// Use default here, as GlobalAppConfig might not be unmarshaled yet.
	// We need project.rootDir *before* full unmarshal to locate the config file itself.
	// Viper provides a way to get a string with a default if not set:
	// However, viper.GetString("project.rootDir") might try to load config if it hasn't been told where to look yet.
	// So, we will assume a default like ".taskwing" for the purpose of *finding* the config file.
	// The actual value from config will be used once loaded.
	potentialProjectConfigDir := viper.GetString("project.rootDir")
	if potentialProjectConfigDir == "" { // If not set by ENV or previous (unlikely) viper.ReadInConfig
		potentialProjectConfigDir = ".taskwing" // Default directory name to check for project-specific config
	}

	if cfgFileFlag != "" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFileFlag)
	} else {
		// Check if potentialProjectConfigDir (e.g., ./.taskwing) exists
		if _, err := os.Stat(potentialProjectConfigDir); !os.IsNotExist(err) {
			// Project-specific config directory exists. Prioritize it.
			viper.AddConfigPath(potentialProjectConfigDir) // e.g., look in ./.taskwing/
			viper.SetConfigName(configName)                // configName is ".taskwing" -> ./.taskwing/.taskwing.yaml
		} else {
			// Project-specific config dir not found, fallback to home and current directory for global/legacy config
			home, err := os.UserHomeDir()
			cobra.CheckErr(err)
			viper.AddConfigPath(home)       // $HOME/.taskwing.yaml
			viper.AddConfigPath(".")        // ./.taskwing.yaml (legacy project root config)
			viper.SetConfigName(configName) // Still looking for a file named ".taskwing"
		}
	}

	// Attempt to read the configuration file.
	if err := viper.ReadInConfig(); err == nil {
		if viper.GetBool("verbose") {
			fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
		}
	} else {
		if _, ok := err.(viper.ConfigFileNotFoundError); ok {
			if cfgFileFlag != "" {
				// If a specific config file was provided by flag but not found, it's an error to report.
				fmt.Fprintln(os.Stderr, "Error: Specified config file not found:", cfgFileFlag)
				// os.Exit(1) // Or handle more gracefully depending on requirements
			} else if viper.GetBool("verbose") {
				// Config file not found by search paths, which is fine.
				fmt.Fprintln(os.Stderr, "No config file found. Using defaults and environment variables.")
			}
		} else {
			// Config file was found but another error was produced (e.g., parsing error).
			fmt.Fprintln(os.Stderr, "Error reading config file:", viper.ConfigFileUsed(), "-", err)
			// os.Exit(1) // Or handle more gracefully
		}
	}

	// Set default values
	viper.SetDefault("greeting", "Hello from TaskWing!")

	viper.SetDefault("project.rootDir", ".taskwing")
	viper.SetDefault("project.tasksDir", "tasks")
	viper.SetDefault("project.templatesDir", "templates")
	viper.SetDefault("project.outputLogPath", "logs/taskwing.log")
	viper.SetDefault("data.file", "tasks.json")
	viper.SetDefault("data.format", "json")

	// Defaults for LLMConfig
	viper.SetDefault("llm.provider", "openai")
	viper.SetDefault("llm.modelName", "gpt-5-mini-2025-08-07")
	viper.SetDefault("llm.apiKey", "")
	viper.SetDefault("llm.projectId", "")
	viper.SetDefault("llm.maxOutputTokens", 16384)
	viper.SetDefault("llm.temperature", 0.7)

	// After all sources are configured, unmarshal into GlobalAppConfig
	if err := viper.Unmarshal(&GlobalAppConfig); err != nil {
		fmt.Fprintf(os.Stderr, "Error unmarshaling config: %s\n", err)
		os.Exit(1) // Exit if unmarshaling fails
	}

	// Ensure critical project paths are set, falling back to Viper's defaults if empty after unmarshal.
	// This handles cases where a config file might exist but be missing these specific nested keys.
	if GlobalAppConfig.Project.RootDir == "" {
		GlobalAppConfig.Project.RootDir = viper.GetString("project.rootDir")
	}
	if GlobalAppConfig.Project.TasksDir == "" {
		GlobalAppConfig.Project.TasksDir = viper.GetString("project.tasksDir")
	}
	// Ensure outputLogPath is also sensible, potentially making it relative to RootDir if not absolute
	if GlobalAppConfig.Project.OutputLogPath == "" {
		GlobalAppConfig.Project.OutputLogPath = viper.GetString("project.outputLogPath")
	}
	if GlobalAppConfig.Project.RootDir != "" && GlobalAppConfig.Project.OutputLogPath != "" && !filepath.IsAbs(GlobalAppConfig.Project.OutputLogPath) {
		GlobalAppConfig.Project.OutputLogPath = filepath.Join(GlobalAppConfig.Project.RootDir, GlobalAppConfig.Project.OutputLogPath)
	}

	// Validate the populated configuration
	if err := validateAppConfig(&GlobalAppConfig); err != nil {
		fmt.Fprintf(os.Stderr, "Configuration validation error: %s\n", err)
		// You can iterate through err.(validator.ValidationErrors) for detailed messages
		// Example:
		// for _, err := range err.(validator.ValidationErrors) {
		// 	 fmt.Println(err.Namespace())
		// 	 fmt.Println(err.Field())
		// 	 fmt.Println(err.StructNamespace())
		// 	 fmt.Println(err.StructField())
		// 	 fmt.Println(err.Tag())
		// 	 fmt.Println(err.ActualTag())
		// 	 fmt.Println(err.Kind())
		// 	 fmt.Println(err.Type())
		// 	 fmt.Println(err.Value())
		// 	 fmt.Println(err.Param())
		// 	 fmt.Println()
		// }
		os.Exit(1) // Exit if validation fails
	}

	// The verbose and config values are bound from flags directly to Viper.
	// When Unmarshal runs, it will populate GlobalAppConfig.Verbose and GlobalAppConfig.Config
	// if those fields exist in the struct and are mapped.
	// We've added them to AppConfig struct with mapstructure tags.
}

// GetConfig returns a pointer to the global AppConfig instance.
func GetConfig() *AppConfig {
	return &GlobalAppConfig
}

// Example of how to get a config value
// func GetGreeting() string { // This can now be GetConfig().Greeting
// 	return viper.GetString("greeting")
// }
</file>

<file path="cmd/init.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

const (
	// projectConfigName is the base name of the config file (e.g., .taskwing)
	// It will be used to create .taskwing.yaml
	projectConfigName = ".taskwing"
)

// initCmd represents the init command
var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initializes a new TaskWing project or reinitializes an existing one.",
	Long: `The init command sets up the necessary TaskWing structures in the current directory.
This includes creating the project root directory (e.g., '.taskwing'),
the tasks directory within it (e.g., '.taskwing/tasks'),
and ensuring the task data file (e.g., 'tasks.json') can be initialized.`,
	Run: func(cmd *cobra.Command, args []string) {
		cfg := GetConfig() // Get the application configuration

		projectRootDir := cfg.Project.RootDir
		projectTasksDir := filepath.Join(projectRootDir, cfg.Project.TasksDir)

		// Create the project root and tasks directories
		if err := os.MkdirAll(projectTasksDir, 0755); err != nil {
			HandleError(fmt.Sprintf("Error: Could not create project directories at '%s'.", projectTasksDir), err)
		}

		// Attempt to get the store, which will initialize the data file if it doesn't exist.
		store, err := GetStore()
		if err != nil {
			HandleError(fmt.Sprintf("Error: Could not initialize task store."), err)
		}
		store.Close() // Close the lock immediately after initialization

		// Create default config file if it doesn't exist inside the project root dir
		projectConfigFilePath := filepath.Join(projectRootDir, fmt.Sprintf("%s.yaml", projectConfigName))
		configCreated := false
		configExisted := false

		if _, statErr := os.Stat(projectConfigFilePath); os.IsNotExist(statErr) {
			fmt.Printf("Creating default configuration file: %s\n", projectConfigFilePath)

			// Use viper to get the default values as strings/ints/etc.
			defaultConfigContent := fmt.Sprintf(
				`# TaskWing Project-Specific Configuration
# File: %s
# This file allows you to override default TaskWing settings for this project.

project:
  rootDir: "%s"
  tasksDir: "%s"
  templatesDir: "%s"
  outputLogPath: "%s"

data:
  file: "%s"
  format: "%s"

# --- Optional configurations ---
# Uncomment and customize as needed.

# --- LLM Configuration for 'taskwing generate tasks' ---
# llm:
#   provider: "%s"
#   modelName: "%s"
#   # It's STRONGLY recommended to set API keys via an environment variable:
#   # - For OpenAI: TASKWING_LLM_APIKEY or OPENAI_API_KEY
#   # - For Google: TASKWING_LLM_APIKEY or GOOGLE_API_KEY
#   apiKey: ""
#   # Required for Google Cloud provider if not using Application Default Credentials
#   projectId: "%s"
#   maxOutputTokens: %d
#   temperature: %.1f
#   estimationTemperature: %.1f
#   estimationMaxOutputTokens: %d
#   improvementTemperature: %.1f
#   improvementMaxOutputTokens: %d

# verbose: %t
`,
				filepath.ToSlash(projectConfigFilePath),
				viper.GetString("project.rootDir"),
				viper.GetString("project.tasksDir"),
				viper.GetString("project.templatesDir"),
				viper.GetString("project.outputLogPath"),
				viper.GetString("data.file"),
				viper.GetString("data.format"),
				viper.GetString("llm.provider"),
				viper.GetString("llm.modelName"),
				viper.GetString("llm.projectId"),
				viper.GetInt("llm.maxOutputTokens"),
				viper.GetFloat64("llm.temperature"),
				viper.GetFloat64("llm.estimationTemperature"),
				viper.GetInt("llm.estimationMaxOutputTokens"),
				viper.GetFloat64("llm.improvementTemperature"),
				viper.GetInt("llm.improvementMaxOutputTokens"),
				viper.GetBool("verbose"),
			)

			// Write the config file
			err = os.WriteFile(projectConfigFilePath, []byte(defaultConfigContent), 0644)
			if err != nil {
				HandleError(fmt.Sprintf("Error: Could not write configuration file at '%s'.", projectConfigFilePath), err)
			}
			configCreated = true
		} else {
			configExisted = true
		}

		// Summary
		fmt.Printf("TaskWing has been initialized in the current directory.\n")
		fmt.Printf("Project root directory: %s\n", projectRootDir)
		fmt.Printf("Tasks directory: %s\n", projectTasksDir)

		if configCreated {
			fmt.Printf("Configuration file created: %s\n", projectConfigFilePath)
		} else if configExisted {
			fmt.Printf("Configuration file already exists: %s\n", projectConfigFilePath)
		}

		fmt.Println("You can now use 'taskwing add' to create your first task!")
	},
}

func init() {
	rootCmd.AddCommand(initCmd)
}
</file>

<file path="llm/provider.go">
package llm

import "context"

// LLMConfig holds the specific configuration fields needed by the LLM package.
// This helps avoid circular dependencies with the cmd package.
type LLMConfig struct {
	Provider                   string
	ModelName                  string
	APIKey                     string // Resolved API key
	ProjectID                  string // For Google Cloud
	MaxOutputTokens            int
	Temperature                float64
	EstimationTemperature      float64 // Temperature for the estimation call
	EstimationMaxOutputTokens  int     // Max output tokens for the estimation call
	ImprovementTemperature     float64 // Temperature for the PRD improvement call
	ImprovementMaxOutputTokens int     // Max output tokens for the PRD improvement call
}

// TaskOutput is the expected structure for tasks extracted by an LLM.
// This structure is designed to be easily convertible to models.Task.
type TaskOutput struct {
	Title              string       `json:"title"`
	Description        string       `json:"description"`
	AcceptanceCriteria string       `json:"acceptanceCriteria"`
	Priority           string       `json:"priority"` // e.g., "high", "medium", "low", "urgent"
	TempID             int          `json:"tempId"`   // A temporary, unique ID for this task within the generation context.
	Subtasks           []TaskOutput `json:"subtasks,omitempty"`
	DependsOnIDs       []int        `json:"dependsOnIds,omitempty"` // List of TempIDs of other tasks it depends on.
}

// EstimationOutput holds the LLM's estimation of task parameters from a document.
type EstimationOutput struct {
	EstimatedTaskCount  int    `json:"estimatedTaskCount"`
	EstimatedComplexity string `json:"estimatedComplexity"` // e.g., "low", "medium", "high"
}

// Provider defines the interface for interacting with different LLM providers
// to generate tasks from a document.
type Provider interface {
	// GenerateTasks takes a system prompt, the content of a document (e.g., PRD),
	// model parameters, and returns a list of TaskOutput objects or an error.
	GenerateTasks(ctx context.Context, systemPrompt, prdContent string, modelName string, apiKey string, projectID string, maxTokens int, temperature float64) ([]TaskOutput, error)

	// EstimateTaskParameters takes a system prompt, the content of a document and returns an estimation
	// of task count and complexity. This is used to dynamically adjust parameters for GenerateTasks.
	EstimateTaskParameters(ctx context.Context, systemPrompt, prdContent string, modelName string, apiKey string, projectID string, maxTokensForEstimation int, temperatureForEstimation float64) (EstimationOutput, error)

	// ImprovePRD takes a system prompt, the content of a PRD, sends it to an LLM for refinement,
	// and returns the improved document content as a string.
	ImprovePRD(ctx context.Context, systemPrompt, prdContent string, modelName string, apiKey string, projectID string, maxTokensForImprovement int, temperatureForImprovement float64) (string, error)
}
</file>

<file path="cmd/generate.go">
/*
Copyright ¬© 2025 Joseph Goksu josephgoksu@gmail.com
*/
package cmd

import (
	"context"
	"encoding/json" // For pretty printing task output for now
	"errors"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"strings"
	"time"

	"github.com/briandowns/spinner"
	"github.com/google/uuid"                  // For generating final IDs
	"github.com/josephgoksu/taskwing.app/llm" // Import the new llm package
	"github.com/josephgoksu/taskwing.app/models"
	"github.com/josephgoksu/taskwing.app/prompts"
	"github.com/josephgoksu/taskwing.app/store" // For TaskStore interface
	"github.com/manifoldco/promptui"
	"github.com/spf13/cobra"
	// For direct ENV var check as fallback
)

// generateCmd represents the generate command
var generateCmd = &cobra.Command{
	Use:   "generate",
	Short: "Generate TaskWing artifacts.",
	Long:  `The generate command has subcommands to generate various TaskWing artifacts, such as tasks from a document.`,
	// Run: func(cmd *cobra.Command, args []string) { ... }, // Base command does nothing itself
}

var generateTasksCmd = &cobra.Command{
	Use:   "tasks --file <path_to_document>",
	Short: "Generate tasks from a document (e.g., PRD).",
	Long: `Parses a document (e.g., a Product Requirements Document) using an AI model
and generates a list of tasks and subtasks based on its content.

The supported document formats are plain text (.txt) and Markdown (.md).
The system will prompt for confirmation before creating any tasks.

Requires LLM to be configured in .taskwing/.taskwing.yaml or via environment variables.
Example configuration in .taskwing/.taskwing.yaml:
llm:
  provider: "openai" # or "google"
  modelName: "gpt-5-mini-2025-08-07" # GPT-5 Mini model
  # apiKey: "YOUR_OPENAI_API_KEY" # Set via TASKWING_LLM_APIKEY or OPENAI_API_KEY
  # projectId: "your-gcp-project-id" # For Google, if provider is "google"
  # maxOutputTokens: 2048
  # temperature: 0.7
`,
	Args: cobra.NoArgs, // Path will be a flag
	Run: func(cmd *cobra.Command, args []string) {
		// Graceful shutdown context listening for SIGINT (Ctrl+C)
		ctx, stop := signal.NotifyContext(cmd.Context(), os.Interrupt)
		defer stop()

		docPath, _ := cmd.Flags().GetString("file")

		if docPath == "" {
			HandleError("Error: The --file flag is required with the path to your document.", nil)
		}

		// --- PRE-GENERATION CHECKS ---
		// 1. Check for existing tasks and ask for overwrite confirmation BEFORE any expensive operations.
		taskStore, err := GetStore()
		if err != nil {
			HandleError("Error: Could not initialize the task store.", err)
		}

		existingTasks, err := taskStore.ListTasks(nil, nil)
		if err != nil {
			HandleError("Error: Could not check for existing tasks.", err)
		}

		if len(existingTasks) > 0 {
			numExisting := len(existingTasks)
			fmt.Printf("Found %d existing task(s).\n", numExisting)
			overwritePrompt := promptui.Prompt{
				Label:     prompts.GenerateTasksOverwriteConfirmation,
				IsConfirm: true,
			}
			_, err := overwritePrompt.Run()
			if err != nil {
				if err == promptui.ErrAbort {
					fmt.Println("Task generation cancelled.")
					taskStore.Close()
					return
				}
				taskStore.Close()
				HandleError("Error: Could not get confirmation for overwriting tasks.", err)
			}

			// User confirmed overwrite. Delete existing tasks now.
			fmt.Println("\nDeleting existing tasks...")
			if err := taskStore.DeleteAllTasks(); err != nil {
				taskStore.Close()
				HandleError("Error: Could not delete the existing tasks.", err)
			}
			fmt.Printf("Successfully deleted %d task(s).\n\n", numExisting)
		}

		// We are done with pre-checks, we can close the store connection for now.
		// It will be re-opened later for creation. This avoids holding the lock.
		taskStore.Close()

		// --- LLM TASK GENERATION ---
		appCfg := GetConfig()

		// 2. Read PRD file content.
		prdContentBytes, err := os.ReadFile(docPath)
		if err != nil {
			HandleError(fmt.Sprintf("Error: Could not read document file '%s'.", docPath), err)
		}
		prdContent := string(prdContentBytes)

		// 3. Load LLM configuration from Viper.
		cmdLLMCfg := appCfg.LLM // This is cmd.LLMConfig

		// Prepare llm.LLMConfig from cmd.LLMConfig, resolving API keys from ENV if necessary.
		resolvedLLMConfig := llm.LLMConfig{
			Provider:                   cmdLLMCfg.Provider,
			ModelName:                  cmdLLMCfg.ModelName,
			APIKey:                     cmdLLMCfg.APIKey,    // Viper already handles ENV overlay for this field from cmd.LLMConfig
			ProjectID:                  cmdLLMCfg.ProjectID, // Viper already handles ENV overlay
			MaxOutputTokens:            cmdLLMCfg.MaxOutputTokens,
			Temperature:                cmdLLMCfg.Temperature,
			EstimationTemperature:      cmdLLMCfg.EstimationTemperature,
			EstimationMaxOutputTokens:  cmdLLMCfg.EstimationMaxOutputTokens,
			ImprovementTemperature:     cmdLLMCfg.ImprovementTemperature,     // Added
			ImprovementMaxOutputTokens: cmdLLMCfg.ImprovementMaxOutputTokens, // Added
		}

		// Explicitly check/resolve APIKey from specific ENV vars if still empty after Viper's load
		if resolvedLLMConfig.APIKey == "" {
			switch resolvedLLMConfig.Provider {
			case "openai":
				apiKeyEnv := os.Getenv("OPENAI_API_KEY")
				if apiKeyEnv == "" {
					apiKeyEnv = os.Getenv(envPrefix + "_LLM_APIKEY")
				}
				resolvedLLMConfig.APIKey = apiKeyEnv
			case "google":
				apiKeyEnv := os.Getenv("GOOGLE_API_KEY")
				if apiKeyEnv == "" {
					apiKeyEnv = os.Getenv(envPrefix + "_LLM_APIKEY")
				}
				resolvedLLMConfig.APIKey = apiKeyEnv
			}
		}
		// Resolve ProjectID for Google if still empty
		if resolvedLLMConfig.Provider == "google" && resolvedLLMConfig.ProjectID == "" {
			resolvedLLMConfig.ProjectID = os.Getenv(envPrefix + "_LLM_PROJECTID")
		}

		// Validate essential LLM config after attempting ENV var fallbacks
		if resolvedLLMConfig.Provider == "" {
			HandleError("Error: LLM provider is not configured. Set 'llm.provider' in your config or use the TASKWING_LLM_PROVIDER environment variable.", nil)
		}
		if resolvedLLMConfig.ModelName == "" {
			HandleError("Error: LLM model name is not configured. Set 'llm.modelName' in your config or use the TASKWING_LLM_MODELNAME environment variable.", nil)
		}
		if resolvedLLMConfig.Provider == "openai" && resolvedLLMConfig.APIKey == "" {
			HandleError("Error: OpenAI API key is not configured. Set 'llm.apiKey' in your config or use the TASKWING_LLM_APIKEY or OPENAI_API_KEY environment variables.", nil)
		}
		if resolvedLLMConfig.Provider == "google" && resolvedLLMConfig.ProjectID == "" {
			HandleError("Error: Google Cloud ProjectID is not configured. Set 'llm.projectId' in your config or use the TASKWING_LLM_PROJECTID environment variable.", nil)
		}

		// 4. Instantiate LLM Provider.
		provider, err := llm.NewProvider(&resolvedLLMConfig)
		if err != nil {
			HandleError("Error: Could not create the LLM provider.", err)
		}

		// --- OPTIONAL PRD IMPROVEMENT ---
		// Construct the absolute path to the templates directory for the prompt loader.
		absoluteTemplatesDir := filepath.Join(appCfg.Project.RootDir, appCfg.Project.TemplatesDir)

		improvePrompt := promptui.Prompt{
			Label:     prompts.GenerateTasksImprovementConfirmation,
			IsConfirm: true,
			Default:   "y",
		}
		_, err = improvePrompt.Run()
		if err != nil && err != promptui.ErrAbort {
			HandleError("Error: Could not get confirmation for PRD improvement.", err)
			return // Unreachable
		}

		if err == nil { // User confirmed "yes"
			s := spinner.New(spinner.CharSets[11], 100*time.Millisecond)
			s.Suffix = " Improving PRD with LLM... (This may take a moment)"
			s.Start()

			improveSystemPrompt, promptErr := prompts.GetPrompt(prompts.KeyImprovePRD, absoluteTemplatesDir)
			if promptErr != nil {
				s.Stop()
				HandleError("Error loading PRD improvement prompt.", promptErr)
			}
			improvedContent, improveErr := provider.ImprovePRD(
				ctx, // Pass the cancellable context
				improveSystemPrompt,
				prdContent,
				resolvedLLMConfig.ModelName,
				resolvedLLMConfig.APIKey,
				resolvedLLMConfig.ProjectID,
				resolvedLLMConfig.ImprovementMaxOutputTokens,
				resolvedLLMConfig.ImprovementTemperature,
			)
			s.Stop()
			fmt.Println() // Newline after spinner stops

			if improveErr != nil {
				if errors.Is(improveErr, context.Canceled) {
					fmt.Println("\nOperation cancelled by user.")
					os.Exit(130) // Standard exit code for Ctrl+C
				}
				fmt.Fprintf(os.Stderr, "Warning: Failed to improve PRD: %v. Proceeding with original content.\n", improveErr)
			} else {
				prdContent = improvedContent // Use the improved content for subsequent steps

				// Save the improved PRD for auditing
				generatedPRDDir := filepath.Join(appCfg.Project.RootDir, "generated_prds")
				if err := os.MkdirAll(generatedPRDDir, 0755); err != nil {
					fmt.Fprintf(os.Stderr, "Warning: Could not create directory for improved PRD at '%s': %v\n", generatedPRDDir, err)
				} else {
					baseName := strings.TrimSuffix(filepath.Base(docPath), filepath.Ext(docPath))
					improvedPRDPath := filepath.Join(generatedPRDDir, fmt.Sprintf("%s-improved-%s.md", baseName, time.Now().Format("20060102-150405")))
					if err := os.WriteFile(improvedPRDPath, []byte(prdContent), 0644); err != nil {
						fmt.Fprintf(os.Stderr, "Warning: Failed to save improved PRD to '%s': %v\n", improvedPRDPath, err)
					} else {
						fmt.Printf("Improved PRD saved for review at: %s\n", improvedPRDPath)
					}
				}
			}
		} else {
			fmt.Println("Skipping PRD improvement. Proceeding with original content.")
		}

		// Attempt to estimate task parameters to dynamically set maxOutputTokens
		s := spinner.New(spinner.CharSets[11], 100*time.Millisecond)
		s.Suffix = fmt.Sprintf(" Estimating task parameters from document using %s provider and model %s...", resolvedLLMConfig.Provider, resolvedLLMConfig.ModelName)
		s.Start()

		estimateSystemPrompt, promptErr := prompts.GetPrompt(prompts.KeyEstimateTasks, absoluteTemplatesDir)
		if promptErr != nil {
			s.Stop()
			HandleError("Error loading task estimation prompt.", promptErr)
		}
		estimationOutput, estimationErr := provider.EstimateTaskParameters(
			ctx, // Pass the cancellable context
			estimateSystemPrompt,
			prdContent,
			resolvedLLMConfig.ModelName,
			resolvedLLMConfig.APIKey,
			resolvedLLMConfig.ProjectID,
			resolvedLLMConfig.EstimationMaxOutputTokens, // Use configured estimation tokens
			resolvedLLMConfig.EstimationTemperature,     // Use configured estimation temperature
		)
		s.Stop()
		fmt.Println() // Newline after spinner stops

		currentMaxOutputTokens := resolvedLLMConfig.MaxOutputTokens // Fallback to configured value
		const minDynamicTokens = 4096                               // Absolute minimum if we calculate dynamically below this.
		const maxSensibleDynamicTokens = 32768                      // Cap for dynamically calculated tokens

		if estimationErr != nil {
			if errors.Is(estimationErr, context.Canceled) {
				fmt.Println("\nOperation cancelled by user.")
				os.Exit(130)
			}
			fmt.Fprintf(os.Stderr, "Warning: Failed to estimate task parameters, will use configured maxOutputTokens (%d). Error: %v\n", currentMaxOutputTokens, estimationErr)
		} else {
			fmt.Printf("LLM Estimation - Estimated Task Count: %d, Complexity: %s\n", estimationOutput.EstimatedTaskCount, estimationOutput.EstimatedComplexity)
			if estimationOutput.EstimatedTaskCount > 0 {
				calculatedTokens := (estimationOutput.EstimatedTaskCount * 200) + 2048 // Heuristic: 200 tokens/task + 2048 buffer

				// Ensure dynamic tokens are not excessively low or high
				if calculatedTokens < minDynamicTokens {
					dynamicMaxOutputTokens := minDynamicTokens
					fmt.Printf("Calculated dynamic tokens (%d) is below minimum (%d), using minimum.\n", calculatedTokens, minDynamicTokens)
					currentMaxOutputTokens = dynamicMaxOutputTokens
				} else if calculatedTokens > maxSensibleDynamicTokens {
					dynamicMaxOutputTokens := maxSensibleDynamicTokens
					fmt.Printf("Calculated dynamic tokens (%d) exceeds sensible cap (%d), using cap.\n", calculatedTokens, maxSensibleDynamicTokens)
					currentMaxOutputTokens = dynamicMaxOutputTokens
				} else {
					currentMaxOutputTokens = calculatedTokens
				}
				fmt.Printf("Using dynamically determined maxOutputTokens: %d\n", currentMaxOutputTokens)
			} else {
				fmt.Printf("LLM estimated 0 tasks. Using configured maxOutputTokens: %d\n", currentMaxOutputTokens)
			}
		}

		genSpinner := spinner.New(spinner.CharSets[11], 100*time.Millisecond)
		genSpinner.Suffix = fmt.Sprintf(" Generating tasks from '%s' (max output tokens: %d) using %s provider and model %s...", docPath, currentMaxOutputTokens, resolvedLLMConfig.Provider, resolvedLLMConfig.ModelName)
		genSpinner.Start()

		// 5. Call LLM service to generate tasks with the determined maxOutputTokens.
		generateSystemPrompt, promptErr := prompts.GetPrompt(prompts.KeyGenerateTasks, absoluteTemplatesDir)
		if promptErr != nil {
			genSpinner.Stop()
			HandleError("Error loading task generation prompt.", promptErr)
		}
		llmTaskOutputs, err := provider.GenerateTasks(
			ctx, // Pass the cancellable context
			generateSystemPrompt,
			prdContent,
			resolvedLLMConfig.ModelName,
			resolvedLLMConfig.APIKey,
			resolvedLLMConfig.ProjectID,
			currentMaxOutputTokens,
			resolvedLLMConfig.Temperature,
		)
		genSpinner.Stop()
		fmt.Println() // Newline after spinner stops

		if err != nil {
			if errors.Is(err, context.Canceled) {
				fmt.Println("\nOperation cancelled by user.")
				os.Exit(130)
			}
			HandleError("Error: The AI model failed to generate tasks.", err)
		}

		if len(llmTaskOutputs) == 0 {
			fmt.Println("LLM did not return any tasks based on the document.")
			return
		}

		fmt.Printf("LLM returned %d potential top-level task(s).\n", len(llmTaskOutputs))

		// 6. Parse LLM JSON response (already parsed into llmTaskOutputs by the provider method).

		// 7. Resolve parent/child and dependency relationships by title.
		fmt.Println("\n--- Raw LLM Task Outputs (for debugging) ---")
		rawOutputBytes, _ := json.MarshalIndent(llmTaskOutputs, "", "  ")
		fmt.Println(string(rawOutputBytes))
		fmt.Println("--- End Raw LLM Task Outputs ---")

		taskCandidates, relationshipMap, err := resolveAndBuildTaskCandidates(llmTaskOutputs)
		if err != nil {
			HandleError("Error: Could not process the AI model's output.", err)
		}

		if len(taskCandidates) == 0 {
			fmt.Println("No valid task candidates could be formed from the LLM output.")
			return
		}

		// --- POST-GENERATION CONFIRMATION ---
		// 8. Display tasks and ask for final confirmation to create them.
		fmt.Printf("\n--- Proposed Tasks to Create (%d) ---\n", len(taskCandidates))
		displayTaskCandidates(taskCandidates, relationshipMap)

		confirmPrompt := promptui.Prompt{
			Label:     fmt.Sprintf("Do you want to create these %d tasks?", len(taskCandidates)),
			IsConfirm: true,
		}
		_, confirmErr := confirmPrompt.Run()
		if confirmErr != nil {
			if confirmErr == promptui.ErrAbort {
				fmt.Println("Task creation cancelled.")
				return
			}
			HandleError("Error: Could not get confirmation to create tasks.", confirmErr)
		}

		// 9. If confirmed, get a fresh store connection and create tasks.
		fmt.Println("\nCreating tasks...")
		finalTaskStore, finalStoreErr := GetStore()
		if finalStoreErr != nil {
			HandleError("Error: Could not initialize task store for the final step.", finalStoreErr)
		}
		defer finalTaskStore.Close()

		createdCount, creationErrors := createTasksInStore(finalTaskStore, taskCandidates, relationshipMap)
		fmt.Printf("Successfully created %d tasks.\n", createdCount)
		if len(creationErrors) > 0 {
			fmt.Fprintf(os.Stderr, "Encountered %d errors during task creation:\n", len(creationErrors))
			for i, e := range creationErrors {
				fmt.Fprintf(os.Stderr, "  %d: %v\n", i+1, e)
			}
		}
	},
}

// tempIDs for relationship mapping during candidate resolution
const tempIDPrefix = "temp_task_id_"

type taskRelationshipMap struct {
	tempParentToChildren map[string][]string    // tempParentID -> []tempChildID
	tempChildToParent    map[string]string      // tempChildID -> tempParentID
	tempTaskToDeps       map[string][]string    // tempTaskID -> []tempDependencyID (where dependency is also a tempID)
	flattenedTasks       map[string]models.Task // tempID -> models.Task (without final ID, ParentID, Dependencies)
	titleToTempID        map[string]string      // title -> tempID (for resolving deps by title)
	tempIDToInputID      map[int]string         // input tempId (int) -> internal tempID (string)
	taskOrder            []string               // tempIDs in a stable order for processing and display
}

// resolveAndBuildTaskCandidates processes LLM outputs into a flat list of models.Task candidates
// and a map representing their relationships using temporary IDs.
func resolveAndBuildTaskCandidates(llmOutputs []llm.TaskOutput) ([]models.Task, taskRelationshipMap, error) {
	relMap := taskRelationshipMap{
		tempParentToChildren: make(map[string][]string),
		tempChildToParent:    make(map[string]string),
		tempTaskToDeps:       make(map[string][]string),
		flattenedTasks:       make(map[string]models.Task),
		tempIDToInputID:      make(map[int]string),
		taskOrder:            make([]string, 0),
	}
	tempIDCounter := 0

	// Recursive function to flatten tasks and initial relationships
	var flatten func(outputs []llm.TaskOutput, parentTempID string) error
	flatten = func(outputs []llm.TaskOutput, parentTempID string) error {
		for _, llmTask := range outputs {
			tempIDCounter++
			currentTempID := fmt.Sprintf("%s%d", tempIDPrefix, tempIDCounter)

			if llmTask.Title == "" {
				fmt.Fprintf(os.Stderr, "Warning: LLM returned a task with an empty title. Skipping this task.\n")
				continue
			}
			if llmTask.TempID == 0 {
				return fmt.Errorf("LLM returned a task with a missing or zero tempId: '%s'. Aborting.", llmTask.Title)
			}

			if _, idExists := relMap.tempIDToInputID[llmTask.TempID]; idExists {
				return fmt.Errorf("duplicate tempId %d found from LLM output. Each task must have a unique tempId.", llmTask.TempID)
			}
			relMap.tempIDToInputID[llmTask.TempID] = currentTempID
			relMap.taskOrder = append(relMap.taskOrder, currentTempID)

			candidateTask := models.Task{
				Title:              llmTask.Title,
				Description:        llmTask.Description,
				AcceptanceCriteria: llmTask.AcceptanceCriteria,
				Priority:           mapLLMPriority(llmTask.Priority),
				Status:             models.StatusPending,
			}
			relMap.flattenedTasks[currentTempID] = candidateTask

			if parentTempID != "" {
				relMap.tempParentToChildren[parentTempID] = append(relMap.tempParentToChildren[parentTempID], currentTempID)
				relMap.tempChildToParent[currentTempID] = parentTempID
			}

			// Store dependencies by their given integer tempIDs for later resolution
			if len(llmTask.DependsOnIDs) > 0 {
				depStrs := make([]string, len(llmTask.DependsOnIDs))
				for i, id := range llmTask.DependsOnIDs {
					depStrs[i] = fmt.Sprintf("%d", id)
				}
				relMap.tempTaskToDeps[currentTempID] = depStrs
			}

			if len(llmTask.Subtasks) > 0 {
				if err := flatten(llmTask.Subtasks, currentTempID); err != nil {
					return err // Propagate error up if any
				}
			}
		}
		return nil
	}

	if err := flatten(llmOutputs, ""); err != nil {
		return nil, relMap, err
	}

	// Second pass: Resolve DependsOnIDs from integer tempIDs to internal string tempIDs
	for taskTempID, depIntIDs := range relMap.tempTaskToDeps {
		var depTempIDs []string
		for _, depIntIDStr := range depIntIDs {
			var depIntID int
			fmt.Sscanf(depIntIDStr, "%d", &depIntID) // Convert string back to int for lookup

			if depTargetTempID, exists := relMap.tempIDToInputID[depIntID]; exists {
				if depTargetTempID == taskTempID {
					// This check is against the internal string tempID, which is correct
					return nil, relMap, fmt.Errorf("task '%s' (tempId %d) cannot depend on itself", relMap.flattenedTasks[taskTempID].Title, depIntID)
				}
				depTempIDs = append(depTempIDs, depTargetTempID)
			} else {
				fmt.Fprintf(os.Stderr, "Warning: Dependency tempId '%d' for task '%s' not found. Skipping dependency.\n", depIntID, relMap.flattenedTasks[taskTempID].Title)
			}
		}
		relMap.tempTaskToDeps[taskTempID] = depTempIDs
	}

	finalCandidates := make([]models.Task, 0, len(relMap.taskOrder))
	for _, tempID := range relMap.taskOrder {
		finalCandidates = append(finalCandidates, relMap.flattenedTasks[tempID])
	}

	return finalCandidates, relMap, nil
}

func mapLLMPriority(llmPriority string) models.TaskPriority {
	switch strings.ToLower(strings.TrimSpace(llmPriority)) {
	case "urgent":
		return models.PriorityUrgent
	case "high":
		return models.PriorityHigh
	case "medium", "med", "": // Treat empty as medium
		return models.PriorityMedium
	case "low":
		return models.PriorityLow
	default:
		fmt.Fprintf(os.Stderr, "Warning: Unknown LLM priority '%s', defaulting to Medium.\n", llmPriority)
		return models.PriorityMedium
	}
}

func displayTaskCandidates(tasks []models.Task, relMap taskRelationshipMap) {
	fmt.Println("----------------------------------------------------------------------")

	tempIDToDisplayIndex := make(map[string]int)
	for i, tempID := range relMap.taskOrder {
		tempIDToDisplayIndex[tempID] = i + 1
	}

	for i, currentTempID := range relMap.taskOrder {
		task := relMap.flattenedTasks[currentTempID]
		fmt.Printf("[%d] Title: %s (Priority: %s)\n", i+1, task.Title, task.Priority)
		if task.Description != "" && task.Description != task.Title {
			fmt.Printf("    Description: %s\n", task.Description)
		}
		if task.AcceptanceCriteria != "" {
			// Format acceptance criteria for better readability
			formattedAC := strings.ReplaceAll(task.AcceptanceCriteria, "\n", "\n                 ")
			fmt.Printf("    Acceptance Criteria: %s\n", formattedAC)
		}

		if parentTempID, isChild := relMap.tempChildToParent[currentTempID]; isChild {
			if parentTask, ok := relMap.flattenedTasks[parentTempID]; ok {
				fmt.Printf("    Parent Task: %s (Ref: #%d)\n", parentTask.Title, tempIDToDisplayIndex[parentTempID])
			}
		}
		if subtaskTempIDs, hasSubtasks := relMap.tempParentToChildren[currentTempID]; hasSubtasks {
			var subtaskRefs []string
			for _, subTempID := range subtaskTempIDs {
				if subTask, ok := relMap.flattenedTasks[subTempID]; ok {
					subtaskRefs = append(subtaskRefs, fmt.Sprintf("%s (#%d)", subTask.Title, tempIDToDisplayIndex[subTempID]))
				}
			}
			if len(subtaskRefs) > 0 {
				fmt.Printf("    Subtasks: %s\n", strings.Join(subtaskRefs, "; "))
			}
		}
		if depTempIDs, hasDeps := relMap.tempTaskToDeps[currentTempID]; hasDeps {
			var depRefs []string
			for _, depTempID := range depTempIDs {
				if depTask, ok := relMap.flattenedTasks[depTempID]; ok {
					depRefs = append(depRefs, fmt.Sprintf("%s (#%d)", depTask.Title, tempIDToDisplayIndex[depTempID]))
				}
			}
			if len(depRefs) > 0 {
				fmt.Printf("    Depends On: %s\n", strings.Join(depRefs, "; "))
			}
		}
		fmt.Println("----------------------------------------------------------------------")
	}
}

func createTasksInStore(store store.TaskStore, taskCandidates []models.Task, relMap taskRelationshipMap) (createdCount int, errors []error) {
	tempIDToFinalID := make(map[string]string)

	// Pass 1: Assign final UUIDs to all tasks based on their tempIDs from relMap.taskOrder
	tasksWithFinalIDs := make(map[string]models.Task) // tempID -> task with final UUID
	for _, tempID := range relMap.taskOrder {
		candidate := relMap.flattenedTasks[tempID]
		finalID := uuid.New().String()
		tempIDToFinalID[tempID] = finalID

		taskWithFinalID := candidate
		taskWithFinalID.ID = finalID
		tasksWithFinalIDs[tempID] = taskWithFinalID
	}

	// Pass 2: Link ParentID and Dependencies using the final UUIDs
	tasksToCreate := make([]models.Task, 0, len(relMap.taskOrder))
	for _, tempID := range relMap.taskOrder {
		linkedTask := tasksWithFinalIDs[tempID]

		if parentTempID, isChild := relMap.tempChildToParent[tempID]; isChild {
			if finalParentID, ok := tempIDToFinalID[parentTempID]; ok {
				linkedTask.ParentID = &finalParentID
			} else {
				errors = append(errors, fmt.Errorf("internal error: could not find final ID for parent tempID %s of task %s", parentTempID, linkedTask.Title))
			}
		}

		if depTempIDs, hasDeps := relMap.tempTaskToDeps[tempID]; hasDeps {
			var finalDepIDs []string
			for _, depTempID := range depTempIDs {
				if finalDepID, ok := tempIDToFinalID[depTempID]; ok {
					finalDepIDs = append(finalDepIDs, finalDepID)
				} else {
					errors = append(errors, fmt.Errorf("internal error: could not find final ID for dependency tempID %s of task %s", depTempID, linkedTask.Title))
				}
			}
			linkedTask.Dependencies = finalDepIDs
		}
		tasksToCreate = append(tasksToCreate, linkedTask)
	}

	if len(errors) > 0 { // If linking failed, don't proceed to creation
		return 0, errors
	}

	// Pass 3: Create tasks in the store
	// The store's CreateTask method should handle setting SubtaskIDs on parents and Dependents on dependencies.
	for _, taskToSave := range tasksToCreate {
		createdTask, err := store.CreateTask(taskToSave)
		if err != nil {
			errors = append(errors, fmt.Errorf("failed to create task '%s' (ID: %s): %w", taskToSave.Title, taskToSave.ID, err))
		} else {
			createdCount++
			fmt.Printf("  Created task: %s (ID: %s)\n", createdTask.Title, createdTask.ID)
		}
	}
	return createdCount, errors
}

func init() {
	rootCmd.AddCommand(generateCmd)
	generateCmd.AddCommand(generateTasksCmd)

	generateTasksCmd.Flags().StringP("file", "f", "", "Path to the document file (PRD) to generate tasks from.")
	// MarkAsRequired is not strictly necessary if we check it and print help as above
	// generateTasksCmd.MarkFlagRequired("file")
}
</file>

</files>
